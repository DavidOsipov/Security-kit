↑ Jump to Table of Contents <#toc>← Collapse Sidebar <#toc>

W3C <https://www.w3.org/>


  Web Cryptography API


    W3C Recommendation /26 January 2017/

This Version:
    https://www.w3.org/TR/2017/REC-WebCryptoAPI-20170126/ <https://
    www.w3.org/TR/2017/REC-WebCryptoAPI-20170126/>
Latest Published Version:
    https://www.w3.org/TR/WebCryptoAPI/ <https://www.w3.org/TR/
    WebCryptoAPI/>
Latest editor's draft:
    https://w3c.github.io/webcrypto/Overview.html <https://
    w3c.github.io/webcrypto/Overview.html>
Previous Version:
    https://www.w3.org/TR/2016/PR-WebCryptoAPI-20161215/ <https://
    www.w3.org/TR/2016/PR-WebCryptoAPI-20161215/>
Editor:
    Mark Watson <http://www.netflix.com/>, Netflix <watsonm@netflix.com>

*Errata <https://w3c.github.io/webcrypto/errata.html>* for this document
will be gathered from issues.

See also *translations* <http://www.w3.org/2003/03/Translations/
byTechnology?technology=WebCryptoAPI>.

Participate:
    We are on GitHub <https://github.com/w3c/webcrypto>. 
    Send feedback to public-web-security@w3.org <mailto:public-web-
    security@w3.org?subject=%5BWebCryptoAPI%5D> (archives <http://
    lists.w3.org/Archives/Public/public-web-security/>). 
    File a bug <https://github.com/w3c/webcrypto/issues/new> (see
    existing bugs <https://github.com/w3c/webcrypto/issues>). 

Copyright <https://www.w3.org/Consortium/Legal/ipr-notice#Copyright> ©
2012-2017 W3C <https://www.w3.org/>^® (MIT <https://www.csail.mit.edu/>,
ERCIM <https://www.ercim.eu/>, Keio <https://www.keio.ac.jp/>, Beihang
<http://ev.buaa.edu.cn/>). W3C liability <https://www.w3.org/Consortium/
Legal/ipr-notice#Legal_Disclaimer>, trademark <https://www.w3.org/
Consortium/Legal/ipr-notice#W3C_Trademarks> and document use <https://
www.w3.org/Consortium/Legal/copyright-documents> rules apply.

------------------------------------------------------------------------


    Abstract

This specification describes a JavaScript API for performing basic
cryptographic operations in web applications, such as hashing, signature
generation and verification, and encryption and decryption.
Additionally, it describes an API for applications to generate and/or
manage the keying material necessary to perform these operations. Uses
for this API range from user or service authentication, document or code
signing, and the confidentiality and integrity of communications.


    Status of this Document

/This section describes the status of this document at the time of its
publication. Other documents may supersede this document. A list of
current W3C publications and the latest revision of this technical
report can be found in the W3C technical reports index <https://
www.w3.org/TR/> at https://www.w3.org/TR/. /

This document is a W3C *Recommendation* of the Web Cryptography API
specification. This document is produced by the Web Cryptography WG
<https://www.w3.org/2012/webcrypto/> of the W3C.

An implementation report <https://rawgit.com/w3c/webcrypto/master/PR-
test-report.html> is also available (as well as reports sent to the
mailing list <https://www.w3.org/Search/Mail/Public/search?type-
index=public-webcrypto&index-type=t&keywords=testing&search=Search>).

Ongoing discussion will be on the public-web-security@w3.org
<mailto:public-web-security@w3.org> mailing list (archives <http://
lists.w3.org/Archives/Public/public-web-security/>).

This document has been reviewed by W3C Members, by software developers,
and by other W3C groups and interested parties, and is endorsed by the
Director as a W3C Recommendation. It is a stable document and may be
used as reference material or cited from another document. W3C's role in
making the Recommendation is to draw attention to the specification and
to promote its widespread deployment. This enhances the functionality
and interoperability of the Web.

This document was produced by a group operating under the 5 February
2004 W3C Patent Policy <https://www.w3.org/Consortium/Patent-
Policy-20040205/>. W3C maintains a public list of any patent disclosures
<https://www.w3.org/2004/01/pp-impl/54174/status> made in connection
with the deliverables of the group; that page also includes instructions
for disclosing a patent. An individual who has actual knowledge of a
patent which the individual believes contains Essential Claim(s)
<https://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential>
must disclose the information in accordance with section 6 of the W3C
Patent Policy <https://www.w3.org/Consortium/Patent-Policy-20040205/
#sec-Disclosure>.

This document is governed by the 1 September 2015 W3C Process Document
<https://www.w3.org/2015/Process-20150901/>.


    Table of Contents

  * 1. Introduction <#introduction>
  * 2. Use Cases <#use-cases>
      o 2.1. Multi-factor Authentication <#multifactor-authentication>
      o 2.2. Protected Document Exchange <#protected-document>
      o 2.3. Cloud Storage <#cloud-storage>
      o 2.4. Document Signing <#document-signing>
      o 2.5. Data Integrity Protection <#data-integrity-protection>
      o 2.6. Secure Messaging <#secure-messaging>
      o 2.7. JavaScript Object Signing and Encryption (JOSE) <#jose>
  * 3. Conformance <#conformance>
      o 3.1. Extensibility <#extensibility>
  * 4. Scope <#scope>
      o 4.1. Level of abstraction <#scope-abstraction>
      o 4.2. Cryptographic algorithms <#scope-algorithms>
      o 4.3. Out of scope <#scope-out-of-scope>
  * 5. Concepts <#concepts>
      o 5.1. Underlying Cryptographic Implementation <#concepts-
        underlying-implementation>
      o 5.2. Key Storage <#concepts-key-storage>
  * 6. Security considerations <#security-considerations>
      o 6.1. Security considerations for implementers <#security-
        implementers>
      o 6.2. Security considerations for authors <#security-developers>
      o 6.3. Security considerations for users <#security-users>
  * 7. Privacy considerations <#privacy>
  * 8. Dependencies <#dependencies>
  * 9. Terminology <#terminology>
  * 10. Crypto interface <#crypto-interface>
      o 10.1. Description <#Crypto-description>
      o 10.2. Methods and Parameters <#Crypto-interface-methods>
          + 10.2.1. The getRandomValues method <#Crypto-method-
            getRandomValues>
      o 10.3. Attributes <#Crypto-interface-attributes>
          + 10.3.1. The subtle attribute <#Crypto-attribute-subtle>
  * 11. Algorithm dictionary <#algorithm-dictionary>
      o 11.1. Algorithm Dictionary Members <#algorithm-dictionary-members>
  * 12. KeyAlgorithm dictionary <#key-algorithm-dictionary>
      o 12.1. Description <#key-algorithm-dictionary-description>
      o 12.2. KeyAlgorithm dictionary members <#key-algorithm-
        dictionary-members>
  * 13. CryptoKey interface <#cryptokey-interface>
      o 13.1. Description <#cryptokey-interface-description>
      o 13.2. Key interface data types <#cryptokey-interface-types>
      o 13.3. CryptoKey internal slots <#cryptokey-interface-internal-slots>
      o 13.4. CryptoKey interface members <#cryptokey-interface-members>
      o 13.5. Structured clone algorithm <#cryptokey-interface-clone>
  * 14. SubtleCrypto interface <#subtlecrypto-interface>
      o 14.1. Description <#subtlecrypto-interface-description>
      o 14.2. Data Types <#subtlecrypto-interface-datatypes>
      o 14.3. Methods and Parameters <#subtlecrypto-interface-methods>
          + 14.3.1. The encrypt method <#SubtleCrypto-method-encrypt>
          + 14.3.2. The decrypt method <#SubtleCrypto-method-decrypt>
          + 14.3.3. The sign method <#SubtleCrypto-method-sign>
          + 14.3.4. The verify method <#SubtleCrypto-method-verify>
          + 14.3.5. The digest method <#SubtleCrypto-method-digest>
          + 14.3.6. The generateKey method <#SubtleCrypto-method-
            generateKey>
          + 14.3.7. The deriveKey method <#SubtleCrypto-method-deriveKey>
          + 14.3.8. The deriveBits method <#SubtleCrypto-method-deriveBits>
          + 14.3.9. The importKey method <#SubtleCrypto-method-importKey>
          + 14.3.10. The exportKey method <#SubtleCrypto-method-exportKey>
          + 14.3.11. The wrapKey method <#SubtleCrypto-method-wrapKey>
          + 14.3.12. The unwrapKey method <#SubtleCrypto-method-unwrapKey>
      o 14.4. Exceptions <#SubtleCrypto-Exceptions>
  * 15. JsonWebKey dictionary <#JsonWebKey-dictionary>
  * 16. BigInteger <#big-integer>
  * 17. CryptoKeyPair dictionary <#keypair>
  * 18. Algorithms <#algorithms>
      o 18.1. Overview <#algorithms-section-overview>
      o 18.2. Concepts <#algorithm-concepts>
          + 18.2.1. Naming <#algorithm-concepts-naming>
          + 18.2.2. Supported Operations <#algorithm-concepts-operations>
          + 18.2.3. Normalization <#algorithm-concepts-normalization>
      o 18.3. Specification Conventions <#algorithm-conventions>
      o 18.4. Algorithm Normalization <#algorithm-normalization>
          + 18.4.1. Description <#algorithm-normalization-description>
          + 18.4.2. Internal State Objects <#algorithm-normalization-
            internal>
          + 18.4.3. Defining an Algorithm <#algorithm-normalization-
            define-an-algorithm>
          + 18.4.4. Normalizing an algorithm <#algorithm-normalization-
            normalize-an-algorithm>
      o 18.5. Recommendations <#algorithm-recommendations>
          + 18.5.1. For Authors <#algorithm-recommendations-authors>
          + 18.5.2. For Implementers <#algorithm-recommendations-
            implementers>
  * 19. Algorithm Overview <#algorithm-overview>
  * 20. RSASSA-PKCS1-v1_5 <#rsassa-pkcs1>
      o 20.1. Description <#rsassa-pkcs1-description>
      o 20.2. Registration <#rsassa-pkcs1-registration>
      o 20.3. RsaKeyGenParams dictionary <#RsaKeyGenParams-dictionary>
      o 20.4. RsaHashedKeyGenParams dictionary <#RsaHashedKeyGenParams-
        dictionary>
      o 20.5. RsaKeyAlgorithm dictionary <#RsaKeyAlgorithm-dictionary>
      o 20.6. RsaHashedKeyAlgorithm dictionary <#RsaHashedKeyAlgorithm-
        dictionary>
      o 20.7. RsaHashedImportParams dictionary <#RsaHashedImportParams-
        dictionary>
      o 20.8. Operations <#rsassa-pkcs1-operations>
  * 21. RSA-PSS <#rsa-pss>
      o 21.1. Description <#rsa-pss-description>
      o 21.2. Registration <#rsa-pss-registration>
      o 21.3. RsaPssParams dictionary <#RsaPssParams-dictionary>
      o 21.4. Operations <#rsa-pss-operations>
  * 22. RSA-OAEP <#rsa-oaep>
      o 22.1. Description <#rsa-oaep-description>
      o 22.2. Registration <#rsa-oaep-registration>
      o 22.3. RsaOaepParams dictionary <#rsa-oaep-params>
      o 22.4. Operations <#rsa-oaep-operations>
  * 23. ECDSA <#ecdsa>
      o 23.1. Description <#ecdsa-description>
      o 23.2. Registration <#ecdsa-registration>
      o 23.3. EcdsaParams dictionary <#EcdsaParams-dictionary>
      o 23.4. EcKeyGenParams dictionary <#EcKeyGenParams-dictionary>
      o 23.5. EcKeyAlgorithm dictionary <#EcKeyAlgorithm-dictionary>
      o 23.6. EcKeyImportParams dictionary <#EcKeyImportParams-dictionary>
      o 23.7. Operations <#ecdsa-operations>
  * 24. ECDH <#ecdh>
      o 24.1. Description <#ecdh-description>
      o 24.2. Registration <#ecdh-registration>
      o 24.3. EcdhKeyDeriveParams dictionary <#dh-EcdhKeyDeriveParams>
      o 24.4. Operations <#ecdh-operations>
  * 25. AES-CTR <#aes-ctr>
      o 25.1. Description <#aes-ctr-description>
      o 25.2. Registration <#aes-ctr-registration>
      o 25.3. AesCtrParams dictionary <#aes-ctr-params>
      o 25.4. <#AesKeyAlgorithm-dictionary>
      o 25.5. AesKeyGenParams dictionary <#aes-keygen-params>
      o 25.6. AesDerivedKeyParams dictionary <#aes-derivedkey-params>
      o 25.7. Operations <#aes-ctr-operations>
  * 26. AES-CBC <#aes-cbc>
      o 26.1. Description <#aes-cbc-description>
      o 26.2. Registration <#aes-cbc-registration>
      o 26.3. AesCbcParams dictionary <#aes-cbc-params>
      o 26.4. Operations <#aes-cbc-operations>
  * 27. AES-GCM <#aes-gcm>
      o 27.1. Description <#aes-gcm-description>
      o 27.2. Registration <#aes-gcm-registration>
      o 27.3. AesGcmParams dictionary <#aes-gcm-params>
      o 27.4. Operations <#aes-gcm-operations>
  * 28. AES-KW <#aes-kw>
      o 28.1. Description <#aes-kw-description>
      o 28.2. Registration <#aes-kw-registration>
      o 28.3. Operations <#aes-kw-operations>
  * 29. HMAC <#hmac>
      o 29.1. Description <#hmac-description>
      o 29.2. Registration <#hmac-registration>
      o 29.3. HmacImportParams dictionary <#hmac-importparams>
      o 29.4. HmacKeyAlgorithm dictionary <#HmacKeyAlgorithm-dictionary>
      o 29.5. HmacKeyGenParams dictionary <#hmac-keygen-params>
      o 29.6. Operations <#hmac-operations>
  * 30. SHA <#sha>
      o 30.1. Description <#sha-description>
      o 30.2. Registration <#sha-registration>
      o 30.3. Operations <#sha-operations>
  * 31. HKDF <#hkdf>
      o 31.1. Description <#hkdf-description>
      o 31.2. Registration <#hkdf-registration>
      o 31.3. HkdfParams dictionary <#hkdf-params>
      o 31.4. Operations <#hkdf2-operations>
  * 32. PBKDF2 <#pbkdf2>
      o 32.1. Description <#pbkdf2-description>
      o 32.2. Registration <#pbkdf2-registration>
      o 32.3. Pbkdf2Params dictionary <#pbkdf2-params>
      o 32.4. Operations <#pbkdf2-operations>
  * 33. JavaScript Example Code <#examples-section>
      o 33.1. Generate a signing key pair, sign some data <#examples-
        signing>
      o 33.2. Symmetric Encryption <#examples-symmetric-encryption>
  * 34. IANA Considerations <#iana-section>
      o 34.1. JSON Web Signature and Encryption Algorithms Registration
        <#iana-section-jws-jwa>
      o 34.2. JSON Web Key Parameters Registration <#iana-section-jwk>
  * 35. Acknowledgments <#acknowledgements-section>
  * 36. References <#references>
      o 36.1. Normative References <#normative-references>
      o 36.2. Informative References <#informative-references>

  * A. Mapping between JSON Web Key / JSON Web Algorithm <#jwk-mapping>
      o A.1. Algorithm mappings <#jwk-mapping-alg>
  * B. Mapping between Algorithm and SubjectPublicKeyInfo <#spki-mapping>
  * C. Mapping between Algorithm and PKCS#8 PrivateKeyInfo <#pkcs8-mapping>


    1. Introduction ¶ <#introduction>

This section is non-normative.

The Web Cryptography API defines a low-level interface to interacting
with cryptographic key material that is managed or exposed by user
agents. The API itself is agnostic of the underlying implementation of
key storage, but provides a common set of interfaces that allow rich web
applications to perform operations such as signature generation and
verification, hashing and verification, encryption and decryption,
without requiring access to the raw keying material.

Cryptographic transformations are exposed via the SubtleCrypto <#dfn-
SubtleCrypto> interface, which defines a set of methods for performing
common cryptographic operations. In addition to operations such as
signature generation and verification, hashing and verification, and
encryption and decryption, the API provides interfaces for key
generation, key derivation and key import and export.


    2. Use Cases ¶ <#use-cases>

This section is non-normative.


      2.1. Multi-factor Authentication ¶ <#multifactor-authentication>

A web application may wish to extend or replace existing username/
password based authentication schemes with authentication methods based
on proving that the user has access to some secret keying material.
Rather than using transport-layer authentication, such as TLS client
certificates, the web application may prefer the richer user experience
provided by authenticating within the application itself.

Using the Web Cryptography API, the application could locate suitable
client keys, which may have been previously generated via the user agent
or pre-provisioned out-of-band by the web application. It could then
perform cryptographic operations such as decrypting an authentication
challenge followed by signing an authentication response.

This exchange could be further strengthened by binding the
authentication to the TLS session over which the client is
authenticating, by deriving a key based on properties of the underlying
transport.

If a user does not already have a key associated with their account, the
web application could direct the user agent to either generate a new key
or to re-use an existing key of the user's choice.


      2.2. Protected Document Exchange ¶ <#protected-document>

A web application may wish to limit the viewership of documents that
contain sensitive or personal information, even when these documents
have been securely received, such as over TLS.

Using the Web Cryptography API, the application could do so by
encrypting the documents with a secret key, and then wrapping that key
with the public keys associated with the authorized viewers. When a user
agent navigates to such a web application, the application would send
the encrypted form of the document. The user agent is then instructed to
unwrap the encryption key, using the user's private key, and from there,
decrypt and display the document.


      2.3. Cloud Storage ¶ <#cloud-storage>

A web application may wish to permit users to protect the
confidentiality of data and documents stored with remote service
providers prior to uploading.

Using the Web Cryptography API, the application may have a user select a
private or secret key, optionally derive an encryption key from the
selected key, encrypt the document, and then upload the encrypted data
to the service provider using existing APIs.

This use case is similar to the Protected Document Exchange <#protected-
document> use case, with viewership of the document limited to the user
themself.


      2.4. Document Signing ¶ <#document-signing>

A web application may wish to accept electronic signatures on documents,
in lieu of requiring physical signatures.

Using the Web Cryptography API, the application may direct the user to
select a key, which may have been pre-provisioned out-of-band, or
generated specifically for the web application. Using this key, the
application may perform a signing operation over some data, as proof
that the user accepts the document.


      2.5. Data Integrity Protection ¶ <#data-integrity-protection>

A web application may wish to cache data locally, while ensuring that
this data cannot be modified in an offline attack.

Using the Web Cryptography API, the application may use a public key
contained within the application to verify the contents of the data
cache. Previously, when data was added to the cache, it would have been
signed by the server with the corresponding private key. By validating
the signature when restoring data from the cache, the client ensures
that the cached data has not been tampered with.


      2.6. Secure Messaging ¶ <#secure-messaging>

A web application may wish to employ message layer security using
schemes such as off-the-record (OTR) messaging, even when these messages
have been securely received, such as over TLS.

The Web Cryptography API enables OTR and similar message signing
schemes, by allowing key agreement to be performed. The two parties can
negotiate shared encryption keys and message authentication code (MAC)
keys, to allow encryption and decryption of messages, and to prevent
tampering.


      2.7. JavaScript Object Signing and Encryption (JOSE) ¶ <#jose>

A web application may wish to interact with the structures and message
formats defined by the IETF JavaScript Object Signing and Encryption
(JOSE) Working Group.

Using the Web Cryptography API, the application may read and import keys
encoded in the JSON key format (JWK), validate messages that have been
integrity protected using digital signatures or MACs (JWS), or decrypt
messages that have been encrypted (JWE).


    3. Conformance ¶ <#conformance>

As well as sections marked as non-normative, all authoring guidelines,
diagrams, examples, and notes in this specification are non-normative.
Everything else in this specification is normative.

The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, RECOMMENDED,
MAY, OPTIONAL, in this specification are to be interpreted as described
in Key words for use in RFCs to Indicate Requirement Levels <http://
www.ietf.org/rfc/rfc2119> [RFC2119 <#RFC2119>].

The following conformance classes are defined by this specification:

conforming user agent

    A user agent is considered to be a conforming user agent <#dfn-
    conforming-implementation> if it satisfies all of the MUST-,
    REQUIRED- and SHALL-level criteria in this specification that apply
    to implementations. This specification uses both the terms
    "conforming user agent" and "user agent" to refer to this product
    class.

Conformance requirements phrased as algorithms or specific steps may be
implemented in any manner, so long as the end result is equivalent. (In
particular, the algorithms defined in this specification are intended to
be easy to follow, and not intended to be performant.)

User agents that use ECMAScript to implement the APIs defined in this
specification MUST implement them in a manner consistent with the
ECMAScript Bindings defined in the Web IDL specification [WebIDL
<#WebIDL>] as this specification uses that specification and terminology.

Unless otherwise stated, string comparisons are done in a case-sensitive
<#case-sensitive> manner. String literals in this specification written
in monospace font like |"this"| do not include the enclosing quotes.


      3.1. Extensibility ¶ <#extensibility>

Vendor-specific proprietary extensions to this specification are
strongly discouraged. Authors must not use such extensions, as doing so
reduces interoperability and fragments the user base, allowing only
users of specific user agents to access the content in question.

If vendor-specific extensions are needed, the members should be prefixed
by vendor-specific strings to prevent clashes with future versions of
this specification. Extensions must be defined so that the use of
extensions neither contradicts nor causes the non-conformance of
functionality defined in the specification.

When vendor-neutral extensions to this specification are needed, either
this specification can be updated accordingly, or an extension
specification can be written that overrides the requirements in this
specification. When someone applying this specification to their
activities decides that they will recognize the requirements of such an
extension specification, it becomes an applicable specification for the
purposes of conformance requirements in this specification. Applicable
specifications defined by the W3C Web Cryptography Working Group are
listed in the table below.

Specification 	Reference

Note
Readers are advised to consult the errata to this specification for
updates to the table above.


    4. Scope ¶ <#scope>

This section is non-normative.


      4.1. Level of abstraction ¶ <#scope-abstraction>

The specification attempts to focus on the common functionality and
features between various platform-specific or standardized cryptographic
APIs, and avoid features and functionality that are specific to one or
two implementations. As such this API allows key generation, management,
and exchange with a level of abstraction that avoids developers needing
to care about the implementation of the underlying key storage. The API
is focused specifically around CryptoKey objects, as an abstraction for
the underlying raw cryptographic keying material. The intent behind this
is to allow an API that is generic enough to allow conforming user
agents to expose keys that are stored and managed directly by the user
agent, that may be stored or managed using isolated storage APIs such as
per-user key stores provided by some operating systems, or within key
storage devices such as secure elements, while allowing rich web
applications to manipulate the keys and without requiring the web
application be aware of the nature of the underlying key storage.


      4.2. Cryptographic algorithms ¶ <#scope-algorithms>

Because the underlying cryptographic implementations will vary between
conforming user agents, and may be subject to local policy, including
but not limited to concerns such as government or industry regulation,
security best practices, intellectual property concerns, and constrained
operational environments, this specification does not dictate a
mandatory set of algorithms that MUST be implemented. Instead, it
defines a common set of bindings that can be used in an algorithm-
independent manner, a common framework for discovering if a user agent
or key handle supports the underlying algorithm, and a set of
conformance requirements for the behaviors of individual algorithms, if
implemented.


      4.3. Out of scope ¶ <#scope-out-of-scope>

This API, while allowing applications to generate, retrieve, and
manipulate keying material, does not specifically address the
provisioning of keys in particular types of key storage, such as secure
elements or smart cards. This is due to such provisioning operations
often being burdened with vendor-specific details that make defining a
vendor-agnostic interface an unsuitably unbounded task. Additionally,
this API does not deal with or address the discovery of cryptographic
modules, as such concepts are dependent upon the underlying user agent
and are not concepts that are portable between common operating systems,
cryptographic libraries, and implementations.


    5. Concepts ¶ <#concepts>

This section is non-normative.


      5.1. Underlying Cryptographic Implementation ¶ <#concepts-
      underlying-implementation>

This specification assumes, but does not require, that conforming user
agents do not and will not be directly implementing cryptographic
operations within the user agent itself. Historically, many user agents
have deferred cryptographic operations, such as those used within TLS,
to existing APIs that are available as part of the underlying operating
system or to third-party modules that are managed independently of the
user agent.

The CryptoKey <#dfn-CryptoKey> object represents the bridge between the
JavaScript execution environment and these underlying libraries, through
the use of the internal slot named [[handle <#dfn-CryptoKey-slot-
handle>]]. The handle represents an opaque type that is implementation
specific, which may not be represented within a JavaScript type, nor is
it ever exposed to script authors. In this way, the CryptoKey <#dfn-
CryptoKey> object is the conceptual equivalent to the JavaScript
executing environment as the [[handle <#dfn-CryptoKey-slot-handle>]] is
to the underlying cryptographic implementation.

These APIs are traditionally built around a notion of cryptographic
providers, an abstraction for a specific implementation of a set of
algorithms. The operating system or library may come with a default
provider, and users are frequently allowed to add additional providers,
reconfigure the set of enabled algorithms, or otherwise customize how
cryptographic services are provided.

While it is assumed that most user agents will be interacting with a
cryptographic provider that is implemented purely in software, it is not
required by this specification. As a result, the capabilities of some
implementations may be limited by the capabilities of the underlying
hardware, and, depending on how the user has configured the underlying
cryptographic library, this may be entirely opaque to the User Agent.


      5.2. Key Storage ¶ <#concepts-key-storage>

This specification does not explicitly provide any new storage
mechanisms for CryptoKey <#dfn-CryptoKey> objects. Instead, by allowing
the CryptoKey <#dfn-CryptoKey> to be used with the structured clone
algorithm, any existing or future web storage mechanisms that support
storing structured clonable objects can be used to store CryptoKey
<#dfn-CryptoKey> objects.

In practice, it is expected that most authors will make use of the
Indexed Database API <#IndexedDB>, which allows associative storage of
key/value pairs, where the key is some string identifier meaningful to
the application, and the value is a CryptoKey <#dfn-CryptoKey> object.
This allows the storage and retrieval of key material, without ever
exposing that key material to the application or the JavaScript
environment. Additionally, this allows authors the full flexibility to
store any additional metadata with the CryptoKey <#dfn-CryptoKey> itself.


    6. Security considerations ¶ <#security-considerations>

This section is non-normative.


    6.1. Security considerations for implementers ¶ <#security-implementers>

By not providing an explicit storage mechanism, this specification
assumes that CryptoKey <#dfn-CryptoKey> objects are scoped to the
current execution environment and any storage mechanisms available to
that environment (e.g. Indexed Database API <#IndexedDB>). Application
authors rely upon this for the security of their applications; two
origins with the same CryptoKey <#dfn-CryptoKey> object have full access
to the underlying key, and as such, messages from these applications
cannot be distinguished, and messages sent to these applications can be
fully recovered. Implementors should ensure that no CryptoKey <#dfn-
CryptoKey> objects are shared between two origins unless the author has
explicitly chosen to share (e.g., such as through the use of postMessage)

A number of algorithms specified within this specification perform
computationally intensive work, such as the generation of significantly
large prime numbers, or through repeated iterations of a particular
operation. As such, hostile applications may attempt to misuse this API
and attempt to cause significant amount of work to be performed by an
implementation, denying access or services to other applications that
are executing. Implementations should take steps to mitigate these
risks, such as limiting the amount of operations an implementation
performs concurrently, requiring user consent for operations that may be
known to be disruptive for the executing environment, or defining
device-specific limits on attributes such as key sizes or iteration counts.


    6.2. Security considerations for authors ¶ <#security-developers>

This specification includes descriptions for a variety of cryptographic
operations, some of which have known weaknesses when used
inappropriately. Application developers must take care and review
appropriate and current cryptographic literature, to understand and
mitigate such issues. In general, application developers are *strongly*
discouraged from inventing new cryptographic protocols; as with all
applications, users of this specification will be best served through
the use of existing protocols, of which this specification provides the
necessary building blocks to implement.

In order to use the APIs defined in this specification to provide any
meaningful cryptographic assurances, authors must be familiar with
existing threats to web applications, as well as the underlying security
model employed. Conceptually, issues such as script injection are the
equivalent to remote code execution in other operating environments, and
allowing hostile script to be injected may allow for the exfiltration of
keys or data. Script injection may come from other applications, for
which the judicious use of Content Security Policy may mitigate, or it
may come from hostile network intermediaries, for which the use of
Transport Layer Security may mitigate.

This specification does not define any specific mechanisms for the
storage of cryptographic keys. By default, unless specific effort is
taken by the author to persist keys, such as through the use of the
Indexed Database API <#IndexedDB>, keys created with this API will only
be valid for the duration of the current page (e.g. until a navigation
event). Authors that wish to use the same key across different pages or
multiple browsing sessions must employ existing web storage
technologies. Authors should be aware of the security assumptions of
these technologies, such as the same-origin security model; that is, any
application that shares the same scheme, host, and port have access to
the same storage partition, even if other information, such as the path,
may differ. Authors may explicitly choose to relax this security through
the use of inter-origin sharing, such as |postMessage|.

Authors should be aware that this specification places no normative
requirements on implementations as to how the underlying cryptographic
key material is stored. The only requirement is that key material is not
exposed to script, except through the use of the exportKey <#dfn-
SubtleCrypto-method-exportKey> and wrapKey <#dfn-SubtleCrypto-method-
wrapKey> operations. In particular, it does not guarantee that the
underlying cryptographic key material will not be persisted to disk,
possibly unencrypted, nor that it will be inaccessible to users or other
applications running with the same privileges as the User Agent. Any
application or user that has access to the device storage may be able to
recover the key material, even through scripts may be prohibited.

This specification places no normative requirements on how
implementations handle key material once all references to it go away.
That is, conforming user agents are not required to zeroize key
material, and it may still be accessible on device storage or device
memory, even after all references to the CryptoKey <#dfn-CryptoKey> have
gone away.

Applications may share a CryptoKey <#dfn-CryptoKey> object across
security boundaries, such as origins, through the use of the structured
clone algorithm and APIs such as |postMessage|. While access to the
underlying cryptographic key material may be restricted, based upon the
extractable <#dfn-CryptoKey-extractable> attribute, once a key is shared
with a destination origin, the source origin can not later restrict or
revoke access to the key. As such, authors must be careful to ensure
they trust the destination origin to take the same mitigations against
hostile script that the source origin employs. Further, in the event of
script injection on the source origin, attackers may post the key to an
origin under attacker control. Any time that the user agent visits the
attacker's origin, the user agent may be directed to perform
cryptographic operations using that key, such as the decryption of
existing messages or the creation of new, fraudulent messages.

Authors should be aware that users may, at any time, choose to clear the
storage associated with an origin, potentially destroying keys.
Applications that are meant to provide long-term storage, such as on the
server, should consider techniques such as key escrow to prevent such
data from being inaccessible. Authors should not presume that keys will
be available indefinitely.


      6.3. Security considerations for users ¶ <#security-users>

Users of applications that employ the APIs defined in this specification
should be aware that these applications will have full access to all
messages exchanged, regardless of the cryptography employed. That is,
for messages that are encrypted, applications that use these APIs will
have full access to the decrypted message as well.


    7. Privacy considerations ¶ <#privacy>

This section is non-normative.

Fingerprinting
    By exposing additional APIs that reflect capabilities of the
    underlying platform, this specification may allow malicious
    applications to determine or distinguish different user agents or
    devices. 
Super-cookies
    This specification does not provide any means for malicious
    applications to create identifiers that outlive existing web storage
    technologies. However, care must be taken when introducing future
    revisions to this API or additional cryptographic capabilities, such
    as those that are hardware backed (e.g.: smart cards or Trusted
    Platform Modules). Considering that such storage is designed to
    prevent any two users from having the same underlying key data, such
    APIs may represent a real risk of being used as a permanent
    identifier against the user's wishes. 


      8. Dependencies ¶ <#dependencies>

This specification relies on underlying specifications.

DOM

    A conforming user agent <#dfn-conforming-implementation> MUST
    support at least the subset of the functionality defined in DOM4
    that this specification relies upon; in particular, it MUST support
    |Promises| and DOMException. [DOM4 <#DOM4>]

HTML

    A conforming user agent <#dfn-conforming-implementation> MUST
    support at least the subset of the functionality defined in HTML
    that this specification relies upon; in particular, it MUST support
    the ArrayBufferView <#dfn-ArrayBufferView> typedef and the
    structured clone <#dfn-structured-clone> algorithm. [HTML <#HTML>]

Web IDL

    A conforming user agent <#dfn-conforming-implementation> MUST be a
    conforming implementation of the IDL fragments in this
    specification, as described in the Web IDL specification. [WebIDL
    <#WebIDL>]


    9. Terminology ¶ <#terminology>

The terms and algorithms ArrayBuffer, ArrayBufferView, and structured
clone, are defined by the HTML specification [HTML <#HTML>].

The terms DOMString and BufferSource are defined in [WebIDL <#WebIDL>].

An octet string is an ordered sequence of zero or more integers, each in
the range 0 to 255 inclusive.

An octet string containing a bit string b is the octet string <#dfn-
octet-string> obtained by first appending zero or more bits of value
zero to b such that the length of the resulting bit string is minimal
and an integer multiple of 8 and then considering each consecutive
sequence of 8 bits in that string as a binary integer, most significant
bit first.

When this specification says to convert a non-negative integer i to an
octet string of length n, where n * 8 is greater than the logarithm to
base 2 of i, the user agent must first calculate the binary
representation of i, most significant bit first, prefix this with
sufficient zero bits to form a bit string of length n * 8, and then
return the octet string <#dfn-octet-string> formed by considering each
consecutive sequence of 8 bits in that bit string as a binary integer,
most significant bit first.

Comparing two strings in a case-sensitive manner means comparing them
exactly, code point for code point.

Comparing two strings in a ASCII case-insensitive manner means comparing
them exactly, code point for code point, except that the codepoints in
the range U+0041 .. U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL
LETTER Z) and the corresponding codepoints in the range U+0061 .. U+007A
(i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are also considered
to match.

When this specification says to terminate the algorithm, the user agent
must terminate the algorithm after finishing the step it is on. The
algorithm referred to is the set of specification-defined processing
steps, rather than the underlying cryptographic algorithm that may be in
the midst of processing.

When this specification says to parse an ASN.1 structure, the user agent
must perform the following steps:

 1.

    Let data be a sequence of bytes to be parsed.

 2.

    Let structure be the ASN.1 structure to be parsed.

 3.

    Let exactData be an optional boolean value. If it is not supplied,
    let it be initialized to |true|.

 4.

    Parse data according to the Distinguished Encoding Rules of X.690
    (11/08) <#X690>, using structure as the ASN.1 structure to be decoded.

 5.

    If exactData was specified, and all of the bytes of data were not
    consumed during the parsing phase, then throw <#concept-throw> a |
    DataError| <#dfn-DataError>.

 6.

    Return the parsed ASN.1 structure.

When this specification says to parse a subjectPublicKeyInfo, the user
agent must parse an ASN.1 structure <#concept-parse-an-asn1-structure>,
with data set to the sequence of bytes to be parsed, structure as the
ASN.1 structure of subjectPublicKeyInfo, as specified in RFC 5280
<#RFC5280>, and exactData set to |true|.

When this specification says to parse a PrivateKeyInfo, the user agent
must parse an ASN.1 structure <#concept-parse-an-asn1-structure> with
data set to the sequence of bytes to be parsed, structure as the ASN.1
structure of PrivateKeyInfo, as specified in RFC 5208 <#RFC5208>, and
exactData set to |true|.

When this specification says to parse a JWK, the user agent must run the
following steps:

 1.

    Let data be the sequence of bytes to be parsed.

 2.

    Let json be the Unicode string that results from interpreting data
    according to UTF-8.

 3.

    Convert json to UTF-16.

 4.

    Let result be the object literal that results from executing the |
    JSON.parse| internal function in the context of a new global object,
    with |text| argument set to a JavaScript String containing json.

 5.

    Let key be the result of converting result to the IDL dictionary
    type of JsonWebKey <#dfn-JsonWebKey>.

 6.

    If the |"kty"| field of key is not defined, then throw <#concept-
    throw> a |DataError| <#dfn-DataError>.

 7.

    Return key.

When this specification states to supply the contents of an ArrayBuffer
named data to an underlying cryptographic implementation, the User Agent
shall supply a contiguous sequence of bytes that is equal to the result
of geting a copy of the bytes <http://heycam.github.io/webidl/#dfn-get-
buffer-source-copy> held data.

When this specification says to calculate the usage intersection of two
sequences, a and b the result shall be a sequence containing each
recognized key usage value <#dfn-RecognizedKeyUsage> that appears in
both a and b, in the order listed in the list of recognized key usage
values <#dfn-RecognizedKeyUsage>, where a value is said to appear in a
sequence if an element of the sequence exists that is a case-sensitive
string match for that value.

When this specification says to calculate the normalized value of a
usages list, usages the result shall be the usage intersection
<#concept-usage-intersection> of usages and a sequence containing all
recognized key usage values <#dfn-RecognizedKeyUsage>.

When this specification refers to the cached ECMAScript object
associated with an internal slot [[slot]] of object, the user agent must
run the following steps:

 1.

    If the [[slot_cached]] internal slot of object is undefined:
        Set the [[slot_cached]] internal slot of object to the result of
        performing type conversion to an ECMAScript object as defined in
        [WebIDL <#WebIDL>] to the contents of the [[slot]] internal slot
        of object. 

 2. Return the contents of the [[slot_cached]] internal slot of object.


    10. Crypto interface ¶ <#crypto-interface>

IDL

|
[NoInterfaceObject,Exposed=(Window,Worker)]
interface GlobalCrypto {
  readonly attribute Crypto <#dfn-Crypto> crypto;
};

Window implements GlobalCrypto;
WorkerGlobalScope implements GlobalCrypto;        
        
[Exposed=(Window,Worker)]
interface Crypto {
  [SecureContext] readonly attribute SubtleCrypto <#dfn-SubtleCrypto> subtle;
  ArrayBufferView getRandomValues <#dfn-Crypto-method-getRandomValues>(ArrayBufferView array);
};
        |


      10.1. Description ¶ <#Crypto-description>

This section is non-normative.

The Crypto <#dfn-Crypto> interface represents an interface to general
purpose cryptographic functionality including a cryptographically strong
pseudo-random number generator seeded with truly random values.

Note
Implementations should generate cryptographically random values using
well-established cryptographic pseudo-random number generators seeded
with high-quality entropy, such as from an operating-system entropy
source (e.g., "/dev/urandom"). This specification provides no lower-
bound on the information theoretic entropy present in cryptographically
random values, but implementations should make a best effort to provide
as much entropy as practicable.
Note
This interface defines a synchronous method for obtaining
cryptographically random values. While some devices and implementations
may support truly random cryptographic number generators or provide
interfaces that block when there is insufficient entropy,
implementations are discouraged from using these sources when
implementing getRandomValues, both for performance and to avoid
depleting the system of entropy. Instead, these sources should be used
to seed a cryptographic pseudo-random number generator that can then
return suitable values efficiently.


      10.2. Methods and Parameters ¶ <#Crypto-interface-methods>


        10.2.1. The getRandomValues method ¶ <#Crypto-method-
        getRandomValues>

The |getRandomValues| method generates cryptographically random values.
It must act as follows:

 1.

    If array is not of an integer type (i.e., Int8Array, Uint8Array,
    Int16Array, Uint16Array, Int32Array, Uint32Array or
    UInt8ClampedArray), throw <#concept-throw> a |TypeMismatchError| and
    terminate the algorithm <#terminate-the-algorithm>.

 2.

    If the |byteLength| of array is greater than 65536, throw <#concept-
    throw> a |QuotaExceededError| and terminate the algorithm
    <#terminate-the-algorithm>.

 3.

    Overwrite all elements of array with cryptographically random values
    of the appropriate type.

 4.

    Return array.

Note

Do not generate keys using the |getRandomValues| method. Use the |
generateKey| <#dfn-SubtleCrypto-method-generateKey> method instead.


      10.3. Attributes ¶ <#Crypto-interface-attributes>


        10.3.1. The subtle attribute ¶ <#Crypto-attribute-subtle>

The |subtle| attribute provides an instance of the SubtleCrypto <#dfn-
SubtleCrypto> interface which provides low-level cryptographic
primitives and algorithms.


    11. Algorithm dictionary ¶ <#algorithm-dictionary>

The Algorithm object is a dictionary object [WebIDL <#WebIDL>] which is
used to specify an algorithm and any additional parameters required to
fully specify the desired operation.

IDL

|
typedef (object or DOMString) AlgorithmIdentifier;

typedef AlgorithmIdentifier <#dfn-AlgorithmIdentifier> HashAlgorithmIdentifier;

dictionary Algorithm {
  required DOMString name <#dfn-Algorithm-name>;
};
        |


      11.1. Algorithm <#dfn-Algorithm> Dictionary Members ¶ <#algorithm-
      dictionary-members>

|name|
    The name of the registered algorithm <#algorithms> to use. 


    12. KeyAlgorithm dictionary ¶ <#key-algorithm-dictionary>

The KeyAlgorithm dictionary represents information about the contents of
a given CryptoKey <#dfn-CryptoKey> object.

IDL

|
dictionary KeyAlgorithm {
  required DOMString name <#dfn-KeyAlgorithm-name>;
};
        |


      12.1. Description ¶ <#key-algorithm-dictionary-description>

This section is non-normative.

The KeyAlgorithm <#dfn-KeyAlgorithm> dictionary is provided to aid in
documenting how fixed, public properties of a CryptoKey <#dfn-CryptoKey>
are reflected back to an application. The actual dictionary type is
never exposed to applications.


      12.2. KeyAlgorithm dictionary members ¶ <#key-algorithm-
      dictionary-members>

name
    The name of the algorithm used to generate the CryptoKey <#dfn-
    CryptoKey> 


    13. CryptoKey interface ¶ <#cryptokey-interface>

The CryptoKey object represents an opaque reference to keying material
that is managed by the user agent.

IDL

|
enum KeyType <#dfn-KeyType> { "public", "private", "secret" };

enum KeyUsage <#dfn-KeyUsage> { "encrypt", "decrypt", "sign", "verify", "deriveKey", "deriveBits", "wrapKey", "unwrapKey" };

[SecureContext,Exposed=(Window,Worker)]
interface CryptoKey {
  readonly attribute KeyType <#dfn-KeyType> type <#dfn-CryptoKey-type>;
  readonly attribute boolean extractable <#dfn-CryptoKey-extractable>;
  readonly attribute object algorithm <#dfn-CryptoKey-algorithm>;
  readonly attribute object usages <#dfn-CryptoKey-usages>;
};
        |


      13.1. Description ¶ <#cryptokey-interface-description>

This section is non-normative.

This specification provides a uniform interface for many different kinds
of keying material managed by the user agent. This may include keys that
have been generated by the user agent, derived from other keys by the
user agent, imported to the user agent through user actions or using
this API, pre-provisioned within software or hardware to which the user
agent has access or made available to the user agent in other ways. The
term key refers broadly to any keying material including actual keys for
cryptographic operations and secret values obtained within key
derivation or exchange operations.

The CryptoKey object is not required to directly interface with the
underlying key storage mechanism, and may instead simply be a reference
for the user agent to understand how to obtain the keying material when
needed, e.g. when performing a cryptographic operation.


      13.2. Key interface data types ¶ <#cryptokey-interface-types>

|KeyType|
    The type of a key. The recognized key type values are |"public"|,
    |"private"| and |"secret"|. Opaque keying material, including that
    used for symmetric algorithms, is represented by |"secret"|, while
    keys used as part of asymmetric algorithms composed of public/
    private keypairs will be either |"public"| or |"private"|. 
|KeyUsage|
    A type of operation that may be performed using a key. The
    recognized key usage values are |"encrypt"|, |"decrypt"|, |"sign"|,
    |"verify"|, |"deriveKey"|, |"deriveBits"|, |"wrapKey"| and
    |"unwrapKey"|. 


      13.3. CryptoKey internal slots ¶ <#cryptokey-interface-internal-slots>

Every |CryptoKey| object has a set of internal slots that store
information about the key. These slots are not exposed as part of this
specification; they represent internal state that an implementation uses
to implement this specification. The notational convention used in
[ECMA-262 <#ECMA-262>] is re-used here; internal slots are identified by
names enclosed in double square brackets [[ ]].

All |CryptoKey| objects have internal slots named [[type]],
[[extractable]], [[algorithm]], [[algorithm_cached]], [[usages]],
[[usages_cached]], and [[handle]].

The contents of the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
internal slot shall be, or be derived from, a KeyAlgorithm <#dfn-
KeyAlgorithm>. The contents of the [[usages <#dfn-CryptoKey-slot-
algorithm>]] internal slot shall be of type Sequence<KeyUsage>.

The [[handle <#dfn-CryptoKey-slot-handle>]] slot is an opaque type that
contains whatever data the underlying cryptographic implementation uses
to represent a logical key. Different cryptographic implementations may
use different types, ranging from opaque identifiers represented as
integers, pointer types, or structures that provide identifying
information. These handles are never exposed to applications.


      13.4. CryptoKey interface members ¶ <#cryptokey-interface-members>

|type|
    Reflects the [[type <#dfn-CryptoKey-slot-type>]] internal slot,
    which contains the type of the underlying key. 
|extractable|
    Reflects the [[extractable <#dfn-CryptoKey-slot-extractable>]]
    internal slot, which indicates whether or not the raw keying
    material may be exported by the application. 
|algorithm|
    Returns the cached ECMAScript object <#concept-cached-object>
    associated with the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
    internal slot. 
|usages|
    Returns the cached ECMAScript object <#concept-cached-object>
    associated with the [[usages <#dfn-CryptoKey-slot-usages>]] internal
    slot, which indicates which cryptographic operations are permissible
    to be used with this key. 


      13.5. Structured clone algorithm ¶ <#cryptokey-interface-clone>

When a user agent is required to obtain a structured clone <#dfn-
structured-clone> of a CryptoKey <#dfn-CryptoKey> object, it must run
the following steps.

 1. Let input and memory be the corresponding inputs defined by the
    internal structured cloning algorithm <#dfn-structured-clone>, where
    input represents a CryptoKey <#dfn-CryptoKey> object to be cloned.
 2. Let output be a newly constructed CryptoKey <#dfn-CryptoKey> object.
 3. Let the [[type <#dfn-CryptoKey-slot-type>]], [[extractable]] <#dfn-
    CryptoKey-slot-extractable>, [[algorithm]] <#dfn-CryptoKey-slot-
    algorithm>, and [[usages]] <#dfn-CryptoKey-slot-usages> internal
    slots of output be set to the result of invoking the internal
    structured clone algorithm recursively on the corresponding internal
    slots of input, with the slot contents as the new "input" argument
    and memory as the new "memory" argument.
 4. Let the [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of
    output refer to the same cryptographic key data represented by the
    [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of input.

Note
When performing the structured clone algorithm in order to serialize a |
CryptoKey| object, implementations must not allow the object to be
deserialized as a different type. This is normatively required by the
definition of structured clone, but it merits specific attention, as
such deserialization may expose the contents of the [[handle <#dfn-
CryptoKey-slot-handle>]] internal slot, which in some implementations
may contain cryptographic key data that should not be exposed to
applications.


    14. SubtleCrypto interface ¶ <#subtlecrypto-interface>

IDL

|
enum |KeyFormat| <#dfn-KeyFormat> { "raw", "spki", "pkcs8", "jwk" };

[SecureContext,Exposed=(Window,Worker)]
interface SubtleCrypto {
  Promise<any> encrypt <#dfn-SubtleCrypto-method-encrypt>(AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                       CryptoKey <#dfn-CryptoKey> key,
                       BufferSource data);
  Promise<any> decrypt <#dfn-SubtleCrypto-method-decrypt>(AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                       CryptoKey <#dfn-CryptoKey> key,
                       BufferSource data);
  Promise<any> sign <#dfn-SubtleCrypto-method-sign>(AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                    CryptoKey <#dfn-CryptoKey> key,
                    BufferSource data);
  Promise<any> verify <#dfn-SubtleCrypto-method-verify>(AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                      CryptoKey <#dfn-CryptoKey> key,
                      BufferSource signature,
                      BufferSource data);
  Promise<any> digest <#dfn-SubtleCrypto-method-digest>(AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                      BufferSource data);

  Promise<any> generateKey <#dfn-SubtleCrypto-method-generateKey>(AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                          boolean extractable,
                          sequence<KeyUsage <#dfn-KeyUsage>> keyUsages );
  Promise<any> deriveKey <#dfn-SubtleCrypto-method-deriveKey>(AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                         CryptoKey <#dfn-CryptoKey> baseKey,
                         AlgorithmIdentifier <#dfn-AlgorithmIdentifier> derivedKeyType,
                         boolean extractable,
                         sequence<KeyUsage <#dfn-KeyUsage>> keyUsages );
  Promise<ArrayBuffer <#dfn-ArrayBuffer>> deriveBits <#dfn-SubtleCrypto-method-deriveBits>(AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                          CryptoKey <#dfn-CryptoKey> baseKey,
                          unsigned long length);
  
  Promise<CryptoKey <#dfn-CryptoKey>> importKey <#dfn-SubtleCrypto-method-importKey>(KeyFormat <#dfn-KeyFormat> format,
                         (BufferSource or JsonWebKey) keyData,
                         AlgorithmIdentifier <#dfn-AlgorithmIdentifier> algorithm,
                         boolean extractable,
                         sequence<KeyUsage <#dfn-KeyUsage>> keyUsages );
  Promise<any> exportKey <#dfn-SubtleCrypto-method-exportKey>(KeyFormat <#dfn-KeyFormat> format, CryptoKey <#dfn-CryptoKey> key);

  Promise<any> wrapKey <#dfn-SubtleCrypto-method-wrapKey>(KeyFormat <#dfn-KeyFormat> format,
                       CryptoKey <#dfn-CryptoKey> key,
                       CryptoKey <#dfn-CryptoKey> wrappingKey,
                       AlgorithmIdentifier <#dfn-AlgorithmIdentifier> wrapAlgorithm);
  Promise<CryptoKey <#dfn-CryptoKey>> unwrapKey <#dfn-SubtleCrypto-method-unwrapKey>(KeyFormat <#dfn-KeyFormat> format,
                         BufferSource wrappedKey,
                         CryptoKey <#dfn-CryptoKey> unwrappingKey,
                         AlgorithmIdentifier <#dfn-AlgorithmIdentifier> unwrapAlgorithm,
                         AlgorithmIdentifier <#dfn-AlgorithmIdentifier> unwrappedKeyAlgorithm,
                         boolean extractable,
                         sequence<KeyUsage <#dfn-KeyUsage>> keyUsages );
};
        |


      14.1. Description ¶ <#subtlecrypto-interface-description>

This section is non-normative.

The SubtleCrypto <#dfn-SubtleCrypto> interface provides a set of methods
for dealing with low-level cryptographic primitives and algorithms. It
is named |SubtleCrypto| to reflect the fact that many of these
algorithms have subtle usage requirements in order to provide the
required algorithmic security guarantees.

For example, the direct use of an unauthenticated encryption scheme,
such as AES in counter mode <#aes-ctr>, gives potential attackers the
ability to manipulate bits in the output by manipulating bits in the
input, compromising the integrity of the message. However, AES-CTR can
be used securely in combination with other cryptographic primitives,
such as message authentication codes, to ensure the integrity of the
protected message, but only when the message authentication code is
constructed over the encrypted message and IV.

Developers making use of the SubtleCrypto interface are expected to be
aware of the security concerns associated with both the design and
implementation of the various algorithms provided. The raw algorithms
are provided in order to allow developers maximum flexibility in
implementing a variety of protocols and applications, each of which may
represent the composition and security parameters in a unique manner
that necessitate the use of the raw algorithms.


      14.2. Data Types ¶ <#subtlecrypto-interface-datatypes>

|KeyFormat|
    Specifies a serialization format for a key. The recognized key
    format values are:

    |"raw"|
        An unformatted sequence of bytes. Intended for secret keys.
    |"pkcs8"|
        The DER encoding of the PrivateKeyInfo structure from RFC 5208
        <#RFC5208>.
    |"spki"|
        The DER encoding of the SubjectPublicKeyInfo structure from RFC
        5280 <#RFC5280>.
    |"jwk"|
        The key is a JsonWebKey <#dfn-JsonWebKey> dictionary encoded as
        a JavaScript object


      14.3. Methods and Parameters ¶ <#subtlecrypto-interface-methods>

Unless otherwise stated, objects created by the methods defined in this
section shall be associated with the relevant global object <https://
www.w3.org/TR/html51/webappapis.html#relevant-global-object> of |this|
[HTML <#HTML>].

Note

All errors are reported asynchronously by rejecting the returned
Promise. This includes Web IDL type mapping errors.


        14.3.1. The encrypt method ¶ <#SubtleCrypto-method-encrypt>

The |encrypt| method returns a new Promise object that will encrypt data
using the specified |AlgorithmIdentifier| <#dfn-AlgorithmIdentifier>
with the supplied |CryptoKey| <#dfn-CryptoKey>. It must act as follows:

 1.

    Let algorithm and key be the |algorithm| and |key| parameters passed
    to the encrypt <#dfn-SubtleCrypto-method-encrypt> method, respectively.

 2.

    Let data be the result of getting a copy of the bytes <http://
    heycam.github.io/webidl/#dfn-get-buffer-source-copy> held by the |
    data| parameter passed to the encrypt <#dfn-SubtleCrypto-method-
    encrypt> method.

 3.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"encrypt"|.

 4.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 5.

    Let promise be a new Promise.

 6.

    Return promise and asynchronously perform the remaining steps.

 7.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 8.

    If the name <#dfn-Algorithm-name> member of normalizedAlgorithm is
    not equal to the name <#dfn-KeyAlgorithm-name> attribute of the
    [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of key
    then throw <#concept-throw> an |InvalidAccessError| <#dfn-
    InvalidAccessError>.

 9.

    If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of key
    does not contain an entry that is |"encrypt"|, then throw <#concept-
    throw> an |InvalidAccessError| <#dfn-InvalidAccessError>.

10.

    Let ciphertext be the result of performing the encrypt operation
    specified by normalizedAlgorithm using algorithm and key and with
    data as plaintext.

11.

    Resolve promise with ciphertext.


        14.3.2. The decrypt method ¶ <#SubtleCrypto-method-decrypt>

The |decrypt| method returns a new Promise object that will decrypt data
using the specified |AlgorithmIdentifier| <#dfn-AlgorithmIdentifier>
with the supplied |CryptoKey| <#dfn-CryptoKey>. It must act as follows:

 1.

    Let algorithm and key be the |algorithm| and |key|parameters passed
    to the decrypt <#dfn-SubtleCrypto-method-decrypt> method, respectively.

 2.

    Let data be the result of getting a copy of the bytes held by
    <http://heycam.github.io/webidl/#dfn-get-buffer-source-copy> the |
    data| parameter passed to the decrypt <#dfn-SubtleCrypto-method-
    decrypt> method.

 3.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"decrypt"|.

 4.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 5.

    Let promise be a new Promise.

 6.

    Return promise and asynchronously perform the remaining steps.

 7.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 8.

    If the name <#dfn-Algorithm-name> member of normalizedAlgorithm is
    not equal to the name <#dfn-KeyAlgorithm-name> attribute of the
    [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of key
    then throw <#concept-throw> an |InvalidAccessError| <#dfn-
    InvalidAccessError>.

 9.

    If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of key
    does not contain an entry that is |"decrypt"|, then throw <#concept-
    throw> an |InvalidAccessError| <#dfn-InvalidAccessError>.

10.

    Let plaintext be the result of performing the decrypt operation
    specified by normalizedAlgorithm using key and algorithm and with
    data as ciphertext.

11.

    Resolve promise with plaintext.


        14.3.3. The sign method ¶ <#SubtleCrypto-method-sign>

The |sign| method returns a new Promise object that will sign data using
the specified |AlgorithmIdentifier| <#dfn-AlgorithmIdentifier> with the
supplied |CryptoKey| <#dfn-CryptoKey>. It must act as follows:

 1.

    Let algorithm and key be the |algorithm| and |key| parameters passed
    to the sign <#dfn-SubtleCrypto-method-sign> method, respectively.

 2.

    Let data be the result of getting a copy of the bytes held by
    <http://heycam.github.io/webidl/#dfn-get-buffer-source-copy> the |
    data| parameter passed to the sign <#dfn-SubtleCrypto-method-sign>
    method.

 3.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"sign"|.

 4.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 5.

    Let promise be a new Promise.

 6.

    Return promise and asynchronously perform the remaining steps.

 7.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 8.

    If the name <#dfn-Algorithm-name> member of normalizedAlgorithm is
    not equal to the name <#dfn-KeyAlgorithm-name> attribute of the
    [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of key
    then throw <#concept-throw> an |InvalidAccessError| <#dfn-
    InvalidAccessError>.

 9.

    If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of key
    does not contain an entry that is |"sign"|, then throw <#concept-
    throw> an |InvalidAccessError| <#dfn-InvalidAccessError>.

10.

    Let result be the result of performing the sign operation specified
    by normalizedAlgorithm using key and algorithm and with data as
    message.

11.

    Resolve promise with result.


        14.3.4. The verify method ¶ <#SubtleCrypto-method-verify>

The |verify| method returns a new Promise object that will verify data
using the specified |AlgorithmIdentifier| <#dfn-AlgorithmIdentifier>
with the supplied |CryptoKey| <#dfn-CryptoKey>. It must act as follows:

 1.

    Let algorithm and key be the |algorithm| and |key| parameters passed
    to the verify <#dfn-SubtleCrypto-method-verify> method, respectively.

 2.

    Let signature be the result of getting a copy of the bytes held by
    <http://heycam.github.io/webidl/#dfn-get-buffer-source-copy> the |
    signature| parameter passed to the verify <#dfn-SubtleCrypto-method-
    verify> method.

 3.

    Let data be the result of getting a copy of the bytes held by
    <http://heycam.github.io/webidl/#dfn-get-buffer-source-copy> the |
    data| parameter passed to the verify <#dfn-SubtleCrypto-method-
    verify> method.

 4.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"verify"|.

 5.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 6.

    Let promise be a new Promise.

 7.

    Return promise and asynchronously perform the remaining steps.

 8.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 9.

    If the name <#dfn-Algorithm-name> member of normalizedAlgorithm is
    not equal to the name <#dfn-KeyAlgorithm-name> attribute of the
    [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of key
    then throw <#concept-throw> an |InvalidAccessError| <#dfn-
    InvalidAccessError>.

10.

    If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of key
    does not contain an entry that is |"verify"|, then throw <#concept-
    throw> an |InvalidAccessError| <#dfn-InvalidAccessError>.

11.

    Let result be the result of performing the verify operation
    specified by normalizedAlgorithm using key, algorithm and signature
    and with data as message.

12.

    Resolve promise with result.


        14.3.5. The digest method ¶ <#SubtleCrypto-method-digest>

The |digest| method returns a new Promise object that will digest data
using the specified |AlgorithmIdentifier| <#dfn-AlgorithmIdentifier>. It
must act as follows:

 1.

    Let algorithm be the |algorithm| parameter passed to the digest
    <#dfn-SubtleCrypto-method-digest> method.

 2.

    Let data be the result of getting a copy of the bytes held by
    <http://heycam.github.io/webidl/#dfn-get-buffer-source-copy> the |
    data| parameter passed to the digest <#dfn-SubtleCrypto-method-
    digest> method.

 3.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"digest"|.

 4.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 5.

    Let promise be a new Promise.

 6.

    Return promise and asynchronously perform the remaining steps.

 7.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 8.

    Let result be the result of performing the digest operation
    specified by normalizedAlgorithm using algorithm, with data as message.

 9.

    Resolve promise with result.


        14.3.6. The generateKey method ¶ <#SubtleCrypto-method-generateKey>

When invoked, |generateKey| MUST perform the following steps:

 1.

    Let algorithm, extractable and usages be the |algorithm|, |
    extractable| and |keyUsages| parameters passed to the generateKey
    <#dfn-SubtleCrypto-method-generateKey> method, respectively.

 2.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"generateKey"|.

 3.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 4.

    Let promise be a new Promise.

 5.

    Return promise and asynchronously perform the remaining steps.

 6.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 7.

    Let result be the result of performing the generate key operation
    specified by normalizedAlgorithm using algorithm, extractable and
    usages.

 8.

    If result is a CryptoKey <#dfn-CryptoKey> object:

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        result is |"secret"| or |"private"| and usages is empty, then
        throw <#concept-throw> a SyntaxError <#dfn-SyntaxError>.

    If result is a CryptoKeyPair <#dfn-CryptoKeyPair> object:

        If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        the privateKey <#dfn-CryptoKeyPair-privateKey> attribute of
        result is the empty sequence, then throw <#concept-throw> a
        SyntaxError <#dfn-SyntaxError>.

 9.

    Resolve promise with result.


        14.3.7. The deriveKey method ¶ <#SubtleCrypto-method-deriveKey>

When invoked, |deriveKey| MUST perform the following steps:

 1.

    Let algorithm, baseKey, derivedKeyType, extractable and usages be
    the |algorithm|, |baseKey|, |derivedKeyType|, |extractable| and |
    keyUsages| parameters passed to the deriveKey <#dfn-SubtleCrypto-
    method-deriveKey> method, respectively.

 2.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"deriveBits"|.

 3.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 4.

    Let normalizedDerivedKeyAlgorithmImport be the result of normalizing
    an algorithm <#dfn-normalize-an-algorithm>, with |alg| set to
    derivedKeyType and |op| set to |"importKey"|.

 5.

    If an error occurred, return a Promise rejected with
    normalizedDerivedKeyAlgorithmImport.

 6.

    Let normalizedDerivedKeyAlgorithmLength be the result of normalizing
    an algorithm <#dfn-normalize-an-algorithm>, with |alg| set to
    derivedKeyType and |op| set to |"get key length"|.

 7.

    If an error occurred, return a Promise rejected with
    normalizedDerivedKeyAlgorithmLength.

 8.

    Let promise be a new Promise.

 9.

    Return promise and asynchronously perform the remaining steps.

10.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

11.

    If the name <#dfn-Algorithm-name> member of normalizedAlgorithm is
    not equal to the name <#dfn-KeyAlgorithm-name> attribute of the
    [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of
    baseKey then throw <#concept-throw> an |InvalidAccessError| <#dfn-
    InvalidAccessError>.

12.

    If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
    baseKey does not contain an entry that is |"deriveKey"|, then throw
    <#concept-throw> an |InvalidAccessError| <#dfn-InvalidAccessError>.

13.

    Let length be the result of performing the get key length algorithm
    specified by normalizedDerivedKeyAlgorithmLength using derivedKeyType.

14.

    Let secret be the result of performing the derive bits operation
    specified by normalizedAlgorithm using key, algorithm and length.

15.

    Let result be the result of performing the import key operation
    specified by normalizedDerivedKeyAlgorithmImport using |"raw"| as
    format, secret as keyData, derivedKeyType as algorithm and using
    extractable and usages.

16.

    If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of result
    is |"secret"| or |"private"| and usages is empty, then throw
    <#concept-throw> a SyntaxError <#dfn-SyntaxError>.

17.

    Resolve promise with result.


        14.3.8. The deriveBits method ¶ <#SubtleCrypto-method-deriveBits>

When invoked, |deriveBits| MUST perform the following steps:

 1.

    Let algorithm, baseKey and length, be the |algorithm|, |baseKey| and
    |length| parameters passed to the deriveBits <#dfn-SubtleCrypto-
    method-deriveBits> method, respectively.

 2.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"deriveBits"|.

 3.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 4.

    Let promise be a new Promise object.

 5.

    Return promise and asynchronously perform the remaining steps.

 6.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 7.

    If the name <#dfn-Algorithm-name> member of normalizedAlgorithm is
    not equal to the name <#dfn-KeyAlgorithm-name> attribute of the
    [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of
    baseKey then throw <#concept-throw> an |InvalidAccessError| <#dfn-
    InvalidAccessError>.

 8.

    If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
    baseKey does not contain an entry that is |"deriveBits"|, then throw
    <#concept-throw> an |InvalidAccessError| <#dfn-InvalidAccessError>.

 9.

    Let result be a new ArrayBuffer <#dfn-ArrayBuffer> associated with
    the relevant global object <https://www.w3.org/TR/html51/
    webappapis.html#relevant-global-object> of |this| [HTML <#HTML>],
    and containing the result of performing the derive bits operation
    specified by normalizedAlgorithm using baseKey, algorithm and length.

10.

    Resolve promise with result.


        14.3.9. The importKey <#dfn-SubtleCrypto-method-importKey>
        method ¶ <#SubtleCrypto-method-importKey>

When invoked, the |importKey| method MUST perform the following steps:

 1.

    Let format, algorithm, extractable and usages, be the |format|, |
    algorithm|, |extractable| and |keyUsages| parameters passed to the
    importKey <#dfn-SubtleCrypto-method-importKey> method, respectively.

 2.

    If format is equal to the string |"raw"|, |"pkcs8"|, or |"spki"|:
         1.

            If the |keyData| parameter passed to the importKey <#dfn-
            SubtleCrypto-method-importKey> method is a JsonWebKey
            dictionary, throw <#concept-throw> a |TypeError| <#dfn-
            TypeError>.

         2.

            Let keyData be the result of getting a copy of the bytes
            held by <http://heycam.github.io/webidl/#dfn-get-buffer-
            source-copy> the |keyData| parameter passed to the importKey
            <#dfn-SubtleCrypto-method-importKey> method.

    If format is equal to the string |"jwk"|:
         1.

            If the |keyData| parameter passed to the importKey <#dfn-
            SubtleCrypto-method-importKey> method is not a JsonWebKey
            dictionary, throw <#concept-throw> a |TypeError| <#dfn-
            TypeError>.

         2.

            Let keyData be the |keyData| parameter passed to the
            importKey <#dfn-SubtleCrypto-method-importKey> method.

 3.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"importKey"|.

 4.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 5.

    Let promise be a new Promise.

 6.

    Return promise and asynchronously perform the remaining steps.

 7.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 8.

    Let result be the CryptoKey <#dfn-CryptoKey> object that results
    from performing the import key operation specified by
    normalizedAlgorithm using keyData, algorithm, format, extractable
    and usages.

 9.

    If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of result
    is |"secret"| or |"private"| and usages is empty, then throw
    <#concept-throw> a SyntaxError <#dfn-SyntaxError>.

10.

    Set the [[extractable <#dfn-CryptoKey-slot-extractable>]] internal
    slot of result to extractable.

11.

    Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
    result to the normalized value <#concept-normalized-usages> of usages.

12.

    Resolve promise with result.

Note

Support of |"raw"| key formats is encouraged for interoperability. Web
developers should consult the test-suite for detailed information on
implementations support of other key formats.

Note

For structured key formats, |"spki"|, |"pks8"| and |"jwk"|, fields that
are not explicitly referred to in the key import procedures for an
algorithm are ignored.


        14.3.10. The exportKey <#dfn-SubtleCrypto-method-exportKey>
        method ¶ <#SubtleCrypto-method-exportKey>

When invoked, the |exportKey| method MUST perform the following steps:

 1.

    Let format and key be the |format| and |key| parameters passed to
    the exportKey <#dfn-SubtleCrypto-method-exportKey> method,
    respectively.

 2.

    Let promise be a new Promise.

 3.

    Return promise and asynchronously perform the remaining steps.

 4.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 5.

    If the name <#dfn-Algorithm-name> member of of the [[algorithm
    <#dfn-CryptoKey-slot-algorithm>]] internal slot of key does not
    identify a registered algorithm <#algorithms> that supports the
    export key operation, then throw <#concept-throw> a |
    NotSupportedError| <#dfn-NotSupportedError>.

 6.

    If the [[extractable <#dfn-CryptoKey-slot-extractable>]] internal
    slot of key is false, then throw <#concept-throw> an |
    InvalidAccessError| <#dfn-InvalidAccessError>.

 7.

    Let result be the result of performing the export key operation
    specified by the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
    internal slot of key using key and format.

 8.

    Resolve promise with result.

Note

Support of |"raw"| key formats is encouraged for interoperability. Web
developers should consult the test-suite for detailed information on
implementations support of other key formats.


        14.3.11. The wrapKey method ¶ <#SubtleCrypto-method-wrapKey>

When invoked, the wrapKey method MUST perform the following steps:

 1.

    Let format, key, wrappingKey and algorithm be the |format|, |key|, |
    wrappingKey| and |wrapAlgorithm| parameters passed to the wrapKey
    <#dfn-SubtleCrypto-method-wrapKey> method, respectively.

 2.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"wrapKey"|.

 3.

    If an error occurred, let normalizedAlgorithm be the result of
    normalizing an algorithm <#dfn-normalize-an-algorithm>, with |alg|
    set to algorithm and |op| set to |"encrypt"|.

 4.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 5.

    Let promise be a new Promise.

 6.

    Return promise and asynchronously perform the remaining steps.

 7.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

 8.

    If the name <#dfn-Algorithm-name> member of normalizedAlgorithm is
    not equal to the name <#dfn-KeyAlgorithm-name> attribute of the
    [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of
    wrappingKey then throw <#concept-throw> an |InvalidAccessError|
    <#dfn-InvalidAccessError>.

 9.

    If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
    wrappingKey does not contain an entry that is |"wrapKey"|, then
    throw <#concept-throw> an |InvalidAccessError| <#dfn-
    InvalidAccessError>.

10.

    If the algorithm identified by the [[algorithm <#dfn-CryptoKey-slot-
    algorithm>]] internal slot of key does not support the export key
    operation, then throw <#concept-throw> a |NotSupportedError| <#dfn-
    NotSupportedError>.

11.

    If the [[extractable <#dfn-CryptoKey-slot-extractable>]] internal
    slot of key is false, then throw <#concept-throw> an |
    InvalidAccessError| <#dfn-InvalidAccessError>.

    Note

    Because the wrapKey method effectively exports the key, only keys
    marked as extractable may be wrapped. In particular, this means that
    this API cannot create a wrapped JWK key that is marked as non-
    extractable using the |ext| JWK member.

    However, the unwrapKey method /does/ support the |ext| JWK member,
    so that wrapped non-extractable keys created elsewhere, for example
    by a server, can be unwrapped using this API.

12.

    Let key be the result of performing the export key operation
    specified the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
    slot of key using key and format.

13.

    If format is equal to the strings |"raw"|, |"pkcs8"|, or |"spki"|:
        Set bytes be set to key. 
    If format is equal to the string |"jwk"|:
         1.

            Convert key to an ECMAScript Object, as specified in
            [ WebIDL <#WebIDL>], performing the conversion in the
            context of a new global object.

         2.

            Let json be the result of representing key as a UTF-16
            string conforming to the JSON grammar; for example, by
            executing the |JSON.stringify| algorithm specified in
            ECMA262 <#ECMA-262> in the context of a new global object.

         3.

            Let bytes be the byte sequence the results from converting
            json, a JavaScript String comprised of UTF-16 code points,
            to UTF-8 code points.

    Note

    The key wrapping operations for some algorithms place constraints on
    the payload size. For example AES-KW requires the payload to be a
    multiple of 8 bytes in length and RSA-OAEP places a restriction on
    the length. For key formats that offer flexibility in serialization
    of a given key (for example JWK), implementations may choose to
    adapt the serialization to the constraints of the wrapping
    algorithm. This is why JSON.stringify is not normatively required,
    as otherwise it would prohibit implementations from introducing
    added padding.

14.

    If normalizedAlgorithm supports the wrap key operation:

        Let result be the result of performing the wrap key operation
        specified by normalizedAlgorithm using algorithm, wrappingKey as
        key and bytes as plaintext.

    Otherwise, if normalizedAlgorithm supports the encrypt operation:

        Let result be the result of performing the encrypt operation
        specified by normalizedAlgorithm using algorithm, wrappingKey as
        key and bytes as plaintext.

    Otherwise:
        throw <#concept-throw> a |NotSupportedError| <#dfn-
        NotSupportedError>. 

15.

    Resolve promise with result.

Note

Support of |"raw"| key formats is encouraged for interoperability. Web
developers should consult the test-suite for detailed information on
implementations support of other key formats.


        14.3.12. The unwrapKey method ¶ <#SubtleCrypto-method-unwrapKey>

When invoked, the unwrapKey method MUST perform the following steps:

 1.

    Let format, unwrappingKey, algorithm, unwrappedKeyAlgorithm,
    extractable and usages, be the |format|, |unwrappingKey|, |
    unwrapAlgorithm|, |unwrappedKeyAlgorithm|, |extractable| and |
    keyUsages| parameters passed to the unwrapKey <#dfn-SubtleCrypto-
    method-unwrapKey> method, respectively.

 2.

    Let wrappedKey be the result of getting a copy of the bytes held by
    <http://heycam.github.io/webidl/#dfn-get-buffer-source-copy> the |
    wrappedKey| parameter passed to the unwrapKey <#dfn-SubtleCrypto-
    method-unwrapKey> method.

 3.

    Let normalizedAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to algorithm and |op|
    set to |"unwrapKey"|.

 4.

    If an error occurred, let normalizedAlgorithm be the result of
    normalizing an algorithm <#dfn-normalize-an-algorithm>, with |alg|
    set to algorithm and |op| set to |"decrypt"|.

 5.

    If an error occurred, return a Promise rejected with
    normalizedAlgorithm.

 6.

    Let normalizedKeyAlgorithm be the result of normalizing an algorithm
    <#dfn-normalize-an-algorithm>, with |alg| set to
    unwrappedKeyAlgorithm and |op| set to |"importKey"|.

 7.

    If an error occurred, return a Promise rejected with
    normalizedKeyAlgorithm.

 8.

    Let promise be a new Promise.

 9.

    Return promise and asynchronously perform the remaining steps.

10.

    If the following steps or referenced procedures say to throw
    <#concept-throw> an error, reject promise with the returned error
    and then terminate the algorithm. <#terminate-the-algorithm>

11.

    If the name <#dfn-Algorithm-name> member of normalizedAlgorithm is
    not equal to the name <#dfn-KeyAlgorithm-name> attribute of the
    [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of
    unwrappingKey then throw <#concept-throw> an |InvalidAccessError|
    <#dfn-InvalidAccessError>.

12.

    If the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
    unwrappingKey does not contain an entry that is |"unwrapKey"|, then
    throw <#concept-throw> an |InvalidAccessError| <#dfn-
    InvalidAccessError>.

13.

    If normalizedAlgorithm supports an unwrap key operation:
        Let key be the result of performing the unwrap key operation
        specified by normalizedAlgorithm using algorithm, unwrappingKey
        as key and wrappedKey as ciphertext. 
    Otherwise, if normalizedAlgorithm supports a decrypt operation:
        Let key be the result of performing the decrypt operation
        specified by normalizedAlgorithm using algorithm, unwrappingKey
        as key and wrappedKey as ciphertext. 
    Otherwise:
        throw <#concept-throw> a |NotSupportedError| <#dfn-
        NotSupportedError>. 

14.

    If format is equal to the strings |"raw"|, |"pkcs8"|, or |"spki"|:
        Set bytes be set to key. 
    If format is equal to the string |"jwk"|:
        Let bytes be the result of executing the parse a JWK <#concept-
        parse-a-jwk> algorithm, with key as the |data| to be parsed. 

15.

    Let result be the result of performing the import key operation
    specified by normalizedKeyAlgorithm using unwrappedKeyAlgorithm as
    algorithm, format, usages and extractable and with bytes as keyData.

16.

    If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of result
    is |"secret"| or |"private"| and usages is empty, then throw
    <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

17.

    Set the [[extractable <#dfn-CryptoKey-slot-extractable>]] internal
    slot of result to extractable.

18.

    Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
    result to the normalized value <#concept-normalized-usages> of usages.

19.

    Resolve promise with result.

Note

Support of |"raw"| key formats is encouraged for interoperability. Web
developers should consult the test-suite for detailed information on
implementations support of other key formats.


      14.4. Exceptions ¶ <#SubtleCrypto-Exceptions>

The methods of the SubtleCrypto <#dfn-SubtleCrypto> interface return
errors by rejecting the returned promise with a predefined exception
defined in ECMAScript [ECMA-262 <#ECMA-262>] or DOMException <#dfn-
DOMException>. The following predefined exceptions are used: TypeError.
The following DOMException types from [DOM4 <#DOM4>] are used:

Name 	Description
|NotSupportedError| 	The algorithm is not supported
|SyntaxError| 	A required parameter was missing or out-of-range
|InvalidAccessError| 	The requested operation is not valid for the
provided key
|DataError| 	Data provided to an operation does not meet requirements
|OperationError| 	The operation failed for an operation-specific reason

When this specification says to throw an error, the user agent must
throw <http://heycam.github.io/webidl/#dfn-throw> an error as described
in [WebIDL <#WebIDL>]. When this occurs in a sub-algorithm, this results
in termination of execution of the sub-algorithm and all ancestor
algorithms until one is reached that explicitly describes procedures for
catching exceptions. The error object thrown shall be associated with
the relevant global object <https://www.w3.org/TR/html51/
webappapis.html#relevant-global-object> of |this| [HTML <#HTML>].


    15. JsonWebKey dictionary ¶ <#JsonWebKey-dictionary>

IDL

|
dictionary RsaOtherPrimesInfo {
  // The following fields are defined in Section 6.3.2.7 of JSON Web Algorithms <#jwa>
  DOMString r;
  DOMString d;
  DOMString t;
};

dictionary JsonWebKey {
  // The following fields are defined in Section 3.1 of JSON Web Key <#jwk>
  DOMString kty;
  DOMString use;
  sequence<DOMString> key_ops;
  DOMString alg;

  // The following fields are defined in JSON Web Key Parameters Registration <#iana-section-jwk>
  boolean ext;

  // The following fields are defined in Section 6 of JSON Web Algorithms <#jwa>
  DOMString crv;
  DOMString x;
  DOMString y;
  DOMString d;
  DOMString n;
  DOMString e;
  DOMString p;
  DOMString q;
  DOMString dp;
  DOMString dq;
  DOMString qi;
  sequence<RsaOtherPrimesInfo> oth;
  DOMString k;
};
        |


      Description ¶ <#JsonWebKey-description>

The following section is non-normative.

The JsonWebKey <#dfn-JsonWebKey> dictionary provides a way to represent
and exchange cryptographic keys represented by the JSON Web Key <#jwk>
structure, while allowing native and efficient use within Web
Cryptography API applications.


    16. BigInteger ¶ <#big-integer>

IDL

|
typedef Uint8Array BigInteger;
        |

The BigInteger <#dfn-BigInteger> typedef is a |Uint8Array| that holds an
arbitrary magnitude unsigned integer in big-endian order. Values read
from the API SHALL have minimal typed array length (that is, at most 7
leading zero bits, except the value 0 which shall have length 8 bits).
The API SHALL accept values with any number of leading zero bits,
including the empty array, which represents zero.

Note
Since the integer is unsigned, the highest order bit is NOT a sign bit.
Implementors should take care when mapping to big integer
implementations that expected signed integers.


    17. CryptoKeyPair dictionary ¶ <#keypair>

IDL

|
dictionary CryptoKeyPair {
  CryptoKey <#dfn-CryptoKey> publicKey;
  CryptoKey <#dfn-CryptoKey> privateKey;
};
        |

The CryptoKeyPair <#dfn-CryptoKeyPair> dictionary represents an
asymmetric key pair that is comprised of both public and private keys.


    18. Algorithms ¶ <#algorithms>


      18.1. Overview ¶ <#algorithms-section-overview>

This section is non-normative.

In addition to providing a common interface to perform cryptographic
operations, by way of the SubtleCrypto <#dfn-SubtleCrypto> interface,
this specification also provides descriptions for a variety of
algorithms that authors may wish to use and that User Agents may choose
to implement. This includes a selection of commonly-deployed symmetric
and asymmetric algorithms, key derivation mechanisms, and methods for
wrapping and unwrapping keys. Further, this specification defines a
process to allow additional specifications to introduce additional
cryptographic algorithms.


      18.2. Concepts ¶ <#algorithm-concepts>


        18.2.1. Naming ¶ <#algorithm-concepts-naming>

Every cryptographic algorithm defined for use with the Web Cryptography
API MUST have a unique name, referred to as its recognized algorithm
name, such that no other specification defines the same case-insensitive
string for use with the Web Cryptography API.


        18.2.2. Supported Operations ¶ <#algorithm-concepts-operations>

Every cryptographic algorithm defined for use with the Web Cryptography
API has a list of supported operations, which are a set of sub-
algorithms to be invoked by the SubtleCrypto <#dfn-SubtleCrypto>
interface in order to perform the desired cryptographic operation. This
specification makes use of the following operations:

  * encrypt
  * decrypt
  * sign
  * verify
  * deriveBits
  * wrapKey
  * unwrapKey
  * generateKey
  * importKey
  * exportKey
  * get key length

If a given algorithm specification does not list a particular operation
as supported, or explicitly lists an operation as not-supported, then
the User Agent MUST behave as if the invocation of the sub-algorithm
threw a NotSupportedError.


        18.2.3. Normalization ¶ <#algorithm-concepts-normalization>

Every cryptographic algorithm defined for use with the Web Cryptography
API MUST define, for every supported operation <#supported-operation>,
the IDL type to use for algorithm normalization <#algorithm-
normalization>, as well as the IDL type or types of the return values of
the sub-algorithms.


      18.3. Specification Conventions ¶ <#algorithm-conventions>

Every cryptographic algorithm definition within this specification
employs the following specification conventions. A section,
titled /"Registration"/, will include the recognized algorithm name
<#recognized-algorithm-name>. Additionally, it includes a table, which
will list each of the supported operations <#supported-operation> as
rows, identified by the Operation column. The contents of the Parameters
column for a given row will contain the IDL type to use for algorithm
normalization <#algorithm-normalization> for that operation, and the
contents of the Result column for that row indicate the IDL type that
results from performing the supported operation.

If a conforming User Agent implements an algorithm, it MUST implement
all of the supported operations <#supported-operation> and MUST return
the IDL type specified.

Additionally, upon initialization, conforming User Agents must perform
the define an algorithm <#concept-define-an-algorithm> steps for each of
the supported operations, registering their IDL parameter type as
indicated.


      18.4. Algorithm Normalization ¶ <#algorithm-normalization>


        18.4.1. Description ¶ <#algorithm-normalization-description>

This section is non-normative.

The AlgorithmIdentifier <#dfn-AlgorithmIdentifier> typedef permits
algorithms to either be specified as a DOMString <#dfn-DOMString> or an
object. The usage of DOMString <#dfn-DOMString> is to permit authors a
short-hand for noting algorithms that have no parameters (e.g. SHA-1).
The usage of object is to allow an Algorithm <#dfn-Algorithm> (or
appropriate subclass) to be specified, which contains all of the
associated parameters for an object.

Because of this, it's necessary to define the algorithm for converting
an AlgorithmIdentifier <#dfn-AlgorithmIdentifier> into an appropriate
dictionary that is usable with this API. This algorithm must be
extensible, so as to allow new cryptographic algorithms to be added, and
consistent, so that Web IDL type mapping can occur before any control is
returned to the calling script, which would potentially allow the
mutation of parameters or the script environment.


        18.4.2. Internal State Objects ¶ <#algorithm-normalization-internal>

This specification makes use of an internal object,
[[supportedAlgorithms]]. This internal object is not exposed to
applications.

Because this value is not exposed to applications, the exact type is not
specified. It is only required to behave as an associative container of
key/value pairs, where comparisons of keys are performed in a case-
sensitive manner.

The initial contents of this internal object are as follows:

 1.

    For each value, v in the List of supported operations <#supported-
    operation>, set the v key of the internal object
    [[supportedAlgorithms <#dfn-supportedAlgorithms>]] to a new
    associative container.


        18.4.3. Defining an Algorithm ¶ <#algorithm-normalization-
        define-an-algorithm>

The define an algorithm algorithm is used by specification authors to
indicate how a user agent should normalize arguments for a particular
algorithm. Its input is an algorithm name alg, represented as a
DOMString, operation name op, represented as a DOMString, and desired
IDL dictionary type type. The algorithm behaves as follows:

 1. Let registeredAlgorithms be the associative container stored at the
    op key of [[supportedAlgorithms <#dfn-supportedAlgorithms>]]..
 2. Set the alg key of registeredAlgorithms to the IDL dictionary type
    type.


        18.4.4. Normalizing an algorithm ¶ <#algorithm-normalization-
        normalize-an-algorithm>

The normalize an algorithm algorithm defines a process for coercing
inputs to a targeted IDL dictionary type, after Web IDL conversion has
occurred. It is designed to be extensible, to allow future
specifications to define additional algorithms, as well as safe for use
with Promises. Its input is an operation name op and an
AlgorithmIdentifier <#dfn-AlgorithmIdentifier> alg. Its output is either
an IDL dictionary type or an error. It behaves as follows:

If alg is an instance of a DOMString:

    Return the result of running the normalize an algorithm <#dfn-
    normalize-an-algorithm> algorithm, with the |alg| set to a new
    Algorithm <#dfn-Algorithm> dictionary whose name <#dfn-KeyAlgorithm-
    name> attribute is alg, and with the |op| set to op.

If alg is an object:

     1. Let registeredAlgorithms be the associative container stored at
        the |op| key of [[supportedAlgorithms <#dfn-supportedAlgorithms>]].
     2. Let initialAlg be the result of converting the ECMAScript object
        represented by alg to the IDL dictionary type Algorithm <#dfn-
        Algorithm>, as defined by [WebIDL <#WebIDL>].
     3. If an error occurred, return the error and terminate this
        algorithm.
     4. Let algName be the value of the name <#dfn-Algorithm-name>
        attribute of initialAlg.
     5.

        If registeredAlgorithms contains a key that is a case-
        insensitive <#case-insensitive> string match for algName:
             1.

                Set algName to the value of the matching key.

             2.

                Let desiredType be the IDL dictionary type stored at
                algName in registeredAlgorithms.

        Otherwise:
            Return a new |NotSupportedError| and terminate this algorithm. 

     6. Let normalizedAlgorithm be the result of converting the
        ECMAScript object represented by alg to the IDL dictionary type
        desiredType, as defined by [WebIDL <#WebIDL>].
     7. Set the name <#dfn-Algorithm-name> attribute of
        normalizedAlgorithm to algName.
     8. If an error occurred, return the error and terminate this
        algorithm.
     9. Let dictionaries be a list consisting of the IDL dictionary type
        desiredType and all of desiredType's inherited dictionaries, in
        order from least to most derived.
    10.

        For each dictionary dictionary in dictionaries:

         1.

            For each dictionary member member declared on dictionary, in
            order:

             1. Let key be the identifier of member.
             2. Let idlValue be the value of the dictionary member with
                key name of key on normalizedAlgorithm.
             3.

                If member is of the type BufferSource <http://
                heycam.github.io/webidl/#common-BufferSource> and is
                present:
                    Set the dictionary member on normalizedAlgorithm
                    with key name key to the result of getting a copy of
                    the bytes held by <http://heycam.github.io/webidl/
                    #dfn-get-buffer-source-copy> idlValue, replacing the
                    current value. 
                If member is of the type HashAlgorithmIdentifier <#dfn-
                HashAlgorithmIdentifier>:
                    Set the dictionary member on normalizedAlgorithm
                    with key name key to the result of normalizing an
                    algorithm <#dfn-normalize-an-algorithm>, with the |
                    alg| set to idlValue and the |op| set to |"digest"|. 
                If member is of the type AlgorithmIdentifier <#dfn-
                AlgorithmIdentifier>:
                    Set the dictionary member on normalizedAlgorithm
                    with key name key to the result of normalizing an
                    algorithm <#dfn-normalize-an-algorithm>, with the |
                    alg| set to idlValue and the |op| set to the
                    operation defined by the specification that defines
                    the algorithm identified by algName. 

             4. If an error occurred, return the error and terminate
                this algorithm.
    11. Return normalizedAlgorithm.


      18.5. Recommendations ¶ <#algorithm-recommendations>

This section is non-normative.


        18.5.1. For Authors ¶ <#algorithm-recommendations-authors>

As this API is meant to be extensible, in order to keep up with future
developments within cryptography, there are no algorithms that
conforming user agents are required to implement. As such, authors
should check to see what algorithms are currently recommended and
supported by implementations.

As highlighted in the Security Considerations <#security-
considerations>, even cryptographic algorithms that might be considered
strong for one purpose may be insufficient when used with another
purpose. Authors should therefore proceed with extreme caution before
inventing new cryptographic protocols.

Additionally, this specification includes several algorithms which, in
their default usage, can result in cryptographic vulnerabilities. While
these concerns may be mitigated, such as through the combination and
composition with additional algorithms provided by this specification,
authors should proceed with caution and review the relevant
cryptographic literature before using a given algorithm. The inclusion
of algorithms within this specification is not an indicator of their
suitability for any or all purpose, and instead merely serve to provide
as a specification for how a conforming User Agent must implement the
given algorithm, if it choses to implement the algorithm.


        18.5.2. For Implementers ¶ <#algorithm-recommendations-implementers>

In order to promote interoperability for developers, this specification
includes a list of suggested algorithms. These are considered to be the
most widely used algorithms in practice at the time of writing, and
therefore provide a good starting point for initial implementations of
this specification. The suggested algorithms are:

  * HMAC <#hmac> using SHA-1 <#alg-sha-1>
  * HMAC <#hmac> using SHA-256 <#alg-sha-256>
  * RSASSA-PKCS1-v1_5 <#rsassa-pkcs1> using SHA-1 <#alg-sha-256>
  * RSA-PSS <#rsa-pss> using SHA-256 <#alg-sha-256> and MGF1 with
    SHA-256 <#alg-sha-256>.
  * RSA-OAEP <#rsa-oaep> using SHA-256 <#alg-sha-256> and MGF1 with
    SHA-256 <#alg-sha-256>.
  * ECDSA <#ecdsa> using P-256 <#dfn-NamedCurve-p256> curve and SHA-256
    <#alg-sha-256>
  * AES-CBC <#aes-cbc>


    19. Algorithm Overview ¶ <#algorithm-overview>

The following section is non-normative.

The table below contains an overview of the algorithms described within
this specification, as well as the set of SubtleCrypto methods
<#subtlecrypto-interface-methods> the algorithm may be used with. In
order for an algorithm to be used with a method the corresponding
operation or operations, as defined in the procedures for the method,
must be defined in the algorithm specification. Note that this mapping
of methods to underlying operations is not one-to-one:

  *

    The encrypt <#SubtleCrypto-method-encrypt> method requires the
    encrypt operation.

  *

    The decrypt <#SubtleCrypto-method-decrypt> method requires the
    decrypt operation.

  *

    The sign <#SubtleCrypto-method-sign> method requires the sign operation.

  *

    The verify <#SubtleCrypto-method-verify> method requires the verify
    operation.

  *

    The generateKey <#SubtleCrypto-method-generateKey> method requires
    the generateKey operation.

  *

    The importKey <#SubtleCrypto-method-importKey> method requires the
    importKey operation.

  *

    The exportKey <#SubtleCrypto-method-exportKey> method requires the
    exportKey operation.

  *

    The deriveKey <#SubtleCrypto-method-deriveKey> method requires the
    deriveBits operation for the key derivation algorithm and the get
    key length and importKey operations for the derived key algorithm.

  *

    The deriveBits <#SubtleCrypto-method-deriveBits> method requires the
    deriveBits operation for the key derivation algorithm.

  *

    The digest <#SubtleCrypto-method-digest> method requires the digest
    operation.

  *

    The wrapKey <#SubtleCrypto-method-wrapKey> method requires either
    the encrypt or wrapKey operation for the wrapping algorithm and the
    exportKey operation for the wrapped key algorithm.

  *

    The unwrapKey <#SubtleCrypto-method-unwrapKey> method requires
    either the decrypt or unwrapKey operation for the unwrapping
    algorithm and the importKey operation for the unwrapped key algorithm.

Application developers and script authors should not interpret this
table as a recommendation for the use of particular algorithms. Instead,
it simply documents what methods are supported. Authors should refer to
the Security considerations for authors <#security-developers> section
of this document to better understand the risks and concerns that may
arise when using certain algorithms.

Algorithm name 	encrypt 	decrypt 	sign 	verify 	digest 	generateKey 	
deriveKey 	deriveBits 	importKey 	exportKey 	wrapKey 	unwrapKey
RSASSA-PKCS1-v1_5 <#rsassa-pkcs1> 			✔ 	✔ 		✔ 			✔ 	✔ 		
RSA-PSS <#rsa-pss> 			✔ 	✔ 		✔ 			✔ 	✔ 		
RSA-OAEP <#rsa-oaep> 	✔ 	✔ 				✔ 			✔ 	✔ 	✔ 	✔
ECDSA <#ecdsa> 			✔ 	✔ 		✔ 			✔ 	✔ 		
ECDH <#ecdh> 						✔ 	✔ 	✔ 	✔ 	✔ 		
AES-CTR <#aes-ctr> 	✔ 	✔ 				✔ 			✔ 	✔ 	✔ 	✔
AES-CBC <#aes-cbc> 	✔ 	✔ 				✔ 			✔ 	✔ 	✔ 	✔
AES-GCM <#aes-gcm> 	✔ 	✔ 				✔ 			✔ 	✔ 	✔ 	✔
AES-KW <#aes-kw> 						✔ 			✔ 	✔ 	✔ 	✔
HMAC <#hmac> 			✔ 	✔ 		✔ 			✔ 	✔ 		
SHA-1 <#sha> 					✔ 							
SHA-256 <#sha> 					✔ 							
SHA-384 <#sha> 					✔ 							
SHA-512 <#sha> 					✔ 							
HKDF <#hkdf> 							✔ 	✔ 	✔ 			
PBKDF2 <#pbkdf2> 							✔ 	✔ 	✔ 			


      20. RSASSA-PKCS1-v1_5 ¶ <#rsassa-pkcs1>


        20.1. Description ¶ <#rsassa-pkcs1-description>

This section is non-normative.

The |"RSASSA-PKCS1-v1_5"| algorithm identifier is used to perform
signing and verification using the RSASSA-PKCS1-v1_5 algorithm specified
in [RFC3447 <#RFC3447>] and using the SHA hash functions defined in this
specification.

Other specifications <#dfn-applicable-specification> may specify the use
of additional hash algorithms with RSASSA-PKCS1-v1_5. Such
specifications must define the digest operations for the additional hash
algorithms and key import steps and key export steps for RSASSA-PKCS1-v1_5.


        20.2. Registration ¶ <#rsassa-pkcs1-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"RSASSA-PKCS1-v1_5"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
sign 	None 	ArrayBuffer <#dfn-ArrayBuffer>
verify 	None 	boolean
generateKey 	RsaHashedKeyGenParams <#dfn-RsaHashedKeyGenParams> 	
CryptoKeyPair <#dfn-CryptoKeyPair>
importKey 	RsaHashedImportParams <#dfn-RsaHashedImportParams> 	CryptoKey
<#dfn-CryptoKey>
exportKey 	None 	object


        20.3. RsaKeyGenParams dictionary ¶ <#RsaKeyGenParams-dictionary>

IDL

|
dictionary RsaKeyGenParams : Algorithm <#dfn-Algorithm> {
  // The length, in bits, of the RSA modulus
  [EnforceRange] required unsigned long modulusLength;
  // The RSA public exponent
  required BigInteger <#dfn-BigInteger> publicExponent;
};
          |


        20.4. RsaHashedKeyGenParams dictionary ¶
        <#RsaHashedKeyGenParams-dictionary>

IDL

|
dictionary RsaHashedKeyGenParams : RsaKeyGenParams <#dfn-RsaKeyGenParams> {
  // The hash algorithm to use 
  required HashAlgorithmIdentifier <#dfn-HashAlgorithmIdentifier> hash;
};
          |


        20.5. RsaKeyAlgorithm dictionary ¶ <#RsaKeyAlgorithm-dictionary>

IDL

|
dictionary RsaKeyAlgorithm : KeyAlgorithm <#dfn-KeyAlgorithm> {
  // The length, in bits, of the RSA modulus
  required unsigned long modulusLength;
  // The RSA public exponent
  required BigInteger <#dfn-BigInteger> publicExponent;
};
          |


        20.6. RsaHashedKeyAlgorithm dictionary ¶
        <#RsaHashedKeyAlgorithm-dictionary>

IDL

|
dictionary RsaHashedKeyAlgorithm : RsaKeyAlgorithm <#dfn-RsaKeyAlgorithm> {
  // The hash algorithm that is used with this key
  required KeyAlgorithm <#dfn-KeyAlgorithm> hash;
};
          |


        20.7. RsaHashedImportParams dictionary ¶
        <#RsaHashedImportParams-dictionary>

IDL

|
dictionary RsaHashedImportParams : Algorithm <#dfn-Algorithm> {
  // The hash algorithm to use
  required HashAlgorithmIdentifier <#dfn-HashAlgorithmIdentifier> hash;
};
          |


        20.8. Operations ¶ <#rsassa-pkcs1-operations>

Sign

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"private"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Perform the signature generation operation defined in Section
        8.2 of [RFC3447 <#RFC3447>] with the key represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key as
        the signer's private key and the contents of message <#concept-
        contents-of-arraybuffer> as M and using the hash function
        specified in the hash <#dfn-RsaHashedKeyAlgorithm-hash>
        attribute of the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
        internal slot of key as the Hash option for the EMSA-PKCS1-v1_5
        encoding method.

     3.

        If performing the operation results in an error, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     4.

        Let signature be the value S that results from performing the
        operation.

     5.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing the bytes of signature.

Verify

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"public"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Perform the signature verification operation defined in Section
        8.2 of [RFC3447 <#RFC3447>] with the key represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key as
        the signer's RSA public key and the contents of message
        <#concept-contents-of-arraybuffer> as M and the contents of
        signature <#concept-contents-of-arraybuffer> as S and using the
        hash function specified in the hash <#dfn-RsaHashedKeyAlgorithm-
        hash> attribute of the [[algorithm <#dfn-CryptoKey-slot-
        algorithm>]] internal slot of key as the Hash option for the
        EMSA-PKCS1-v1_5 encoding method.

     3.

        Let result be a boolean with value true if the result of the
        operation was "valid signature" and the value false otherwise.

     4.

        Return result.

Generate Key

     1.

        If usages contains an entry which is not |"sign"| or |"verify"|,
        then throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        Generate an RSA key pair, as defined in [RFC3447 <#RFC3447>],
        with RSA modulus length equal to the modulusLength <#dfn-
        RsaKeyGenParams-modulusLength> attribute of normalizedAlgorithm
        and RSA public exponent equal to the publicExponent <#dfn-
        RsaKeyGenParams-publicExponent> attribute of normalizedAlgorithm.

     3.

        If generation of the key pair fails, then throw <#concept-throw>
        an |OperationError| <#dfn-OperationError>.

     4.

        Let algorithm be a new RsaHashedKeyAlgorithm <#dfn-
        RsaHashedKeyAlgorithm> dictionary.

     5.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"RSASSA-PKCS1-v1_5"|.

     6.

        Set the modulusLength <#dfn-RsaKeyAlgorithm-modulusLength>
        attribute of algorithm to equal the modulusLength <#dfn-
        RsaKeyGenParams-modulusLength> attribute of normalizedAlgorithm.

     7.

        Set the publicExponent <#dfn-RsaKeyAlgorithm-publicExponent>
        attribute of algorithm to equal the publicExponent <#dfn-
        RsaKeyGenParams-publicExponent> attribute of normalizedAlgorithm.

     8.

        Set the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute of
        algorithm to equal the hash <#dfn-RsaHashedKeyGenParams> member
        of normalizedAlgorithm.

     9.

        Let publicKey be a new CryptoKey <#dfn-CryptoKey> object,
        associated with the relevant global object <https://www.w3.org/
        TR/html51/webappapis.html#relevant-global-object> of |this|
        [HTML <#HTML>], and representing the public key of the generated
        key pair.

    10.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        publicKey to |"public"|

    11.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of publicKey to algorithm.

    12.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of publicKey to true.

    13.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        publicKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "verify" ]|.

    14.

        Let privateKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the private key of the generated key
        pair.

    15.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        privateKey to |"private"|

    16.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of privateKey to algorithm.

    17.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of privateKey to extractable.

    18.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        privateKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "sign" ]|.

    19.

        Let result be a new CryptoKeyPair <#dfn-CryptoKeyPair> dictionary.

    20.

        Set the publicKey <#dfn-CryptoKeyPair-publicKey> attribute of
        result to be publicKey.

    21.

        Set the privateKey <#dfn-CryptoKeyPair-privateKey> attribute of
        result to be privateKey.

    22.

        Return result.

Import Key

     1.

        Let keyData be the key data to be imported.

     2.

        If format is |"spki"|:
             1.

                If usages contains an entry which is not |"verify"|,
                then throw <#concept-throw> a |SyntaxError| <#dfn-
                SyntaxError>.

             2.

                Let spki be the result of running the parse a
                subjectPublicKeyInfo <#concept-parse-a-spki> algorithm
                over keyData.

             3.

                If an error occurred while parsing, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                Let hash be undefined.

             5.

                Let alg be the |algorithm| object identifier field of
                the |algorithm| AlgorithmIdentifier field of spki.

             6.

                If alg is equivalent to the |rsaEncryption| OID defined
                in Section 2.3.1 of RFC 3279 <#RFC3279>:

                    Let hash be undefined.

                If alg is equivalent to the |sha1WithRSAEncryption| OID
                defined in Section A.2.4 of RFC 3279 <#RFC3279>:

                    Let hash be the string |"SHA-1"|.

                If alg is equivalent to the |sha256WithRSAEncryption|
                OID defined in Section A.2.4 of RFC 3447 <#RFC3447>:

                    Let hash be the string |"SHA-256"|.

                If alg is equivalent to the |sha384WithRSAEncryption|
                OID defined in Section A.2.4 of RFC 3447 <#RFC3447>:

                    Let hash be the string |"SHA-384"|.

                If alg is equivalent to the |sha512WithRSAEncryption|
                OID defined in Section A.2.4 of RFC 3447 <#RFC3447>:

                    Let hash be the string |"SHA-512"|.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-rsa-ssa-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, spki and
                        obtaining hash.

                     2.

                        If an error occurred or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

             7.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

             8.

                Let publicKey be the result of performing the parse an
                ASN.1 structure <#concept-parse-an-asn1-structure>
                algorithm, with data as the |subjectPublicKeyInfo| field
                of spki, structure as the |RSAPublicKey| structure
                specified in Section A.1.1 of RFC 3447 <#RFC3447>, and
                exactData set to true.

             9.

                If an error occurred while parsing, or it can be
                determined that publicKey is not a valid public key
                according to RFC 3447 <#RFC3447>, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

            10.

                Let key be a new CryptoKey <#dfn-CryptoKey> associated
                with the relevant global object <https://www.w3.org/TR/
                html51/webappapis.html#relevant-global-object> of |this|
                [HTML <#HTML>], and that represents the RSA public key
                identified by publicKey.

            11.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"public"|

        If format is |"pkcs8"|:
             1.

                If usages contains an entry which is not |"sign"| then
                throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

             2.

                Let privateKeyInfo be the result of running the parse a
                privateKeyInfo <#concept-parse-a-privateKeyInfo>
                algorithm over keyData.

             3.

                If an error occurred while parsing, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                Let hash be undefined.

             5.

                Let alg be the |algorithm| object identifier field of
                the |privateKeyAlgorithm| PrivateKeyAlgorithmIdentifier
                field of privateKeyInfo.

             6.

                If alg is equivalent to the |rsaEncryption| OID defined
                in Section 2.3.1 of RFC 3279 <#RFC3279>:

                    Let hash be undefined.

                If alg is equivalent to the |sha1WithRSAEncryption| OID
                defined in Section A.2.4 of RFC 3279 <#RFC3279>:

                    Let hash be the string |"SHA-1"|.

                If alg is equivalent to the |sha256WithRSAEncryption|
                OID defined in Section A.2.4 of RFC 3447 <#RFC3447>:

                    Let hash be the string |"SHA-256"|.

                If alg is equivalent to the |sha384WithRSAEncryption|
                OID defined in Section A.2.4 of RFC 3447 <#RFC3447>:

                    Let hash be the string |"SHA-384"|.

                If alg is equivalent to the |sha512WithRSAEncryption|
                OID defined in Section A.2.4 of RFC 3447 <#RFC3447>:

                    Let hash be the string |"SHA-512"|.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-rsa-ssa-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, privateKeyInfo
                        and obtaining hash.

                     2.

                        If an error occurred or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

             7.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

             8.

                Let rsaPrivateKey be the result of performing the parse
                an ASN.1 structure <#concept-parse-an-asn1-structure>
                algorithm, with data as the |privateKey| field of
                privateKeyInfo, structure as the |RSAPrivateKey|
                structure specified in Section A.1.2 of RFC 3447
                <#RFC3447>, and exactData set to true.

             9.

                If an error occurred while parsing, or if rsaPrivateKey
                is not a valid RSA private key according to RFC 3447
                <#RFC3447>, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            10.

                Let key be a new CryptoKey <#dfn-CryptoKey> associated
                with the relevant global object <https://www.w3.org/TR/
                html51/webappapis.html#relevant-global-object> of |this|
                [HTML <#HTML>], and that represents the RSA private key
                identified by rsaPrivateKey.

            11.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"private"|

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"d"| field of jwk is present and usages contains
                an entry which is not |"sign"|, or, if the |"d"| field
                of jwk is not present and usages contains an entry which
                is not |"verify"| then throw <#concept-throw> a |
                SyntaxError| <#dfn-SyntaxError>.

             3.

                If the |"kty"| field of jwk is not a case-sensitive
                string match to |"RSA"|, then throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

             4.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not a case-sensitive string match to
                |"sig"|, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             5.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk> or does not contain all of the specified usages
                values, then throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             6.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

             7.

                Let hash be a be a string whose initial value is undefined.

             8.

                If the |"alg"| field of jwk is not present:

                    Let hash be undefined.

                If the |"alg"| field is equal to the string |"RS1"|:

                    Let hash be the string |"SHA-1"|.

                If the |"alg"| field is equal to the string |"RS256"|:

                    Let hash be the string |"SHA-256"|.

                If the |"alg"| field is equal to the string |"RS384"|:

                    Let hash be the string |"SHA-384"|.

                If the |"alg"| field is equal to the string |"RS512"|:

                    Let hash be the string |"SHA-512"|.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-rsa-ssa-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, jwk and
                        obtaining hash.

                     2.

                        If an error occurred or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

             9.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

            10.

                If the |"d"| field of jwk is present:
                     1.

                        If jwk does not meet the requirements of Section
                        6.3.2 of JSON Web Algorithms <#jwa>, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     2.

                        Let privateKey represents the RSA private key
                        identified by interpreting jwk according to
                        Section 6.3.2 of JSON Web Algorithms <#jwa>.

                     3.

                        If privateKey is not a valid RSA private key
                        according to RFC 3447 <#RFC3447>, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        object that represents privateKey.

                     5.

                        Set the [[type <#dfn-CryptoKey-slot-type>]]
                        internal slot of key to |"private"|

                Otherwise:
                     1.

                        If jwk does not meet the requirements of Section
                        6.3.1 of JSON Web Algorithms <#jwa>, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     2.

                        Let publicKey represent the RSA public key
                        identified by interpreting jwk according to
                        Section 6.3.1 of JSON Web Algorithms <#jwa>.

                     3.

                        If publicKey can be determined to not be a valid
                        RSA public key according to RFC 3447 <#RFC3447>,
                        then throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        representing publicKey.

                     5.

                        Set the [[type <#dfn-CryptoKey-slot-type>]]
                        internal slot of key to |"public"|

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>. 

     3.

        Let algorithm be a new RsaHashedKeyAlgorithm <#dfn-
        RsaHashedKeyAlgorithm> dictionary.

     4.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"RSASSA-PKCS1-v1_5"|

     5.

        Set the modulusLength <#dfn-RsaKeyAlgorithm-modulusLength>
        attribute of algorithm to the length, in bits, of the RSA public
        modulus.

     6.

        Set the publicExponent <#dfn-RsaKeyAlgorithm-publicExponent>
        attribute of algorithm to the BigInteger <#dfn-BigInteger>
        representation of the RSA public exponent.

     7.

        Set the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute of
        algorithm to the hash <#dfn-RsaHashedImportParams-hash> member
        of normalizedAlgorithm.

     8.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

     9.

        Return key.

Export Key

     1.

        Let key be the key to be exported.

     2.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     3.

        If format is |"spki"|
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"public"|, then throw <#concept-throw> an
                |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be an instance of the |subjectPublicKeyInfo|
                ASN.1 structure defined in RFC 5280 <#RFC5280> with the
                following properties:

                  *

                    Set the algorithm field to an |AlgorithmIdentifier|
                    ASN.1 type with the following properties:

                      o

                        Set the algorithm field to the OID |
                        1.2.840.113549.1.1.1|

                      o

                        Set the params field to the ASN.1 type NULL.

                  *

                    Set the subjectPublicKey field to the result of DER-
                    encoding an |RSAPublicKey| ASN.1 type, as defined in
                    RFC 3447 <#RFC3447>, Appendix A.1.1, that represents
                    the RSA public key represented by the [[handle
                    <#dfn-CryptoKey-slot-handle>]] internal slot of key

             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"pkcs8"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"private"|, then throw <#concept-throw>
                an |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be the result of encoding a privateKeyInfo
                structure with the following properties:

                  *

                    Set the version field to 0.

                  *

                    Set the privateKeyAlgorithm field to a |
                    PrivateKeyAlgorithmIdentifier| ASN.1 type with the
                    following properties:

                      o

                        Set the algorithm field to the OID |
                        1.2.840.113549.1.1.1|

                      o

                        Set the params field to the ASN.1 type NULL.

                  *

                    Set the privateKey field to the result of DER-
                    encoding an |RSAPrivateKey| ASN.1 type, as defined
                    in RFC 3447 <#RFC3447>, Appendix A.1.2, that
                    represents the RSA private key represented by the
                    [[handle <#dfn-CryptoKey-slot-handle>]] internal
                    slot of key

                    Note
                    RFC 5208 <#RFC5208> specifies that the encoding of
                    this field should be /BER/ encoded in Section 5 (as
                    a "for example"). However, to avoid requiring
                    WebCrypto implementations support BER-encoding and
                    BER-decoding, only /DER/ encodings are produced or
                    accepted.
             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
              *

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

              *

                Set the |kty| attribute of jwk to the string |"RSA"|.

              *

                Let hash be the name <#dfn-KeyAlgorithm-name> attribute
                of the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute
                of key.

              *

                If hash is |"SHA-1"|:

                    Set the |alg| attribute of jwk to the string |"RS1"|.

                If hash is |"SHA-256"|:

                    Set the |alg| attribute of jwk to the string |"RS256"|.

                If hash is |"SHA-384"|:

                    Set the |alg| attribute of jwk to the string |"RS384"|.

                If hash is |"SHA-512"|:

                    Set the |alg| attribute of jwk to the string |"RS512"|.

                Otherwise:
                     1.

                        Perform any key export steps <#dfn-rsa-ssa-
                        extended-export-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, key and
                        obtaining alg.

                     2.

                        If an error occurred or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |NotSupportedError|
                        <#dfn-NotSupportedError>.

                     3.

                        Set the |alg| attribute of jwk to alg.

              *

                Set the attributes |n| and |e| of jwk according to the
                corresponding definitions in JSON Web Algorithms <#jwa>,
                Section 6.3.1.

              *

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is |"private"|:
                     1.

                        Set the attributes named |d|, |p|, |q|, |dp|, |
                        dq|, and |qi| of jwk according to the
                        corresponding definitions in JSON Web Algorithms
                        <#jwa>, Section 6.3.2.

                     2.

                        If the underlying RSA private key represented by
                        the [[handle <#dfn-CryptoKey-slot-handle>]]
                        internal slot of key is represented by more than
                        two primes, set the attribute named |oth| of jwk
                        according to the corresponding definition in
                        JSON Web Algorithms <#jwa>, Section 6.3.2.7

              *

                Set the |key_ops| attribute of jwk to the usages <#dfn-
                CryptoKey-usages> attribute of key.

              *

                Set the |ext| attribute of jwk to the [[extractable
                <#dfn-CryptoKey-slot-extractable>]] internal slot of key.

              *

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        Otherwise

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     4.

        Return result.


      21. RSA-PSS ¶ <#rsa-pss>


        21.1. Description ¶ <#rsa-pss-description>

This section is non-normative.

The |"RSA-PSS"| algorithm identifier is used to perform signing and
verification using the RSASSA-PSS algorithm specified in [RFC3447
<#RFC3447>], using the SHA hash functions defined in this specification
and the mask generation formula MGF1.

Other specifications <#dfn-applicable-specification> may specify the use
of additional hash algorithms with RSASSA-PSS. Such specifications must
define the digest operation for the additional hash algorithms and key
import steps and key export steps for RSASSA-PSS.


        21.2. Registration ¶ <#rsa-pss-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"RSA-PSS"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
sign 	RsaPssParams <#dfn-RsaPssParams> 	ArrayBuffer <#dfn-ArrayBuffer>
verify 	RsaPssParams <#dfn-RsaPssParams> 	boolean
generateKey 	RsaHashedKeyGenParams <#dfn-RsaHashedKeyGenParams> 	
CryptoKeyPair <#dfn-CryptoKeyPair>
importKey 	RsaHashedImportParams <#dfn-RsaHashedImportParams> 	CryptoKey
<#dfn-CryptoKey>
exportKey 	None 	object


        21.3. RsaPssParams dictionary ¶ <#RsaPssParams-dictionary>

IDL

|
dictionary RsaPssParams : Algorithm <#dfn-Algorithm> {
  // The desired length of the random salt
  [EnforceRange] required unsigned long saltLength;
};
          |


        21.4. Operations ¶ <#rsa-pss-operations>

Sign

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"private"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Perform the signature generation operation defined in Section
        8.1 of [RFC3447 <#RFC3447>] with the key represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key as
        the signer's private key, K, and the contents of message
        <#concept-contents-of-arraybuffer> as the message to be signed,
        M, and using the hash function specified by the hash <#dfn-
        RsaHashedKeyAlgorithm-hash> attribute of the [[algorithm <#dfn-
        CryptoKey-slot-algorithm>]] internal slot of key as the Hash
        option, MGF1 (defined in Section B.2.1 of [RFC3447 <#RFC3447>])
        as the MGF option and the saltLength <#dfn-RsaPssParams-
        saltLength> member of normalizedAlgorithm as the salt length
        option for the EMM-PSS-ENCODE operation.

     3.

        If performing the operation results in an error, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     4.

        Let signature be the signature, S, that results from performing
        the operation.

     5.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing the bytes of signature.

Verify

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"public"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Perform the signature verification operation defined in Section
        8.1 of [RFC3447 <#RFC3447>] with the key represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key as
        the signer's RSA public key and the contents of message
        <#concept-contents-of-arraybuffer> as M and the contents of
        signature <#concept-contents-of-arraybuffer> as S and using the
        hash function specified by the hash <#dfn-RsaHashedKeyAlgorithm-
        hash> attribute of the [[algorithm <#dfn-CryptoKey-slot-
        algorithm>]] internal slot of key as the Hash option, MGF1
        (defined in Section B.2.1 of [RFC3447 <#RFC3447>]) as the MGF
        option and the saltLength <#dfn-RsaPssParams-saltLength> member
        of normalizedAlgorithm as the salt length option for the EMSA-
        PSS-VERIFY operation.

     3.

        Let result be a boolean with the value true if the result of the
        operation was "valid signature" and the value false otherwise.

Generate Key

     1.

        If usages contains an entry which is not |"sign"| or |"verify"|,
        then throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        Generate an RSA key pair, as defined in [RFC3447 <#RFC3447>],
        with RSA modulus length equal to the modulusLength <#dfn-
        RsaKeyGenParams-modulusLength> member of normalizedAlgorithm and
        RSA public exponent equal to the publicExponent <#dfn-
        RsaKeyGenParams-publicExponent> member of normalizedAlgorithm.

     3.

        If performing the operation results in an error, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     4.

        Let algorithm be a new RsaHashedKeyAlgorithm <#dfn-
        RsaHashedKeyAlgorithm> dictionary.

     5.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"RSA-PSS"|.

     6.

        Set the modulusLength <#dfn-RsaKeyAlgorithm-modulusLength>
        attribute of algorithm to equal the modulusLength <#dfn-
        RsaKeyGenParams-modulusLength> member of normalizedAlgorithm.

     7.

        Set the publicExponent <#dfn-RsaKeyAlgorithm-publicExponent>
        attribute of algorithm to equal the publicExponent <#dfn-
        RsaKeyGenParams-publicExponent> member of normalizedAlgorithm.

     8.

        Set the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute of
        algorithm to equal the hash <#dfn-RsaHashedKeyGenParams> member
        of normalizedAlgorithm.

     9.

        Let publicKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the public key of the generated key
        pair.

    10.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        publicKey to |"public"|

    11.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of publicKey to algorithm.

    12.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of publicKey to true.

    13.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        publicKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "verify" ]|.

    14.

        Let privateKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the private key of the generated key
        pair.

    15.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        privateKey to |"private"|

    16.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of privateKey to algorithm.

    17.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of privateKey to extractable.

    18.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        privateKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "sign" ]|.

    19.

        Let result be a new CryptoKeyPair <#dfn-CryptoKeyPair> dictionary.

    20.

        Set the publicKey <#dfn-CryptoKeyPair-publicKey> attribute of
        result to publicKey.

    21.

        Set the privateKey <#dfn-CryptoKeyPair-privateKey> attribute of
        result to privateKey.

    22.

        Return the result of converting result to an ECMAScript Object,
        as defined by [WebIDL <#WebIDL>].

Import Key

     1.

        Let keyData be the key data to be imported.

     2.

        If format is |"spki"|:
             1.

                If usages contains an entry which is not |"verify"| then
                throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

             2.

                Let spki be the result of running the parse a
                subjectPublicKeyInfo <#concept-parse-a-spki> algorithm
                over keyData.

             3.

                If an error occurred while parsing, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                Let hash be undefined.

             5.

                Let alg be the |algorithm| object identifier field of
                the |algorithm| AlgorithmIdentifier field of spki.

             6.

                If alg is equivalent to the |rsaEncryption| OID defined
                in RFC 3447 <#RFC3447>:

                    Let hash be undefined.

                If alg is equivalent to the |id-RSASSA-PSS| OID defined
                in RFC 3447 <#RFC3447>:
                     1.

                        Let params be the ASN.1 structure contained
                        within the |parameters| field of the |algorithm|
                        AlgorithmIdentifier field of spki.

                     2.

                        If params is not defined, or is not an instance
                        of the |RSASSA-PSS-params| ASN.1 type defined in
                        RFC3447 <#RFC3447>, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     3.

                        Let hashAlg be the AlgorithmIdentifier ASN.1
                        type within the |hashAlgorithm| field of params.

                     4.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha1| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-1"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha256| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-256"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha384| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-384"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha512| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-512"|.

                        Otherwise:
                             1.

                                Perform any key import steps <#dfn-rsa-
                                pss-extended-import-steps> defined by
                                other applicable specifications <#dfn-
                                applicable-specification>, passing
                                format, spki and obtaining hash.

                             2.

                                If an error occurred or there are no
                                applicable specifications <#dfn-
                                applicable-specification>, throw
                                <#concept-throw> a |DataError| <#dfn-
                                DataError>.

                     5.

                        If the |algorithm| object identifier field of
                        the |maskGenAlgorithm| field of params is not
                        equivalent to the OID |id-mgf1| defined in RFC
                        3447 <#RFC3447>, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                     6.

                        If the |parameters| field of the |
                        maskGenAlgorithm| field of params is not an
                        instance of the |HashAlgorithm| ASN.1 type that
                        is identical in content to the |hashAlglorithm|
                        field of params, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                Otherwise:

                    throw <#concept-throw> a |DataError| <#dfn-DataError>.

             7.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

             8.

                Let publicKey be the result of performing the parse an
                ASN.1 structure <#concept-parse-an-asn1-structure>
                algorithm, with data as the |subjectPublicKeyInfo| field
                of spki, structure as the |RSAPublicKey| structure
                specified in Section A.1.1 of RFC 3447 <#RFC3447>, and
                exactData set to true.

             9.

                If an error occurred while parsing, or it can be
                determined that publicKey is not a valid public key
                according to RFC 3447 <#RFC3447>, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

            10.

                Let key be a new CryptoKey <#dfn-CryptoKey> associated
                with the relevant global object <https://www.w3.org/TR/
                html51/webappapis.html#relevant-global-object> of |this|
                [HTML <#HTML>], and that represents the RSA public key
                identified by publicKey.

            11.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"public"|

        If format is |"pkcs8"|:
             1.

                If usages contains an entry which is not |"sign"| then
                throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

             2.

                Let privateKeyInfo be the result of running the parse a
                privateKeyInfo <#concept-parse-a-privateKeyInfo>
                algorithm over keyData.

             3.

                If an error occurred while parsing, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                Let hash be undefined.

             5.

                Let alg be the |algorithm| object identifier field of
                the |privateKeyAlgorithm| PrivateKeyAlgorithmIdentifier
                field of privateKeyInfo.

             6.

                If alg is equivalent to the |rsaEncryption| OID defined
                in RFC 3447 <#RFC3447>:

                    Let hash be undefined.

                If alg is equivalent to the |id-RSASSA-PSS| OID defined
                in RFC 3447 <#RFC3447>:
                     1.

                        Let params be the ASN.1 structure contained
                        within the |parameters| field of the |
                        privateKeyAlgorithm|
                        PrivateKeyAlgorithmIdentifier field of
                        privateKeyInfo.

                     2.

                        If params is not defined, or is not an instance
                        of the |RSASSA-PSS-params| ASN.1 type defined in
                        RFC3447 <#RFC3447>, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                     3.

                        Let hashAlg be the AlgorithmIdentifier ASN.1
                        type within the |hashAlgorithm| field of params.

                     4.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha1| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-1"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha256| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-256"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha384| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-384"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha512| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-512"|.

                        Otherwise:
                             1.

                                Perform any key import steps <#dfn-rsa-
                                pss-extended-import-steps> defined by
                                other applicable specifications <#dfn-
                                applicable-specification>, passing
                                format, privateKeyInfo and obtaining hash.

                             2.

                                If an error occurred or there are no
                                applicable specifications <#dfn-
                                applicable-specification>, throw
                                <#concept-throw> a |DataError| <#dfn-
                                DataError>.

                     5.

                        If the |algorithm| object identifier field of
                        the |maskGenAlgorithm| field of params is not
                        equivalent to the OID |id-mgf1| defined in RFC
                        3447 <#RFC3447>, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                     6.

                        If the |parameters| field of the |
                        maskGenAlgorithm| field of params is not an
                        instance of the |HashAlgorithm| ASN.1 type that
                        is identical in content to the |hashAlglorithm|
                        field of params, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                Otherwise:

                    throw <#concept-throw> a |DataError| <#dfn-DataError>.

             7.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

             8.

                Let rsaPrivateKey be the result of performing the parse
                an ASN.1 structure <#concept-parse-an-asn1-structure>
                algorithm, with data as the |privateKey| field of
                privateKeyInfo, structure as the |RSAPrivateKey|
                structure specified in Section A.1.2 of RFC 3447
                <#RFC3447>, and exactData set to true.

             9.

                If an error occurred while parsing, or if rsaPrivateKey
                is not a valid RSA private key according to RFC 3447
                <#RFC3447>, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            10.

                Let key be a new CryptoKey <#dfn-CryptoKey> associated
                with the relevant global object <https://www.w3.org/TR/
                html51/webappapis.html#relevant-global-object> of |this|
                [HTML <#HTML>], and that represents the RSA private key
                identified by rsaPrivateKey.

            11.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"private"|

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"d"| field of jwk is present and usages contains
                an entry which is not |"sign"|, or, if the |"d"| field
                of jwk is not present and usages contains an entry which
                is not |"verify"| then throw <#concept-throw> a |
                SyntaxError| <#dfn-SyntaxError>.

             3.

                If the |"kty"| field of jwk is not a case-sensitive
                string match to |"RSA"|, then throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

             4.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not a case-sensitive string match to
                |"sig"|, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             5.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk> or does not contain all of the specified usages
                values, then throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             6.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

             7.

                If the |"alg"| field of jwk is not present:

                    Let hash be undefined.

                If the |"alg"| field is equal to the string |"PS1"|:

                    Let hash be the string |"SHA-1"|.

                If the |"alg"| field is equal to the string |"PS256"|:

                    Let hash be the string |"SHA-256"|.

                If the |"alg"| field is equal to the string |"PS384"|:

                    Let hash be the string |"SHA-384"|.

                If the |"alg"| field is equal to the string |"PS512"|:

                    Let hash be the string |"SHA-512"|.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-rsa-pss-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, jwk and
                        obtaining hash.

                     2.

                        If an error occurred or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

             8.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

             9.

                If the |"d"| field of jwk is present:
                     1.

                        If jwk does not meet the requirements of Section
                        6.3.2 of JSON Web Algorithms <#jwa>, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     2.

                        Let privateKey represent the RSA public key
                        identified by interpreting jwk according to
                        Section 6.3.1 of JSON Web Algorithms <#jwa>.

                     3.

                        If privateKey can be determined to not be a
                        valid RSA public key according to RFC 3447
                        <#RFC3447>, then throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        representing privateKey.

                     5.

                        Set the [[type <#dfn-CryptoKey-slot-type>]]
                        internal slot of key to |"private"|

                Otherwise:
                     1.

                        If jwk does not meet the requirements of Section
                        6.3.1 of JSON Web Algorithms <#jwa>, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     2.

                        Let publicKey represent the RSA public key
                        identified by interpreting jwk according to
                        Section 6.3.1 of JSON Web Algorithms <#jwa>.

                     3.

                        If publicKey can be determined to not be a valid
                        RSA public key according to RFC 3447 <#RFC3447>,
                        then throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        representing publicKey.

                     5.

                        Set the [[type <#dfn-CryptoKey-slot-type>]]
                        internal slot of key to |"public"|

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>. 

     3.

        Let algorithm be a new RsaHashedKeyAlgorithm <#dfn-
        RsaHashedKeyAlgorithm> dictionary.

     4.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"RSA-PSS"|

     5.

        Set the modulusLength <#dfn-RsaKeyAlgorithm-modulusLength>
        attribute of algorithm to the length, in bits, of the RSA public
        modulus.

     6.

        Set the publicExponent <#dfn-RsaKeyAlgorithm-publicExponent>
        attribute of algorithm to the BigInteger <#dfn-BigInteger>
        representation of the RSA public exponent.

     7.

        Set the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute of
        algorithm to the hash <#dfn-RsaHashedImportParams-hash> member
        of normalizedAlgorithm.

     8.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm

     9.

        Return key.

Export Key

     1.

        Let key be the key to be exported.

     2.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     3.

        If format is |"spki"|
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"public"|, then throw <#concept-throw> an
                |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be an instance of the |subjectPublicKeyInfo|
                ASN.1 structure defined in RFC 5280 <#RFC5280> with the
                following properties:

                  *

                    Set the algorithm field to an |AlgorithmIdentifier|
                    ASN.1 type with the following properties:

                      o

                        Set the algorithm field to the OID |id-RSASSA-
                        PSS| defined in RFC 3447 <#RFC3447>.

                      o

                        Set the params field to an instance of the |
                        RSASSA-PSS-params| ASN.1 type with the following
                        properties:

                          +

                            Set the hashAlgorithm field to an instance
                            of the |HashAlgorithm| ASN.1 type with the
                            following properties:

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is |"SHA-1"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha1|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-256"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha256|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-384"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha384|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-512"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha512|
                                defined in RFC 3447 <#RFC3447>.

                            Otherwise:
                                 1.

                                    Perform any key export steps <#dfn-
                                    rsa-pss-extended-export-steps>
                                    defined by other applicable
                                    specifications <#dfn-applicable-
                                    specification>, passing format and
                                    the hash <#dfn-
                                    RsaHashedKeyAlgorithm> attribute of
                                    the [[algorithm <#dfn-CryptoKey-
                                    slot-algorithm>]] internal slot of
                                    key and obtaining hashOid and
                                    hashParams.

                                 2.

                                    Set the algorithm object identifier
                                    of hashAlgorithm to hashOid.

                                 3.

                                    Set the params field of
                                    hashAlgorithm to hashParams if
                                    hashParams is not undefined and omit
                                    the params field otherwise.

                          +

                            Set the maskGenAlgorithm field to an
                            instance of the |MaskGenAlgorithm| ASN.1
                            type with the following properties:

                              #

                                Set the algorithm field to the OID |id-
                                mgf1| defined in RFC 3447 <#RFC3447>.

                              #

                                Set the params field to an instance of
                                the |HashAlgorithm| ASN.1 type that is
                                identical to the hashAlgorithm field.

                          +

                            Set the saltLength field to the length in
                            octets of the digest algorithm identified by
                            the name <#dfn-KeyAlgorithm-name> attribute
                            of the hash <#dfn-RsaHashedKeyAlgorithm-
                            hash> attribute of the [[algorithm <#dfn-
                            CryptoKey-slot-algorithm>]] internal slot of
                            key.

                  *

                    Set the subjectPublicKey field to the result of DER-
                    encoding an |RSAPublicKey| ASN.1 type, as defined in
                    RFC 3447 <#RFC3447>, Appendix A.1.1, that represents
                    the RSA public key represented by the [[handle
                    <#dfn-CryptoKey-slot-handle>]] internal slot of key

             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"pkcs8"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"private"|, then throw <#concept-throw>
                an |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be the result of encoding a privateKeyInfo
                structure with the following properties:

                  *

                    Set the version field to 0.

                  *

                    Set the privateKeyAlgorithm field to an |
                    PrivateKeyAlgorithmIdentifier| ASN.1 type with the
                    following properties:

                      o

                        Set the algorithm field to the OID |id-RSASSA-
                        PSS| defined in RFC 3447 <#RFC3447>.

                      o

                        Set the params field to an instance of the |
                        RSASSA-PSS-params| ASN.1 type with the following
                        properties:

                          +

                            Set the hashAlgorithm field to an instance
                            of the |HashAlgorithm| ASN.1 type with the
                            following properties:

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is |"SHA-1"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha1|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-256"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha256|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-384"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha384|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-512"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha512|
                                defined in RFC 3447 <#RFC3447>.

                            Otherwise:
                                 1.

                                    Perform any key export steps <#dfn-
                                    rsa-pss-extended-export-steps>
                                    defined by other applicable
                                    specifications <#dfn-applicable-
                                    specification>, passing format and
                                    the hash <#dfn-
                                    RsaHashedKeyAlgorithm> attribute of
                                    the [[algorithm <#dfn-CryptoKey-
                                    slot-algorithm>]] internal slot of
                                    key and obtaining hashOid and
                                    hashParams.

                                 2.

                                    Set the algorithm object identifier
                                    of hashAlgorithm to hashOid.

                                 3.

                                    Set the params field of
                                    hashAlgorithm to hashParams if
                                    hashParams is not undefined and omit
                                    the params field otherwise.

                          +

                            Set the maskGenAlgorithm field to an
                            instance of the |MaskGenAlgorithm| ASN.1
                            type with the following properties:

                              #

                                Set the algorithm field to the OID |id-
                                mgf1| defined in RFC 3447 <#RFC3447>.

                              #

                                Set the params field to an instance of
                                the |HashAlgorithm| ASN.1 type that is
                                identical to the hashAlgorithm field.

                          +

                            Set the saltLength field to the length in
                            octets of the digest algorithm identified by
                            the name <#dfn-KeyAlgorithm-name> attribute
                            of the hash <#dfn-RsaHashedKeyAlgorithm-
                            hash> attribute of the [[algorithm <#dfn-
                            CryptoKey-slot-algorithm>]] internal slot of
                            key.

                  *

                    Set the privateKey field to the result of DER-
                    encoding an |RSAPrivateKey| ASN.1 type, as defined
                    in RFC 3447 <#RFC3447>, Appendix A.1.2, that
                    represents the RSA private key represented by the
                    [[handle <#dfn-CryptoKey-slot-handle>]] internal
                    slot of key

                    Note
                    RFC 5208 <#RFC5208> specifies that the encoding of
                    this field should be /BER/ encoded in Section 5 (as
                    a "for example"). However, to avoid requiring
                    WebCrypto implementations support BER-encoding and
                    BER-decoding, only /DER/ encodings are produced or
                    accepted.
             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
              *

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

              *

                Set the |kty| attribute of jwk to the string |"RSA"|.

              *

                Let hash be the name <#dfn-KeyAlgorithm-name> attribute
                of the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute
                of the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key.

              *

                If hash is |"SHA-1"|:

                    Set the |alg| attribute of jwk to the string |"PS1"|.

                If hash is |"SHA-256"|:

                    Set the |alg| attribute of jwk to the string |"PS256"|.

                If hash is |"SHA-384"|:

                    Set the |alg| attribute of jwk to the string |"PS384"|.

                If hash is |"SHA-512"|:

                    Set the |alg| attribute of jwk to the string |"PS512"|.

                Otherwise:
                     1.

                        Perform any key export steps <#dfn-rsa-pss-
                        extended-export-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format and the hash
                        <#dfn-RsaHashedKeyAlgorithm> attribute of the
                        [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                        internal slot of key and obtaining alg.

                     2.

                        Set the |alg| attribute of jwk to alg.

              *

                Set the attributes |n| and |e| of jwk according to the
                corresponding definitions in JSON Web Algorithms <#jwa>,
                Section 6.3.1.

              *

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is |"private"|:
                     1.

                        Set the attributes named |d|, |p|, |q|, |dp|, |
                        dq|, and |qi| of jwk according to the
                        corresponding definitions in JSON Web Algorithms
                        <#jwa>, Section 6.3.2.

                     2.

                        If the underlying RSA private key represented by
                        the [[handle <#dfn-CryptoKey-slot-handle>]]
                        internal slot of key is represented by more than
                        two primes, set the attribute named |oth| of jwk
                        according to the corresponding definition in
                        JSON Web Algorithms <#jwa>, Section 6.3.2.7

              *

                Set the |key_ops| attribute of jwk to the usages <#dfn-
                CryptoKey-usages> attribute of key.

              *

                Set the |ext| attribute of jwk to the [[extractable
                <#dfn-CryptoKey-slot-extractable>]] internal slot of key.

              *

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        Otherwise

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     4.

        Return result.


      22. RSA-OAEP ¶ <#rsa-oaep>


        22.1. Description ¶ <#rsa-oaep-description>

This section is non-normative.

The |"RSA-OAEP"| algorithm identifier is used to perform encryption and
decryption ordering to the RSAES-OAEP algorithm specified in [RFC3447
<#RFC3447>], using the SHA hash functions defined in this specification
and using the mask generation function MGF1.

Other specifications <#dfn-applicable-specification> may specify the use
of additional hash algorithms with RSAES-OAEP. Such specifications must
define the digest operation for the additional hash algorithm and key
import steps and key export steps for RSAES-OAEP.


        22.2. Registration ¶ <#rsa-oaep-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"RSA-OAEP"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
encrypt 	RsaOaepParams <#dfn-RsaOaepParams> 	ArrayBuffer <#dfn-ArrayBuffer>
decrypt 	RsaOaepParams <#dfn-RsaOaepParams> 	ArrayBuffer <#dfn-ArrayBuffer>
generateKey 	RsaHashedKeyGenParams <#dfn-RsaHashedKeyGenParams> 	
CryptoKeyPair <#dfn-CryptoKeyPair>
importKey 	RsaHashedImportParams <#dfn-RsaHashedImportParams> 	CryptoKey
<#dfn-CryptoKey>
exportKey 	None 	object


        22.3. RsaOaepParams dictionary ¶ <#rsa-oaep-params>

IDL

|
dictionary RsaOaepParams : Algorithm <#dfn-Algorithm> {
  // The optional label/application data to associate with the message
  BufferSource label;
};
          |


        22.4. Operations ¶ <#rsa-oaep-operations>

Encrypt

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"public"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Let label be the contents of <#concept-contents-of-arraybuffer>
        the label <#dfn-RsaOaepParams-label> member of
        normalizedAlgorithm or the empty octet string if the label
        <#dfn-RsaOaepParams-label> member of normalizedAlgorithm is not
        present.

     3.

        Perform the encryption operation defined in Section 7.1 of
        [RFC3447 <#RFC3447>] with the key represented by key as the
        recipient's RSA public key, the contents of plaintext <#concept-
        contents-of-arraybuffer> as the message to be encrypted, M and
        label as the label, L, and with the hash function specified by
        the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute of the
        [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of
        key as the Hash option and MGF1 (defined in Section B.2.1 of
        [RFC3447 <#RFC3447>]) as the MGF option.

     4.

        If performing the operation results in an error, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     5.

        Let ciphertext be the value C that results from performing the
        operation.

     6.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing ciphertext.

Decrypt

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"private"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Let label be the contents of <#concept-contents-of-arraybuffer>
        the label <#dfn-RsaOaepParams-label> member of
        normalizedAlgorithm or the empty octet string if the label
        <#dfn-RsaOaepParams-label> member of normalizedAlgorithm is not
        present.

     3.

        Perform the decryption operation defined in Section 7.1 of
        [RFC3447 <#RFC3447>] with the key represented by key as the
        recipient's RSA private key, the contents of ciphertext
        <#concept-contents-of-arraybuffer> as the ciphertext to be
        decrypted, C, and label as the label, L, and with the hash
        function specified by the hash <#dfn-RsaHashedKeyAlgorithm-hash>
        attribute of the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
        internal slot of key as the Hash option and MGF1 (defined in
        Section B.2.1 of [RFC3447 <#RFC3447>]) as the MGF option.

     4.

        If performing the operation results in an error, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     5.

        Let plaintext the value M that results from performing the
        operation.

     6.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing plaintext.

Generate Key

     1.

        If usages contains an entry which is not |"encrypt"|,
        |"decrypt"|, |"wrapKey"| or |"unwrapKey"|, then throw <#concept-
        throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        Generate an RSA key pair, as defined in [RFC3447 <#RFC3447>],
        with RSA modulus length equal to the modulusLength <#dfn-
        RsaKeyGenParams-modulusLength> member of normalizedAlgorithm and
        RSA public exponent equal to the publicExponent <#dfn-
        RsaKeyGenParams-publicExponent> member of normalizedAlgorithm.

     3.

        If performing the operation results in an error, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     4.

        Let algorithm be a new RsaHashedKeyAlgorithm <#dfn-
        RsaHashedKeyAlgorithm> object.

     5.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"RSA-OAEP"|.

     6.

        Set the modulusLength <#dfn-RsaKeyAlgorithm-modulusLength>
        attribute of algorithm to equal the modulusLength <#dfn-
        RsaKeyGenParams-modulusLength> member of normalizedAlgorithm.

     7.

        Set the publicExponent <#dfn-RsaKeyAlgorithm-publicExponent>
        attribute of algorithm to equal the publicExponent <#dfn-
        RsaKeyGenParams-publicExponent> member of normalizedAlgorithm.

     8.

        Set the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute of
        algorithm to equal the hash <#dfn-RsaHashedKeyGenParams> member
        of normalizedAlgorithm.

     9.

        Let publicKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the public key of the generated key
        pair.

    10.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        publicKey to |"public"|

    11.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of publicKey to algorithm.

    12.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of publicKey to true.

    13.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        publicKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "encrypt", "wrapKey" ]|.

    14.

        Let privateKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the private key of the generated key
        pair.

    15.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        privateKey to |"private"|

    16.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of privateKey to algorithm.

    17.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of privateKey to extractable.

    18.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        privateKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "decrypt", "unwrapKey" ]|.

    19.

        Let result be a new CryptoKeyPair <#dfn-CryptoKeyPair> dictionary.

    20.

        Set the publicKey <#dfn-CryptoKeyPair-publicKey> attribute of
        result to be publicKey.

    21.

        Set the privateKey <#dfn-CryptoKeyPair-privateKey> attribute of
        result to be privateKey.

    22.

        Return the result of converting result to an ECMAScript Object,
        as defined by [WebIDL <#WebIDL>].

Import Key

     1.

        Let keyData be the key data to be imported.

     2.

        If format is |"spki"|:
             1.

                If usages contains an entry which is not |"encrypt"| or
                |"wrapKey"|, then throw <#concept-throw> a |SyntaxError|
                <#dfn-SyntaxError>.

             2.

                Let spki be the result of running the parse a
                subjectPublicKeyInfo <#concept-parse-a-spki> algorithm
                over keyData.

             3.

                If an error occurred while parsing, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                Let hash be a string whose initial value is undefined.

             5.

                Let alg be the |algorithm| object identifier field of
                the |algorithm| AlgorithmIdentifier field of spki.

             6.

                If alg is equivalent to the |rsaEncryption| OID defined
                in RFC 3447 <#RFC3447>:

                    Let hash be undefined.

                If alg is equivalent to the |id-RSAES-OAEP| OID defined
                in RFC 3447 <#RFC3447>:
                     1.

                        Let params be the ASN.1 structure contained
                        within the |parameters| field of the |algorithm|
                        AlgorithmIdentifier field of spki.

                     2.

                        If params is not defined, or is not an instance
                        of the |RSAES-OAEP-params| ASN.1 type defined in
                        RFC3447 <#RFC3447>, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     3.

                        Let hashAlg be the AlgorithmIdentifier ASN.1
                        type within the |hashAlgorithm| field of params.

                     4.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha1| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-1"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha256| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-256"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha384| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-384"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha512| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-512"|.

                        Otherwise:
                             1.

                                Perform any key import steps <#dfn-rsa-
                                oaep-extended-import-steps> defined by
                                other applicable specifications <#dfn-
                                applicable-specification>, passing
                                format, spki and obtaining hash.

                             2.

                                If an error occured or there are no
                                applicable specifications <#dfn-
                                applicable-specification>, throw
                                <#concept-throw> a |DataError| <#dfn-
                                DataError>.

                     5.

                        If the |algorithm| object identifier field of
                        the |maskGenAlgorithm| field of params is not
                        equivalent to the OID |id-mgf1| defined in RFC
                        3447 <#RFC3447>, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                     6.

                        If the |parameters| field of the |
                        maskGenAlgorithm| field of params is not an
                        instance of the |HashAlgorithm| ASN.1 type that
                        is identical in content to the |hashAlglorithm|
                        field of params, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                Otherwise:

                    throw <#concept-throw> a |DataError| <#dfn-DataError>.

             7.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

             8.

                Let publicKey be the result of performing the parse an
                ASN.1 structure <#concept-parse-an-asn1-structure>
                algorithm, with data as the |subjectPublicKeyInfo| field
                of spki, structure as the |RSAPublicKey| structure
                specified in Section A.1.1 of RFC 3447 <#RFC3447>, and
                exactData set to true.

             9.

                If an error occurred while parsing, or it can be
                determined that publicKey is not a valid public key
                according to RFC 3447 <#RFC3447>, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

            10.

                Let key be a new CryptoKey <#dfn-CryptoKey> associated
                with the relevant global object <https://www.w3.org/TR/
                html51/webappapis.html#relevant-global-object> of |this|
                [HTML <#HTML>], and that represents the RSA public key
                identified by publicKey.

            11.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"public"|

        If format is |"pkcs8"|:
             1.

                If usages contains an entry which is not |"decrypt"| or
                |"unwrapKey"|, then throw <#concept-throw> a |
                SyntaxError| <#dfn-SyntaxError>.

             2.

                Let privateKeyInfo be the result of running the parse a
                privateKeyInfo <#concept-parse-a-privateKeyInfo>
                algorithm over keyData.

             3.

                If an error occurred while parsing, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                Let hash be a string whose initial value is undefined.

             5.

                Let alg be the |algorithm| object identifier field of
                the |privateKeyAlgorithm| PrivateKeyAlgorithmIdentifier
                field of privateKeyInfo.

             6.

                If alg is equivalent to the |rsaEncryption| OID defined
                in RFC 3447 <#RFC3447>:

                    Let hash be undefined.

                If alg is equivalent to the |id-RSAES-OAEP| OID defined
                in RFC 3447 <#RFC3447>:
                     1.

                        Let params be the ASN.1 structure contained
                        within the |parameters| field of the |
                        privateKeyAlgorithm|
                        PrivateKeyAlgorithmIdentifier field of
                        privateKeyInfo.

                     2.

                        If params is not defined, or is not an instance
                        of the |RSAES-OAEP-params| ASN.1 type defined in
                        RFC3447 <#RFC3447>, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                     3.

                        Let hashAlg be the AlgorithmIdentifier ASN.1
                        type within the |hashAlgorithm| field of params.

                     4.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha1| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-1"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha256| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-256"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha384| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-384"|.

                        If the |algorithm| object identifier field of
                        hashAlg is equivalent to the |id-sha512| OID
                        defined in RFC 3447 <#RFC3447>:

                            Set hash to the string |"SHA-512"|.

                        Otherwise:
                             1.

                                Perform any key import steps <#dfn-rsa-
                                oaep-extended-import-steps> defined by
                                other applicable specifications <#dfn-
                                applicable-specification>, passing
                                format, spki and obtaining hash.

                             2.

                                If an error occured or there are no
                                applicable specifications <#dfn-
                                applicable-specification>, throw
                                <#concept-throw> a |DataError| <#dfn-
                                DataError>.

                     5.

                        If the |algorithm| object identifier field of
                        the |maskGenAlgorithm| field of params is not
                        equivalent to the OID |id-mgf1| defined in RFC
                        3447 <#RFC3447>, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                     6.

                        If the |parameters| field of the |
                        maskGenAlgorithm| field of params is not an
                        instance of the |HashAlgorithm| ASN.1 type that
                        is identical in content to the |hashAlglorithm|
                        field of params, throw <#concept-throw> a |
                        NotSupportedError| <#dfn-NotSupportedError>.

                Otherwise:

                    throw <#concept-throw> a |DataError| <#dfn-DataError>.

             7.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

             8.

                Let rsaPrivateKey be the result of performing the parse
                an ASN.1 structure <#concept-parse-an-asn1-structure>
                algorithm, with data as the |privateKey| field of
                privateKeyInfo, structure as the |RSAPrivateKey|
                structure specified in Section A.1.2 of RFC 3447
                <#RFC3447>, and exactData set to true.

             9.

                If an error occurred while parsing, or if rsaPrivateKey
                is not a valid RSA private key according to RFC 3447
                <#RFC3447>, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            10.

                Let key be a new CryptoKey <#dfn-CryptoKey> associated
                with the relevant global object <https://www.w3.org/TR/
                html51/webappapis.html#relevant-global-object> of |this|
                [HTML <#HTML>], and that represents the RSA private key
                identified by rsaPrivateKey.

            11.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"private"|

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"d"| field of jwk is present and usages contains
                an entry which is not |"decrypt"| or |"unwrapKey"|, then
                throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

             3.

                If the |"d"| field of jwk is not present and usages
                contains an entry which is not |"encrypt"| or
                |"wrapKey"|, then throw <#concept-throw> a |SyntaxError|
                <#dfn-SyntaxError>.

             4.

                If the |"kty"| field of jwk is not a case-sensitive
                string match to |"RSA"|, then throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

             5.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not a case-sensitive string match to
                |"enc"|, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             6.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk> or does not contain all of the specified usages
                values, then throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             7.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

             8.

                If the |alg| field of jwk is not present:
                    Let hash be undefined.
                If the |alg| field of jwk is equal to |"RSA-OAEP"|:
                    Let hash be the string |"SHA-1"|.
                If the |alg| field of jwk is equal to |"RSA-OAEP-256"|:
                    Let hash be the string |"SHA-256"|.
                If the |alg| field of jwk is equal to |"RSA-OAEP-384"|:
                    Let hash be the string |"SHA-384"|.
                If the |alg| field of jwk is equal to |"RSA-OAEP-512"|:
                    Let hash be the string |"SHA-512"|.
                Otherwise:
                     1.

                        Perform any key import steps <#dfn-rsa-oaep-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, jwk and
                        obtaining hash.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

             9.

                If hash is not undefined:
                     1.

                        Let normalizedHash be the result of normalize an
                        algorithm <#dfn-normalize-an-algorithm> with |
                        alg| set to hash and |op| set to |digest|.

                     2.

                        If normalizedHash is not equal to the hash
                        <#dfn-RsaHashedImportParams-hash> member of
                        normalizedAlgorithm, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

            10.

                If the |"d"| field of jwk is present:
                     1.

                        If jwk does not meet the requirements of Section
                        6.3.2 of JSON Web Algorithms <#jwa>, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     2.

                        Let privateKey represent the RSA public key
                        identified by interpreting jwk according to
                        Section 6.3.1 of JSON Web Algorithms <#jwa>.

                     3.

                        If privateKey can be determined to not be a
                        valid RSA public key according to RFC 3447
                        <#RFC3447>, then throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        representing privateKey.

                     5.

                        Set the [[type <#dfn-CryptoKey-slot-type>]]
                        internal slot of key to |"private"|

                Otherwise:
                     1.

                        If jwk does not meet the requirements of Section
                        6.3.1 of JSON Web Algorithms <#jwa>, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     2.

                        Let publicKey represent the RSA public key
                        identified by interpreting jwk according to
                        Section 6.3.1 of JSON Web Algorithms <#jwa>.

                     3.

                        If publicKey can be determined to not be a valid
                        RSA public key according to RFC 3447 <#RFC3447>,
                        then throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        representing publicKey.

                     5.

                        Set the [[type <#dfn-CryptoKey-slot-type>]]
                        internal slot of key to |"public"|

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>. 

     3.

        Let algorithm be a new RsaHashedKeyAlgorithm <#dfn-
        RsaHashedKeyAlgorithm>.

     4.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"RSA-OAEP"|

     5.

        Set the modulusLength <#dfn-RsaKeyAlgorithm-modulusLength>
        attribute of algorithm to the length, in bits, of the RSA public
        modulus.

     6.

        Set the publicExponent <#dfn-RsaKeyAlgorithm-publicExponent>
        attribute of algorithm to the BigInteger <#dfn-BigInteger>
        representation of the RSA public exponent.

     7.

        Set the hash <#dfn-RsaHashedKeyAlgorithm-hash> attribute of
        algorithm to the hash <#dfn-RsaHashedImportParams-hash> member
        of normalizedAlgorithm.

     8.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm

     9.

        Return key.

Export Key

     1.

        Let key be the key to be exported.

     2.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     3.

        If format is |"spki"|
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"public"|, then throw <#concept-throw> an
                |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be an instance of the |subjectPublicKeyInfo|
                ASN.1 structure defined in RFC 5280 <#RFC5280> with the
                following properties:

                  *

                    Set the algorithm field to an |AlgorithmIdentifier|
                    ASN.1 type with the following properties:

                      o

                        Set the algorithm field to the OID |id-RSAES-
                        OAEP| defined in RFC 3447 <#RFC3447>.

                      o

                        Set the params field to an instance of the |
                        RSAES-OAEP-params| ASN.1 type with the following
                        properties:

                          +

                            Set the hashAlgorithm field to an instance
                            of the |HashAlgorithm| ASN.1 type with the
                            following properties:

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is |"SHA-1"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha1|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-256"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha256|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-384"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha384|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-512"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha512|
                                defined in RFC 3447 <#RFC3447>.

                            Otherwise:
                                 1.

                                    Perform any key export steps <#dfn-
                                    rsa-pss-extended-export-steps>
                                    defined by other applicable
                                    specifications <#dfn-applicable-
                                    specification>, passing format and
                                    the hash <#dfn-
                                    RsaHashedKeyAlgorithm> attribute of
                                    the [[algorithm <#dfn-CryptoKey-
                                    slot-algorithm>]] internal slot of
                                    key and obtaining hashOid and
                                    hashParams.

                                 2.

                                    Set the algorithm object identifier
                                    of hashAlgorithm to hashOid.

                                 3.

                                    Set the params field of
                                    hashAlgorithm to hashParams if
                                    hashParams is not undefined and omit
                                    the params field otherwise.

                          +

                            Set the maskGenAlgorithm field to an
                            instance of the |MaskGenAlgorithm| ASN.1
                            type with the following properties:

                              #

                                Set the algorithm field to the OID |id-
                                mgf1| defined in RFC 3447 <#RFC3447>.

                              #

                                Set the params field to an instance of
                                the |HashAlgorithm| ASN.1 type that is
                                identical to the hashAlgorithm field.

                  *

                    Set the subjectPublicKey field to the result of DER-
                    encoding an |RSAPublicKey| ASN.1 type, as defined in
                    RFC 3447 <#RFC3447>, Appendix A.1.1, that represents
                    the RSA public key represented by the [[handle
                    <#dfn-CryptoKey-slot-handle>]] internal slot of key

             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"pkcs8"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"private"|, then throw <#concept-throw>
                an |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be the result of encoding a privateKeyInfo
                structure with the following properties:

                  *

                    Set the version field to 0.

                  *

                    Set the privateKeyAlgorithm field to an |
                    PrivateKeyAlgorithmIdentifier| ASN.1 type with the
                    following properties:

                      o

                        Set the algorithm field to the OID |id-RSAES-
                        OAEP| defined in RFC 3447 <#RFC3447>.

                      o

                        Set the params field to an instance of the |
                        RSAES-OAEP-params| ASN.1 type with the following
                        properties:

                          +

                            Set the hashAlgorithm field to an instance
                            of the |HashAlgorithm| ASN.1 type with the
                            following properties:

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is |"SHA-1"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha1|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-256"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha256|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-384"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha384|
                                defined in RFC 3447 <#RFC3447>.

                            If the name <#dfn-KeyAlgorithm-name>
                            attribute of the hash <#dfn-
                            RsaHashedKeyAlgorithm> attribute of the
                            [[algorithm <#dfn-CryptoKey-slot-
                            algorithm>]] internal slot of key is
                            |"SHA-512"|:

                                Set the algorithm object identifier of
                                hashAlgorithm to the OID |id-sha512|
                                defined in RFC 3447 <#RFC3447>.

                            Otherwise:
                                 1.

                                    Perform any key export steps <#dfn-
                                    rsa-oaep-extended-export-steps>
                                    defined by other applicable
                                    specifications <#dfn-applicable-
                                    specification>, passing format and
                                    the hash <#dfn-
                                    RsaHashedKeyAlgorithm> attribute of
                                    the [[algorithm <#dfn-CryptoKey-
                                    slot-algorithm>]] internal slot of
                                    key and obtaining hashOid and
                                    hashParams.

                                 2.

                                    Set the algorithm object identifier
                                    of hashAlgorithm to hashOid.

                                 3.

                                    Set the params field of
                                    hashAlgorithm to hashParams if
                                    hashParams is not undefined and omit
                                    the params field otherwise.

                          +

                            Set the maskGenAlgorithm field to an
                            instance of the |MaskGenAlgorithm| ASN.1
                            type with the following properties:

                              #

                                Set the algorithm field to the OID |id-
                                mgf1| defined in RFC 3447 <#RFC3447>.

                              #

                                Set the params field to an instance of
                                the |HashAlgorithm| ASN.1 type that is
                                identical to the hashAlgorithm field.

                  *

                    Set the privateKey field to the result of DER-
                    encoding an |RSAPrivateKey| ASN.1 type, as defined
                    in RFC 3447 <#RFC3447>, Appendix A.1.2, that
                    represents the RSA private key represented by the
                    [[handle <#dfn-CryptoKey-slot-handle>]] internal
                    slot of key

                    Note
                    RFC 5208 <#RFC5208> specifies that the encoding of
                    this field should be /BER/ encoded in Section 5 (as
                    a "for example"). However, to avoid requiring
                    WebCrypto implementations support BER-encoding and
                    BER-decoding, only /DER/ encodings are produced or
                    accepted.
             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
              *

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

              *

                Set the |kty| attribute of jwk to the string |"RSA"|.

              *

                If the name <#dfn-KeyAlgorithm-name> attribute of the
                hash <#dfn-RsaHashedKeyAlgorithm> attribute of the
                [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
                slot of key is |"SHA-1"|:

                    Set the |alg| attribute of jwk to the string |"RSA-
                    OAEP"|.

                If the name <#dfn-KeyAlgorithm-name> attribute of the
                hash <#dfn-RsaHashedKeyAlgorithm> attribute of the
                [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
                slot of key is |"SHA-256"|:

                    Set the |alg| attribute of jwk to the string |"RSA-
                    OAEP-256"|.

                If the name <#dfn-KeyAlgorithm-name> attribute of the
                hash <#dfn-RsaHashedKeyAlgorithm> attribute of the
                [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
                slot of key is |"SHA-384"|:

                    Set the |alg| attribute of jwk to the string |"RSA-
                    OAEP-384"|.

                If the name <#dfn-KeyAlgorithm-name> attribute of the
                hash <#dfn-RsaHashedKeyAlgorithm> attribute of the
                [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
                slot of key is |"SHA-512"|:

                    Set the |alg| attribute of jwk to the string |"RSA-
                    OAEP-512"|.

                Otherwise:
                     1.

                        Perform any key export steps <#dfn-rsa-oaep-
                        extended-export-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format and the hash
                        <#dfn-RsaHashedKeyAlgorithm> attribute of the
                        [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                        internal slot of key and obtaining alg.

                     2.

                        Set the |alg| attribute of jwk to alg.

              *

                Set the attributes |n| and |e| of jwk according to the
                corresponding definitions in JSON Web Algorithms <#jwa>,
                Section 6.3.1.

              *

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is |"private"|:
                     1.

                        Set the attributes named |d|, |p|, |q|, |dp|, |
                        dq|, and |qi| of jwk according to the
                        corresponding definitions in JSON Web Algorithms
                        <#jwa>, Section 6.3.2.

                     2.

                        If the underlying RSA private key represented by
                        the [[handle <#dfn-CryptoKey-slot-handle>]]
                        internal slot of key is represented by more than
                        two primes, set the attribute named |oth| of jwk
                        according to the corresponding definition in
                        JSON Web Algorithms <#jwa>, Section 6.3.2.7

              *

                Set the |key_ops| attribute of jwk to the usages <#dfn-
                CryptoKey-usages> attribute of key.

              *

                Set the |ext| attribute of jwk to the [[extractable
                <#dfn-CryptoKey-slot-extractable>]] internal slot of key.

              *

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        Otherwise

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     4.

        Return result.


      23. ECDSA ¶ <#ecdsa>


        23.1. Description ¶ <#ecdsa-description>

This section is non-normative.

The |"ECDSA"| algorithm identifier is used to perform signing and
verification using the ECDSA algorithm specified in [RFC6090 <#RFC6090>]
and using the SHA hash functions and elliptic curves defined in this
specification.

Other specifications <#dfn-applicable-specification> may specify the use
of additional elliptic curves and hash algorithms with ECDSA. To specify
additional hash algorithms to be used with ECDSA, a specification must
define a registered algorithm <#algorithms> that supports the digest
operation. To specify an additional elliptic curve a specification must
define the curve name, ECDSA signature steps, ECDSA verification steps,
ECDSA generation steps, ECDSA key import steps and ECDSA key export steps.


        23.2. Registration ¶ <#ecdsa-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"ECDSA"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
sign 	EcdsaParams <#dfn-EcdsaParams> 	ArrayBuffer <#dfn-ArrayBuffer>
verify 	EcdsaParams <#dfn-EcdsaParams> 	boolean
generateKey 	EcKeyGenParams <#dfn-EcKeyGenParams> 	CryptoKeyPair <#dfn-
CryptoKeyPair>
importKey 	EcKeyImportParams <#dfn-EcKeyImportParams> 	CryptoKey <#dfn-
CryptoKey>
exportKey 	None 	object


        23.3. EcdsaParams dictionary ¶ <#EcdsaParams-dictionary>

IDL

|
dictionary EcdsaParams : Algorithm <#dfn-Algorithm> {
  // The hash algorithm to use
  required HashAlgorithmIdentifier <#dfn-HashAlgorithmIdentifier> hash;
};
          |


        23.4. EcKeyGenParams dictionary ¶ <#EcKeyGenParams-dictionary>

IDL

|
typedef DOMString NamedCurve <#dfn-NamedCurve>;

dictionary EcKeyGenParams : Algorithm <#dfn-Algorithm> {
  // A named curve
  required NamedCurve <#dfn-NamedCurve> namedCurve;
};
          |

The NamedCurve type represents named elliptic curves, which are a
convenient way to specify the domain parameters of well-known elliptic
curves. The following values defined by this specification:

|"P-256"|
    NIST recommended curve P-256, also known as |secp256r1|.
|"P-384"|
    NIST recommended curve P-384, also known as |secp384r1|.
|"P-521"|
    NIST recommended curve P-521, also known as |secp521r1|.

Other specifications <#dfn-applicable-specification> may define
additional values <#dfn-ecdsa-extended-namedcurve-values>.


        23.5. EcKeyAlgorithm dictionary ¶ <#EcKeyAlgorithm-dictionary>

IDL

|
dictionary EcKeyAlgorithm : KeyAlgorithm <#dfn-KeyAlgorithm> {
  // The named curve that the key uses
  required NamedCurve <#dfn-NamedCurve> namedCurve;
};
          |


        23.6. EcKeyImportParams dictionary ¶ <#EcKeyImportParams-dictionary>

IDL

|
dictionary EcKeyImportParams : Algorithm <#dfn-Algorithm> {
  // A named curve
  required NamedCurve <#dfn-NamedCurve> namedCurve;
};
          |


        23.7. Operations ¶ <#ecdsa-operations>

Sign
    When signing, the following algorithm should be used:

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"private"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Let hashAlgorithm be the hash <#dfn-EcdsaParams-hash> member of
        normalizedAlgorithm.

     3.

        Let M be the result of performing the digest operation specified
        by hashAlgorithm using message.

     4.

        Let d be the ECDSA private key associated with key.

     5.

        Let params be the EC domain parameters associated with key.

     6.

        If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve> attribute of
        the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot
        of key is |"P-256"|, |"P-384"| or |"P-521"|:
             1.

                Perform the ECDSA signing process, as specified in
                RFC6090 <#RFC6090>, Section 5.4, with M as the message,
                using params as the EC domain parameters, and with d as
                the private key.

             2.

                Let r and s be the pair of integers resulting from
                performing the ECDSA signing process.

             3.

                Let result be a new empty ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>].

             4.

                Let n be the smallest integer such that n * 8 is greater
                than the logarithm to base 2 of the order of the base
                point of the elliptic curve identified by params.

             5.

                Convert r to an octet string of length n <#dfn-convert-
                integer-to-octet-string> and append this sequence of
                bytes to result.

             6.

                Convert s to an octet string of length n <#dfn-convert-
                integer-to-octet-string> and append this sequence of
                bytes to result.

        Otherwise, the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
        attribute of the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
        internal slot of key is a value specified in an applicable
        specification <#dfn-applicable-specification>:

            Perform the ECDSA signature steps <#dfn-ecdsa-extended-
            signature-steps> specified in that specification, passing in
            M, params and d and resulting in result.

     7.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing the bytes of result.

Verify
    When verifying, the following algorithm should be used:

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"public"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Let hashAlgorithm be the hash <#dfn-EcdsaParams-hash> member of
        normalizedAlgorithm.

     3.

        Let M be the result of performing the digest operation specified
        by hashAlgorithm using message.

     4.

        Let Q be the ECDSA public key associated with key.

     5.

        Let params be the EC domain parameters associated with key.

     6.

        If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve> attribute of
        the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot
        of key is |"P-256"|, |"P-384"| or |"P-521"|:

            Perform the ECDSA verifying process, as specified in RFC6090
            <#RFC6090>, Section 5.3, with M as the received message,
            signature as the received signature and using params as the
            EC domain parameters, and Q as the public key.

        Otherwise, the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
        attribute of the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
        internal slot of key is a value specified in an applicable
        specification <#dfn-applicable-specification>:

            Perform the ECDSA verification steps <#dfn-ecdsa-extended-
            verification-steps> specified in that specification passing
            in M, signature, params and Q and resulting in an indication
            of whether or not the purported signature is valid.

     7.

        Let result be a boolean with the value |true| if the signature
        is valid and the value |false| otherwise.

     8.

        Return result.

Generate Key

     1.

        If usages contains a value which is not one of |"sign"| or
        |"verify"|, then throw <#concept-throw> a |SyntaxError| <#dfn-
        SyntaxError>.

     2.

        If the namedCurve <#dfn-EcKeyGenParams-namedCurve> member of
        normalizedAlgorithm is |"P-256"|, |"P-384"| or |"P-521"|:

            Generate an Elliptic Curve key pair, as defined in [RFC6090
            <#RFC6090>] with domain parameters for the curve identified
            by the namedCurve <#dfn-EcKeyGenParams-namedCurve> member of
            normalizedAlgorithm.

        If the namedCurve <#dfn-EcKeyGenParams-namedCurve> member of
        normalizedAlgorithm is a value specified in an applicable
        specification <#dfn-applicable-specification>:

            Perform the ECDSA key generation steps <#dfn-ecdsa-extended-
            generation-steps> specified in that specification, passing
            in normalizedAlgorithm and resulting in an elliptic curve
            key pair.

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            OperationError>

     3.

        If performing the key generation operation results in an error,
        then throw <#concept-throw> an |OperationError| <#dfn-
        OperationError>.

     4.

        Let algorithm be a new EcKeyAlgorithm <#dfn-EcKeyAlgorithm> object.

     5.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"ECDSA"|.

     6.

        Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve> attribute of
        algorithm to equal the namedCurve <#dfn-EcKeyGenParams> member
        of normalizedAlgorithm.

     7.

        Let publicKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the public key of the generated key
        pair.

     8.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        publicKey to |"public"|

     9.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of publicKey to algorithm.

    10.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of publicKey to true.

    11.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        publicKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "verify" ]|.

    12.

        Let privateKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the private key of the generated key
        pair.

    13.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        privateKey to |"private"|

    14.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of privateKey to algorithm.

    15.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of privateKey to extractable.

    16.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        privateKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "sign" ]|.

    17.

        Let result be a new CryptoKeyPair <#dfn-CryptoKeyPair> dictionary.

    18.

        Set the publicKey <#dfn-CryptoKeyPair-publicKey> attribute of
        result to be publicKey.

    19.

        Set the privateKey <#dfn-CryptoKeyPair-privateKey> attribute of
        result to be privateKey.

    20.

        Return the result of converting result to an ECMAScript Object,
        as defined by [WebIDL <#WebIDL>].

Import Key

     1.

        Let keyData be the key data to be imported.

     2.

        If format is |"spki"|:
             1.

                If usages contains a value which is not |"verify"| then
                throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

             2.

                Let spki be the result of running the parse a
                subjectPublicKeyInfo <#concept-parse-a-spki> algorithm
                over keyData

             3.

                If an error occurred while parsing, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                If the |algorithm| object identifier field of the |
                algorithm| AlgorithmIdentifier field of spki is not
                equal to the |id-ecPublicKey| object identifier defined
                in RFC 5480 <#RFC5480>, then throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

             5.

                If the |parameters| field of the |algorithm|
                AlgorithmIdentifier field of spki is absent, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             6.

                Let params be the |parameters| field of the |algorithm|
                AlgorithmIdentifier field of spki.

             7.

                If params is not an instance of the |ECParameters| ASN.1
                type defined in RFC 5480 <#RFC5480> that specifies a |
                namedCurve|, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             8.

                Let namedCurve be a string whose initial value is
                undefined.

             9.

                If params is equivalent to the |secp256r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-256"|.

                If params is equivalent to the |secp384r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-384"|.

                If params is equivalent to the |secp521r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-521"|.

            10.

                If namedCurve is not undefined:
                     1.

                        Let publicKey be the Elliptic Curve public key
                        identified by performing the conversion steps
                        defined in Section 2.3.4 of SEC 1 <#SEC1> using
                        the the |subjectPublicKey| field of spki.

                        The uncompressed point format MUST be supported.

                     2.

                        If the implementation does not support the
                        compressed point format and a compressed point
                        is provided, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     3.

                        If a decode error occurs or an identity point is
                        found, throw <#concept-throw> a |DataError|
                        <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        associated with the relevant global object
                        <https://www.w3.org/TR/html51/
                        webappapis.html#relevant-global-object> of |
                        this| [HTML <#HTML>], and that represents
                        publicKey.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-ecdsa-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, spki and
                        obtaining namedCurve and key.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

            11.

                If namedCurve is defined, and not equal to the
                namedCurve <#dfn-EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm, throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

            12.

                If the public key value is not a valid point on the
                Elliptic Curve identified by the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            13.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"public"|

            14.

                Let algorithm be a new EcKeyAlgorithm <#dfn-
                EcKeyAlgorithm>.

            15.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"ECDSA"|.

            16.

                Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of algorithm to namedCurve.

            17.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

        If format is |"pkcs8"|:
             1.

                If usages contains a value which is not |"sign"| then
                throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

             2.

                Let privateKeyInfo be the result of running the parse a
                privateKeyInfo <#concept-parse-a-privateKeyInfo>
                algorithm over keyData.

             3.

                If an error occurs while parsing, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

             4.

                If the |algorithm| object identifier field of the |
                privateKeyAlgorithm| PrivateKeyAlgorithm field of
                privateKeyInfo is not equal to the |id-ecPublicKey|
                object identifier defined in RFC 5480 <#RFC5480>, then
                throw <#concept-throw> a |DataError| <#dfn-DataError>.

             5.

                If the |parameters| field of the |privateKeyAlgorithm|
                PrivateKeyAlgorithmIdentifier field of privateKeyInfo is
                not present, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             6.

                Let params be the |parameters| field of the |
                privateKeyAlgorithm| PrivateKeyAlgorithmIdentifier field
                of privateKeyInfo.

             7.

                If params is not an instance of the |ECParameters| ASN.1
                type defined in RFC 5480 <#RFC5480> that specifies a |
                namedCurve|, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             8.

                Let namedCurve be a string whose initial value is
                undefined.

             9.

                If params is equivalent to the |secp256r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-256"|.

                If params is equivalent to the |secp384r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-384"|.

                If params is equivalent to the |secp521r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-521"|.

            10.

                If namedCurve is not undefined:
                     1.

                        Let ecPrivateKey be the result of performing the
                        parse an ASN.1 structure <#concept-parse-an-
                        asn1-structure> algorithm, with data as the |
                        privateKey| field of privateKeyInfo, structure
                        as the ASN.1 |ECPrivateKey| structure specified
                        in Section 3 of RFC 5915 <#RFC5915>, and
                        exactData set to true.

                     2.

                        If an error occurred while parsing, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     3.

                        If the |parameters| field of ecPrivateKey is
                        present, and is not an instance of the |
                        namedCurve| ASN.1 type defined in RFC 5480
                        <#RFC5480>, or does not contain the same object
                        identifier as the |parameters| field of the |
                        privateKeyAlgorithm|
                        PrivateKeyAlgorithmIdentifier field of
                        privateKeyInfo, then throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        associated with the relevant global object
                        <https://www.w3.org/TR/html51/
                        webappapis.html#relevant-global-object> of |
                        this| [HTML <#HTML>], and that represents the
                        Elliptic Curve private key identified by
                        performing the conversion steps defined in
                        Section 3 of RFC 5915 <#RFC5915> using
                        ecPrivateKey.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-ecdsa-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, privateKeyInfo
                        and obtaining namedCurve and key.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

            11.

                If namedCurve is defined, and not equal to the
                namedCurve <#dfn-EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm, throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

            12.

                If the private key value is not a valid point on the
                Elliptic Curve identified by the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            13.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"private"|

            14.

                Let algorithm be a new EcKeyAlgorithm <#dfn-
                EcKeyAlgorithm>.

            15.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"ECDSA"|.

            16.

                Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of algorithm to namedCurve.

            17.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"d"| field is present and usages contains a
                value which is not |"sign"|, or, if the |"d"| field is
                not present and usages contains a value which is not
                |"verify"| then throw <#concept-throw> a |SyntaxError|
                <#dfn-SyntaxError>.

             3.

                If the |"kty"| field of jwk is not |"EC"|, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not |"sig"|, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             5.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk>, or it does not contain all of the specified
                usages values, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             6.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

             7.

                Let namedCurve be a string whose value is equal to the
                |"crv"| field of jwk.

             8.

                If namedCurve is not equal to the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm, throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

             9.

                If namedCurve is equal to |"P-256"|, |"P-384"| or
                |"P-521"|:
                     1.

                        Let algNamedCurve be a string whose initial
                        value is undefined.

                     2.

                        If the |"alg"| field is not present:
                            Let algNamedCurve be undefined. 
                        If the |"alg"| field is equal to the string
                        "ES256":
                            Let algNamedCurve be the string |"P-256"|. 
                        If the |"alg"| field is equal to the string
                        "ES384":
                            Let algNamedCurve be the string |"P-384"|. 
                        If the |"alg"| field is equal to the string
                        "ES512":
                            Let algNamedCurve be the string |"P-521"|. 
                        otherwise:
                            throw <#concept-throw> a |DataError| <#dfn-
                            DataError>. 

                     3.

                        If algNamedCurve is defined, and is not equal to
                        namedCurve, throw <#concept-throw> a |DataError|
                        <#dfn-DataError>.

                     4.

                        If the |"d"| field is present:
                             1.

                                If jwk does not meet the requirements of
                                Section 6.2.2 of JSON Web Algorithms
                                <#jwa>, then throw <#concept-throw> a |
                                DataError| <#dfn-DataError>.

                             2.

                                Let key be a new CryptoKey <#dfn-
                                CryptoKey> object that represents the
                                Elliptic Curve private key identified by
                                interpreting jwk according to Section
                                6.2.2 of JSON Web Algorithms <#jwa>.

                             3.

                                Set the [[type <#dfn-CryptoKey-slot-
                                type>]] internal slot of Key to
                                |"private"|.

                        Otherwise:
                             1.

                                If jwk does not meet the requirements of
                                Section 6.2.1 of JSON Web Algorithms
                                <#jwa>, then throw <#concept-throw> a |
                                DataError| <#dfn-DataError>.

                             2.

                                Let key be a new CryptoKey <#dfn-
                                CryptoKey> object that represents the
                                Elliptic Curve public key identified by
                                interpreting jwk according to Section
                                6.2.1 of JSON Web Algorithms <#jwa>.

                             3.

                                Set the [[type <#dfn-CryptoKey-slot-
                                type>]] internal slot of Key to |"public"|.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-ecdsa-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, jwk and
                        obtaining key.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

            10.

                If the key value is not a valid point on the Elliptic
                Curve identified by the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            11.

                Let algorithm be a new instance of an EcKeyAlgorithm
                <#dfn-EcKeyAlgorithm> object.

            12.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"ECDSA"|.

            13.

                Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of algorithm to namedCurve.

            14.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

        If format is |"raw"|:
             1.

                If the namedCurve <#dfn-EcKeyImportParams-namedCurve>
                member of normalizedAlgorithm is not a named curve
                <#dfn-NamedCurve>, then throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

             2.

                If usages contains a value which is not |"verify"| then
                throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

             3.

                If namedCurve is |"P-256"|, |"P-384"| or |"P-521"|:
                     1.

                        Let Q be the elliptic curve point on the curve
                        identified by the namedCurve <#dfn-
                        EcKeyImportParams-namedCurve> member of
                        normalizedAlgorithm identified by performing the
                        conversion steps defined in Section 2.3.4 of SEC
                        1 <#SEC1> on keyData.

                        The uncompressed point format MUST be supported.

                     2.

                        If the implementation does not support the
                        compressed point format and a compressed point
                        is provided, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     3.

                        If a decode error occurs or an identity point is
                        found, throw <#concept-throw> a |DataError|
                        <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        associated with the relevant global object
                        <https://www.w3.org/TR/html51/
                        webappapis.html#relevant-global-object> of |
                        this| [HTML <#HTML>], and that represents Q

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-ecdh-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, keyData and
                        obtaining key.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

             4.

                Let algorithm be a new EcKeyAlgorithm <#dfn-
                EcKeyAlgorithm> object.

             5.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"ECDH"|.

             6.

                Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of algorithm to equal the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm.

             7.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"public"|

             8.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     3.

        Return key

Export Key

     1.

        Let key be the CryptoKey <#dfn-CryptoKey> to be exported.

     2.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     3.

        If format is |"spki"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"public"|, then throw <#concept-throw> an
                |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be an instance of the |subjectPublicKeyInfo|
                ASN.1 structure defined in RFC 5280 <#RFC5280> with the
                following properties:

                  *

                    Set the algorithm field to an |AlgorithmIdentifier|
                    ASN.1 type with the following properties:

                      o

                        Set the algorithm object identifier to the OID |
                        1.2.840.10045.2.1|.

                      o

                        Set the parameters field to an instance of the |
                        ECParameters| ASN.1 type defined in RFC 5480
                        <#RFC5480> as follows:

                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-256"|, |"P-384"| or |"P-521"|:

                            Let keyData be the octet string <#dfn-octet-
                            string> that represents the Elliptic Curve
                            public key represented by the [[handle
                            <#dfn-CryptoKey-slot-handle>]] internal slot
                            of key according to the encoding rules
                            specified in Section 2.2 of RFC 5480
                            <#RFC5480> and using the uncompressed form.
                            and keyData.

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-256"|:

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier |secp256r1| defined in RFC
                                5480 <#RFC5480>

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-384"|:

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier |secp384r1| defined in RFC
                                5480 <#RFC5480>

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-521"|:

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier |secp521r1| defined in RFC
                                5480 <#RFC5480>

                        Otherwise:
                             1.

                                Perform any key export steps <#dfn-
                                ecdsa-extended-export-steps> defined by
                                other applicable specifications <#dfn-
                                applicable-specification>, passing
                                format and the namedCurve <#dfn-
                                EcKeyAlgorithm-namedCurve> attribute of
                                the [[algorithm <#dfn-CryptoKey-slot-
                                algorithm>]] internal slot of key and
                                obtaining namedCurveOid and keyData.

                             2.

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier namedCurveOid.

                  *

                    Set the subjectPublicKey field to keyData.

             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"pkcs8"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"private"|, then throw <#concept-throw>
                an |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be an instance of the |privateKeyInfo| ASN.1
                structure defined in RFC 5280 <#RFC5280> with the
                following properties:

                  *

                    Set the version field to |0|.

                  *

                    Set the privateKeyAlgorithm field to an |
                    PrivateKeyAlgorithmIdentifier| ASN.1 type with the
                    following properties:

                      o

                        Set the algorithm object identifier to the OID |
                        1.2.840.10045.2.1|.

                      o

                        Set the parameters field to an instance of the |
                        ECParameters| ASN.1 type defined in RFC 5480
                        <#RFC5480> as follows:

                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-256"|, |"P-384"| or |"P-521"|:

                            Let keyData be the result of DER-encoding an
                            instance of the |ECPrivateKey| structure
                            defined in Section 3 of RFC 5915 <#RFC5915>
                            for the Elliptic Curve private key
                            represented by the [[handle <#dfn-CryptoKey-
                            slot-handle>]] internal slot of key and that
                            conforms to the following:

                              +

                                The parameters field is present, and is
                                equivalent to the parameters field of
                                the privateKeyAlgorithm field of this |
                                PrivateKeyInfo| ASN.1 structure.

                              +

                                The publicKey field is present and
                                represents the Elliptic Curve public key
                                associated with the Elliptic Curve
                                private key represented by the [[handle
                                <#dfn-CryptoKey-slot-handle>]] internal
                                slot of key.

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-256"|:

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier |secp256r1| defined in RFC
                                5480 <#RFC5480>

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-384"|:

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier |secp384r1| defined in RFC
                                5480 <#RFC5480>

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-521"|:

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier |secp521r1| defined in RFC
                                5480 <#RFC5480>

                        Otherwise:
                             1.

                                Perform any key export steps <#dfn-
                                ecdsa-extended-export-steps> defined by
                                other applicable specifications <#dfn-
                                applicable-specification>, passing
                                format and the namedCurve <#dfn-
                                EcKeyAlgorithm-namedCurve> attribute of
                                the [[algorithm <#dfn-CryptoKey-slot-
                                algorithm>]] internal slot of key and
                                obtaining namedCurveOid and keyData.

                             2.

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier namedCurveOid.

                  *

                    Set the privateKey field to keyData.

             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
             1.

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

             2.

                Set the |kty| attribute of jwk to |"EC"|.

             3.

                If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of the [[algorithm <#dfn-CryptoKey-slot-
                algorithm>]] internal slot of key is |"P-256"|,
                |"P-384"| or |"P-521"|:
                     1.

                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-256"|:
                            Set the |crv| attribute of jwk to |"P-256"| 
                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-384"|:
                            Set the |crv| attribute of jwk to |"P-384"| 
                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-521"|:
                            Set the |crv| attribute of jwk to |"P-521"| 

                     2.

                        Set the |x| attribute of jwk according to the
                        definition in Section 6.2.1.2 of JSON Web
                        Algorithms <#jwa>.

                     3.

                        Set the |y| attribute of jwk according to the
                        definition in Section 6.2.1.3 of JSON Web
                        Algorithms <#jwa>.

                     4.

                        If the [[type <#dfn-CryptoKey-slot-type>]]
                        internal slot of key is |"private"|

                            Set the |d| attribute of jwk according to
                            the definition in Section 6.2.2.1 of JSON
                            Web Algorithms <#jwa>.

                Otherwise:
                     1.

                        Perform any key export steps <#dfn-ecdsa-
                        extended-export-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format and the
                        namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                        attribute of the [[algorithm <#dfn-CryptoKey-
                        slot-algorithm>]] internal slot of key and
                        obtaining namedCurve and a new value of jwk.

                     2.

                        Set the |crv| attribute of jwk to namedCurve.

             4.

                Set the |key_ops| attribute of jwk to the usages <#dfn-
                CryptoKey-usages> attribute of key.

             5.

                Set the |ext| attribute of jwk to the [[extractable
                <#dfn-CryptoKey-slot-extractable>]] internal slot of key.

             6.

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        If format is |"raw"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"public"|, then throw <#concept-throw> an
                |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of the [[algorithm <#dfn-CryptoKey-slot-
                algorithm>]] internal slot of key is |"P-256"|,
                |"P-384"| or |"P-521"|:

                    Let data be an octet string <#dfn-octet-string>
                    representing the Elliptic Curve point Q represented
                    by [[handle <#dfn-CryptoKey-slot-handle>]] internal
                    slot of key according to SEC 1 <#SEC1> 2.3.3 using
                    the uncompressed format.

                Otherwise:

                    Perform any key export steps <#dfn-ecdh-extended-
                    export-steps> defined by other applicable
                    specifications <#dfn-applicable-specification>,
                    passing format and the namedCurve <#dfn-
                    EcKeyAlgorithm-namedCurve> attribute of the
                    [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                    internal slot of key and obtaining namedCurve and data.

             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     4.

        Return result.


      24. ECDH ¶ <#ecdh>


        24.1. Description ¶ <#ecdh-description>

This section is non-normative.

This describes using Elliptic Curve Diffie-Hellman (ECDH) for key
generation and key agreement, as specified by RFC6090 <#RFC6090>.

Other specifications <#dfn-applicable-specification> may specify the use
of additional elliptic curves with ECDH. To specify an additional
elliptic curve a specification must define the curve name, ECDH
generation steps, ECDH derivation steps, ECDH key import steps and ECDH
key export steps.


        24.2. Registration ¶ <#ecdh-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"ECDH"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
generateKey 	EcKeyGenParams <#dfn-EcKeyGenParams> 	CryptoKeyPair <#dfn-
CryptoKeyPair>
deriveBits 	EcdhKeyDeriveParams <#dfn-EcdhKeyDeriveParams> 	Octet string
<#dfn-octet-string>
importKey 	EcKeyImportParams <#dfn-EcKeyImportParams> 	CryptoKey <#dfn-
CryptoKey>
exportKey 	None 	object


        24.3. EcdhKeyDeriveParams dictionary ¶ <#dh-EcdhKeyDeriveParams>

IDL

|
dictionary EcdhKeyDeriveParams : Algorithm <#dfn-Algorithm> {
  // The peer's EC public key.
  required CryptoKey <#dfn-CryptoKey> public;
};
          |


        24.4. Operations ¶ <#ecdh-operations>

Generate Key

     1.

        If usages contains an entry which is not |"deriveKey"| or
        |"deriveBits"| then throw <#concept-throw> a |SyntaxError|
        <#dfn-SyntaxError>.

     2.

        If the namedCurve <#dfn-EcKeyGenParams-namedCurve> member of
        normalizedAlgorithm is |"P-256"|, |"P-384"| or |"P-521"|:

            Generate an Elliptic Curve key pair, as defined in [RFC6090
            <#RFC6090>] with domain parameters for the curve identified
            by the namedCurve <#dfn-EcKeyGenParams-namedCurve> member of
            normalizedAlgorithm.

        If the namedCurve <#dfn-EcKeyGenParams-namedCurve> member of
        normalizedAlgorithm is a value specified in an applicable
        specification <#dfn-applicable-specification> that specifies the
        use of that value with ECDH:

            Perform the ECDH key generation steps <#dfn-ecdh-extended-
            generation-steps> specified in that specification, passing
            in normalizedAlgorithm and resulting in an elliptic curve
            key pair.

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            OperationError>

     3.

        If performing the operation results in an error, then throw
        <#concept-throw> a |OperationError| <#dfn-OperationError>.

     4.

        Let algorithm be a new EcKeyAlgorithm <#dfn-EcKeyAlgorithm> object.

     5.

        Set the name <#dfn-Algorithm-name> member of algorithm to |"ECDH"|.

     6.

        Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve> attribute of
        algorithm to equal the namedCurve <#dfn-EcKeyGenParams> member
        of normalizedAlgorithm.

     7.

        Let publicKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the public key of the generated key
        pair.

     8.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        publicKey to |"public"|

     9.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of publicKey to algorithm.

    10.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of publicKey to true.

    11.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        publicKey to be the empty list.

    12.

        Let privateKey be a new CryptoKey <#dfn-CryptoKey> associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing the private key of the generated key
        pair.

    13.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        privateKey to |"private"|

    14.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of privateKey to algorithm.

    15.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of privateKey to extractable.

    16.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        privateKey to be the usage intersection <#concept-usage-
        intersection> of usages and |[ "deriveKey", "deriveBits" ]|.

    17.

        Let result be a new CryptoKeyPair <#dfn-CryptoKeyPair> dictionary.

    18.

        Set the publicKey <#dfn-CryptoKeyPair-publicKey> attribute of
        result to be publicKey.

    19.

        Set the privateKey <#dfn-CryptoKeyPair-privateKey> attribute of
        result to be privateKey.

    20.

        Return the result of converting result to an ECMAScript Object,
        as defined by [WebIDL <#WebIDL>].

Derive Bits

     1.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        is not |"private"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     2.

        Let publicKey be the public <#dfn-EcdhKeyDeriveParams-public>
        member of normalizedAlgorithm.

     3.

        If the [[type <#dfn-CryptoKey-slot-type>]] internal slot of
        publicKey is not |"public"|, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     4.

        If the name <#dfn-KeyAlgorithm-name> attribute of the
        [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of
        publicKey is not equal to the name <#dfn-KeyAlgorithm-name>
        property of the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
        internal slot of key, then throw <#concept-throw> an |
        InvalidAccessError| <#dfn-InvalidAccessError>.

     5.

        If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve> attribute of
        the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot
        of publicKey is not equal to the namedCurve <#dfn-
        EcKeyAlgorithm-namedCurve> property of the [[algorithm <#dfn-
        CryptoKey-slot-algorithm>]] internal slot of key, then throw
        <#concept-throw> an |InvalidAccessError| <#dfn-InvalidAccessError>.

     6.

        If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve> property of
        the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot
        of key is |"P-256"|, |"P-384"| or |"P-521"|:
             1.

                Perform the ECDH primitive specified in RFC6090
                <#RFC6090> Section 4 with key as the EC private key d
                and the EC public key represented by the [[handle <#dfn-
                CryptoKey-slot-handle>]] internal slot of publicKey as
                the EC public key.

             2.

                Let secret be the result of applying the field element
                to octet string <#dfn-octet-string> conversion defined
                in Section 6.2 of RFC6090 <#RFC6090> to the output of
                the ECDH primitive.

        If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve> property of
        the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot
        of key is a value specified in an applicable specification
        <#dfn-applicable-specification> that specifies the use of that
        value with ECDH:

            Perform the ECDH key derivation steps <#dfn-ecdh-extended-
            derivation-steps> specified in that specification, passing
            in key and publicKey and resulting in secret.

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            OperationError>

     7.

        If performing the operation results in an error, then throw
        <#concept-throw> a |OperationError| <#dfn-OperationError>.

     8.

        If length is null:
            Return secret
        Otherwise:

            If the length of secret in bits is less than length:
                throw <#concept-throw> an |OperationError| <#dfn-
                OperationError>. 
            Otherwise:
                Return an octet string containing <#dfn-octet-string-
                containing> the first length bits of secret. 

Import Key

     1.

        Let keyData be the key data to be imported.

     2.

        If format is |"spki"|:
             1.

                If usages is not empty then throw <#concept-throw> a |
                SyntaxError| <#dfn-SyntaxError>.

             2.

                Let spki be the result of running the parse a
                subjectPublicKeyInfo <#concept-parse-a-spki> algorithm
                over keyData

             3.

                If an error occurred while parsing, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             4.

                If the |algorithm| object identifier field of the |
                algorithm| AlgorithmIdentifier field of spki is not
                equal to the |id-ecPublicKey| or |id-ecDH| object
                identifiers defined in RFC 5480 <#RFC5480>, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             5.

                If the |parameters| field of the |algorithm|
                AlgorithmIdentifier field of spki is absent, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             6.

                Let params be the |parameters| field of the |algorithm|
                AlgorithmIdentifier field of spki.

             7.

                If params is not an instance of the |ECParameters| ASN.1
                type defined in RFC 5480 <#RFC5480> that specifies a |
                namedCurve|, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             8.

                Let namedCurve be a string whose initial value is
                undefined.

             9.

                If params is equivalent to the |secp256r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-256"|.

                If params is equivalent to the |secp384r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-384"|.

                If params is equivalent to the |secp521r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve |"P-521"|.

            10.

                If namedCurve is not undefined:
                     1.

                        Let publicKey be the Elliptic Curve public key
                        identified by performing the conversion steps
                        defined in Section 2.3.4 of SEC 1 <#SEC1> to the
                        |subjectPublicKey| field of spki.

                        The uncompressed point format MUST be supported.

                     2.

                        If the implementation does not support the
                        compressed point format and a compressed point
                        is provided, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     3.

                        If a decode error occurs or an identity point is
                        found, throw <#concept-throw> a |DataError|
                        <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        associated with the relevant global object
                        <https://www.w3.org/TR/html51/
                        webappapis.html#relevant-global-object> of |
                        this| [HTML <#HTML>], and that represents
                        publicKey.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-ecdh-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, spki and
                        obtaining namedCurve and key.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

            11.

                If namedCurve is defined, and not equal to the
                namedCurve <#dfn-EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm, throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

            12.

                If the key value is not a valid point on the Elliptic
                Curve identified by the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            13.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"public"|

            14.

                Let algorithm be a new EcKeyAlgorithm <#dfn-
                EcKeyAlgorithm>.

            15.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"ECDH"|.

            16.

                Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of algorithm to namedCurve.

            17.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

        If format is |"pkcs8"|:
             1.

                If usages contains an entry which is not |"deriveKey"|
                or |"deriveBits"| then throw <#concept-throw> a |
                SyntaxError| <#dfn-SyntaxError>.

             2.

                Let privateKeyInfo be the result of running the parse a
                privateKeyInfo <#concept-parse-a-privateKeyInfo>
                algorithm over keyData.

             3.

                If an error occurs while parsing, throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             4.

                If the |algorithm| object identifier field of the |
                privateKeyAlgorithm| PrivateKeyAlgorithm field of
                privateKeyInfo is not equal to the |id-ecPublicKey| or |
                id-ecDH| object identifiers defined in RFC 5480
                <#RFC5480>, throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             5.

                If the |parameters| field of the |privateKeyAlgorithm|
                PrivateKeyAlgorithmIdentifier field of privateKeyInfo is
                not present, throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             6.

                Let params be the |parameters| field of the |
                privateKeyAlgorithm| PrivateKeyAlgorithmIdentifier field
                of privateKeyInfo.

             7.

                If params is not an instance of the |ECParameters| ASN.1
                type defined in RFC 5480 <#RFC5480> that specifies a |
                namedCurve|, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             8.

                Let namedCurve be a string whose initial value is
                undefined.

             9.

                If params is equivalent to the |secp256r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve to |"P-256"|.

                If params is equivalent to the |secp384r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve to |"P-384"|.

                If params is equivalent to the |secp521r1| object
                identifier defined in RFC 5480 <#RFC5480>:

                    Set namedCurve to |"P-521"|.

            10.

                If namedCurve is not undefined:
                     1.

                        Let ecPrivateKey be the result of performing the
                        parse an ASN.1 structure <#concept-parse-an-
                        asn1-structure> algorithm, with data as the |
                        privateKey| field of privateKeyInfo, structure
                        as the ASN.1 |ECPrivateKey| structure specified
                        in Section 3 of RFC 5915 <#RFC5915>, and
                        exactData set to true.

                     2.

                        If an error occurred while parsing, then throw
                        <#concept-throw> a |DataError| <#dfn-DataError>.

                     3.

                        If the |parameters| field of ecPrivateKey is
                        present, and is not an instance of the |
                        namedCurve| ASN.1 type defined in RFC 5480
                        <#RFC5480>, or does not contain the same object
                        identifier as the |parameters| field of the |
                        privateKeyAlgorithm|
                        PrivateKeyAlgorithmIdentifier field of
                        privateKeyInfo, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        associated with the relevant global object
                        <https://www.w3.org/TR/html51/
                        webappapis.html#relevant-global-object> of |
                        this| [HTML <#HTML>], and that represents the
                        Elliptic Curve private key identified by
                        performing the conversion steps defined in
                        Section 3 of RFC 5915 <#RFC5915> using
                        ecPrivateKey.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-ecdh-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, privateKeyInfo
                        and obtaining namedCurve and key.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

            11.

                If namedCurve is defined, and not equal to the
                namedCurve <#dfn-EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm, throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

            12.

                If the key value is not a valid point on the Elliptic
                Curve identified by the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            13.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"private"|.

            14.

                Let algorithm be a new EcKeyAlgorithm <#dfn-
                EcKeyAlgorithm>.

            15.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"ECDH"|.

            16.

                Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of algorithm to namedCurve.

            17.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"d"| field is present and if usages contains an
                entry which is not |"deriveKey"| or |"deriveBits"| then
                throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

             3.

                If the |"d"| field is not present and if usages is not
                empty then throw <#concept-throw> a |SyntaxError| <#dfn-
                SyntaxError>.

             4.

                If the |"kty"| field of jwk is not |"EC"|, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             5.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not equal to |"enc"| then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             6.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk>, or it does not contain all of the specified
                usages values, then throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

             7.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

             8.

                Let namedCurve be a string whose value is equal to the
                |"crv"| field of jwk.

             9.

                If namedCurve is not equal to the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm, throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

            10.

                If namedCurve is |"P-256"|, |"P-384"| or |"P-521"|:

                    If the |"d"| field is present:
                         1.

                            If jwk does not meet the requirements of
                            Section 6.2.2 of JSON Web Algorithms <#jwa>,
                            then throw <#concept-throw> a |DataError|
                            <#dfn-DataError>.

                         2.

                            Let key be a new CryptoKey <#dfn-CryptoKey>
                            object that represents the Elliptic Curve
                            private key identified by interpreting jwk
                            according to Section 6.2.2 of JSON Web
                            Algorithms <#jwa>.

                         3.

                            Set the [[type <#dfn-CryptoKey-slot-type>]]
                            internal slot of Key to |"private"|.

                    Otherwise:
                         1.

                            If jwk does not meet the requirements of
                            Section 6.2.1 of JSON Web Algorithms <#jwa>,
                            then throw <#concept-throw> a |DataError|
                            <#dfn-DataError>.

                         2.

                            Let key be a new CryptoKey <#dfn-CryptoKey>
                            object that represents the Elliptic Curve
                            public key identified by interpreting jwk
                            according to Section 6.2.1 of JSON Web
                            Algorithms <#jwa>.

                         3.

                            Set the [[type <#dfn-CryptoKey-slot-type>]]
                            internal slot of Key to |"public"|.

                Otherwise
                     1.

                        Perform any key import steps <#dfn-ecdh-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, jwk and
                        obtaining key.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

            11.

                If the key value is not a valid point on the Elliptic
                Curve identified by the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm throw <#concept-throw> a |DataError|
                <#dfn-DataError>.

            12.

                Let algorithm be a new instance of an EcKeyAlgorithm
                <#dfn-EcKeyAlgorithm> object.

            13.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"ECDH"|.

            14.

                Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of algorithm to namedCurve.

            15.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

        If format is |"raw"|:
             1.

                If the namedCurve <#dfn-EcKeyImportParams-namedCurve>
                member of normalizedAlgorithm is not a named curve
                <#dfn-NamedCurve>, then throw <#concept-throw> a |
                DataError| <#dfn-DataError>.

             2.

                If usages is not the empty list, then throw <#concept-
                throw> a |SyntaxError| <#dfn-DataError>.

             3.

                If namedCurve is |"P-256"|, |"P-384"| or |"P-521"|:
                     1.

                        Let Q be the Elliptic Curve public key on the
                        curve identified by the namedCurve <#dfn-
                        EcKeyImportParams-namedCurve> member of
                        normalizedAlgorithm identified by performing the
                        conversion steps defined in Section 2.3.4 of SEC
                        1 <#SEC1> to keyData.

                        The uncompressed point format MUST be supported.

                     2.

                        If the implementation does not support the
                        compressed point format and a compressed point
                        is provided, throw <#concept-throw> a |
                        DataError| <#dfn-DataError>.

                     3.

                        If a decode error occurs or an identity point is
                        found, throw <#concept-throw> a |DataError|
                        <#dfn-DataError>.

                     4.

                        Let key be a new CryptoKey <#dfn-CryptoKey>
                        associated with the relevant global object
                        <https://www.w3.org/TR/html51/
                        webappapis.html#relevant-global-object> of |
                        this| [HTML <#HTML>], and that represents Q.

                Otherwise:
                     1.

                        Perform any key import steps <#dfn-ecdh-
                        extended-import-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format, keyData and
                        obtaining key.

                     2.

                        If an error occured or there are no applicable
                        specifications <#dfn-applicable-specification>,
                        throw <#concept-throw> a |DataError| <#dfn-
                        DataError>.

             4.

                Let algorithm be a new EcKeyAlgorithm <#dfn-
                EcKeyAlgorithm> object.

             5.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"ECDH"|.

             6.

                Set the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of algorithm to equal the namedCurve <#dfn-
                EcKeyImportParams-namedCurve> member of
                normalizedAlgorithm.

             7.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"public"|

             8.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

     3.

        Return key

Export Key

     1.

        Let key be the CryptoKey <#dfn-CryptoKey> to be exported.

     2.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     3.

        If format is |"spki"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"public"|, then throw <#concept-throw> an
                |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be an instance of the |subjectPublicKeyInfo|
                ASN.1 structure defined in RFC 5280 <#RFC5280> with the
                following properties:

                  *

                    Set the algorithm field to an |AlgorithmIdentifier|
                    ASN.1 type with the following properties:

                      o

                        Set the algorithm object identifier to the OID |
                        1.3.132.1.12|.

                      o

                        Set the parameters field to an instance of the |
                        ECParameters| ASN.1 type defined in RFC 5480
                        <#RFC5480> as follows:

                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-256"|, |"P-384"| or |"P-521"|:

                            Let keyData be the octet string <#dfn-octet-
                            string> that represents the Elliptic Curve
                            public key represented by the [[handle
                            <#dfn-CryptoKey-slot-handle>]] internal slot
                            of key according to the encoding rules
                            specified in Section 2.3.3 of SEC 1 <#SEC1>
                            and using the uncompressed form.

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-256"|:

                                Set parameters to the namedCurve choice
                                with value equal to the object
                                identifier |secp256r1| defined in RFC
                                5480 <#RFC5480>

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-384"|:

                                Set parameters to the namedCurve choice
                                with value equal to the object
                                identifier |secp384r1| defined in RFC
                                5480 <#RFC5480>

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-521"|:

                                Set parameters to the namedCurve choice
                                with value equal to the object
                                identifier |secp521r1| defined in RFC
                                5480 <#RFC5480>

                        Otherwise:
                             1.

                                Perform any key export steps <#dfn-ecdh-
                                extended-export-steps> defined by other
                                applicable specifications <#dfn-
                                applicable-specification>, passing
                                format and the namedCurve <#dfn-
                                EcKeyAlgorithm-namedCurve> attribute of
                                the [[algorithm <#dfn-CryptoKey-slot-
                                algorithm>]] internal slot of key and
                                obtaining namedCurveOid and keyData.

                             2.

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier namedCurveOid.

                  *

                    Set the subjectPublicKey field to keyData

        If format is |"pkcs8"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"private"|, then throw <#concept-throw>
                an |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                Let data be an instance of the |privateKeyInfo| ASN.1
                structure defined in RFC 5280 <#RFC5280> with the
                following properties:

                  *

                    Set the version field to |0|.

                  *

                    Set the privateKeyAlgorithm field to an |
                    PrivateKeyAlgorithmIdentifier| ASN.1 type with the
                    following properties:

                      o

                        Set the algorithm object identifier to the OID |
                        1.3.132.1.12|.

                      o

                        Set the parameters field to an instance of the |
                        ECParameters| ASN.1 type defined in RFC 5480
                        <#RFC5480> as follows:

                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-256"|, |"P-384"| or |"P-521"|:

                            Let keyData be the result of DER-encoding an
                            instance of the |ECPrivateKey| structure
                            defined in Section 3 of RFC 5915 <#RFC5915>
                            for the Elliptic Curve private key
                            represented by the [[handle <#dfn-CryptoKey-
                            slot-handle>]] internal slot of key and that
                            conforms to the following:

                              +

                                The parameters field is present, and is
                                equivalent to the parameters field of
                                the privateKeyAlgorithm field of this |
                                PrivateKeyInfo| ASN.1 structure.

                              +

                                The publicKey field is present and
                                represents the Elliptic Curve public key
                                associated with the Elliptic Curve
                                private key represented by the [[handle
                                <#dfn-CryptoKey-slot-handle>]] internal
                                slot of key.

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-256"|:

                                Set parameters to the namedCurve choice
                                with value equal to the object
                                identifier |secp256r1| defined in RFC
                                5480 <#RFC5480>

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-384"|:

                                Set parameters to the namedCurve choice
                                with value equal to the object
                                identifier |secp384r1| defined in RFC
                                5480 <#RFC5480>

                            If the namedCurve <#dfn-EcKeyAlgorithm-
                            namedCurve> attribute of the [[algorithm
                            <#dfn-CryptoKey-slot-algorithm>]] internal
                            slot of key is |"P-521"|:

                                Set parameters to the namedCurve choice
                                with value equal to the object
                                identifier |secp521r1| defined in RFC
                                5480 <#RFC5480>

                        Otherwise:
                             1.

                                Perform any key export steps <#dfn-ecdh-
                                extended-export-steps> defined by other
                                applicable specifications <#dfn-
                                applicable-specification>, passing
                                format and the namedCurve <#dfn-
                                EcKeyAlgorithm-namedCurve> attribute of
                                the [[algorithm <#dfn-CryptoKey-slot-
                                algorithm>]] internal slot of key and
                                obtaining namedCurveOid and keyData.

                             2.

                                Set parameters to the |namedCurve|
                                choice with value equal to the object
                                identifier namedCurveOid.

                  *

                    Set the privateKey field to keyData.

        If format is |"jwk"|:
             1.

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

             2.

                Set the |kty| attribute of jwk to |"EC"|.

             3.

                If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of the [[algorithm <#dfn-CryptoKey-slot-
                algorithm>]] internal slot of key is |"P-256"|,
                |"P-384"| or |"P-521"|:
                     1.

                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-256"|:
                            Set the |crv| attribute of jwk to |"P-256"| 
                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-384"|:
                            Set the |crv| attribute of jwk to |"P-384"| 
                        If the namedCurve <#dfn-EcKeyAlgorithm-
                        namedCurve> attribute of the [[algorithm <#dfn-
                        CryptoKey-slot-algorithm>]] internal slot of key
                        is |"P-521"|:
                            Set the |crv| attribute of jwk to |"P-521"| 

                     2.

                        Set the |x| attribute of jwk according to the
                        definition in Section 6.2.1.2 of JSON Web
                        Algorithms <#jwa>.

                     3.

                        Set the |y| attribute of jwk according to the
                        definition in Section 6.2.1.3 of JSON Web
                        Algorithms <#jwa>.

                     4.

                        If the [[type <#dfn-CryptoKey-slot-type>]]
                        internal slot of key is |"private"|

                            Set the |d| attribute of jwk according to
                            the definition in Section 6.2.2.1 of JSON
                            Web Algorithms <#jwa>.

                Otherwise:
                     1.

                        Perform any key export steps <#dfn-ecdh-
                        extended-export-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format and the
                        namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                        attribute of the [[algorithm <#dfn-CryptoKey-
                        slot-algorithm>]] internal slot of key and
                        obtaining namedCurve and a new value of jwk.

                     2.

                        Set the |crv| attribute of jwk to namedCurve.

             4.

                Set the |key_ops| attribute of jwk to the usages <#dfn-
                CryptoKey-usages> attribute of key.

             5.

                Set the |ext| attribute of jwk to the [[extractable
                <#dfn-CryptoKey-slot-extractable>]] internal slot of key.

             6.

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        If format is |"raw"|:
             1.

                If the [[type <#dfn-CryptoKey-slot-type>]] internal slot
                of key is not |"public"|, then throw <#concept-throw> an
                |InvalidAccessError| <#dfn-InvalidAccessError>.

             2.

                If the namedCurve <#dfn-EcKeyAlgorithm-namedCurve>
                attribute of the [[algorithm <#dfn-CryptoKey-slot-
                algorithm>]] internal slot of key is |"P-256"|,
                |"P-384"| or |"P-521"|:

                    Let data be the octet string <#dfn-octet-string>
                    that represents the Elliptic Curve public key
                    represented by the [[handle <#dfn-CryptoKey-slot-
                    handle>]] internal slot of key according to the
                    encoding rules specified in Section 2.3.3 of SEC 1
                    <#SEC1> and using the uncompressed form.

                Otherwise:

                    Perform any key export steps <#dfn-ecdh-extended-
                    export-steps> defined by other applicable
                    specifications <#dfn-applicable-specification>,
                    passing format and the namedCurve <#dfn-
                    EcKeyAlgorithm-namedCurve> attribute of the
                    [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                    internal slot of key and obtaining namedCurve and data.

             3.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

     4.

        Return result.


      25. AES-CTR ¶ <#aes-ctr>


        25.1. Description ¶ <#aes-ctr-description>

This section is non-normative.

The |"AES-CTR"| algorithm identifier is used to perform encryption and
decryption using AES in Counter mode, as described in [NIST SP800-38A
<#SP800-38A>].


        25.2. Registration ¶ <#aes-ctr-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"AES-CTR"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
encrypt 	AesCtrParams <#dfn-AesCtrParams> 	ArrayBuffer <#dfn-ArrayBuffer>
decrypt 	AesCtrParams <#dfn-AesCtrParams> 	ArrayBuffer <#dfn-ArrayBuffer>
generateKey 	AesKeyGenParams <#dfn-AesKeyGenParams> 	CryptoKey <#dfn-
CryptoKey>
importKey 	None 	CryptoKey <#dfn-CryptoKey>
exportKey 	None 	object
get key length 	AesDerivedKeyParams <#dfn-AesDerivedKeyParams> 	Integer


        25.3. AesCtrParams dictionary ¶ <#aes-ctr-params>

IDL

|
dictionary AesCtrParams : Algorithm <#dfn-Algorithm> {
  // The initial value of the counter block. counter MUST be 16 bytes
  // (the AES block size). The counter bits are the rightmost length
  // bits of the counter block. The rest of the counter block is for
  // the nonce. The counter bits are incremented using the standard
  // incrementing function specified in NIST SP 800-38A Appendix B.1:
  // the counter bits are interpreted as a big-endian integer and
  // incremented by one.
  required BufferSource counter;
  // The length, in bits, of the rightmost part of the counter block
  // that is incremented.
  [EnforceRange] required octet length;
};
          |

IDL

|
dictionary AesKeyAlgorithm : KeyAlgorithm <#dfn-KeyAlgorithm> {
  // The length, in bits, of the key.
  required unsigned short length;
};
          |


        25.5. AesKeyGenParams dictionary ¶ <#aes-keygen-params>

IDL

|
dictionary AesKeyGenParams : Algorithm <#dfn-Algorithm> {
  // The length, in bits, of the key.
  [EnforceRange] required unsigned short length;
};
          |


        25.6. AesDerivedKeyParams dictionary ¶ <#aes-derivedkey-params>

IDL

|
dictionary AesDerivedKeyParams : Algorithm <#dfn-Algorithm> {
  // The length, in bits, of the key.
  [EnforceRange] required unsigned short length;
};
          |


        25.7. Operations ¶ <#aes-ctr-operations>

Encrypt

     1.

        If the counter <#dfn-AesCtrParams-counter> member of
        normalizedAlgorithm does not have length 16 bytes, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     2.

        If the length <#dfn-AesCtrParams-length> member of
        normalizedAlgorithm is zero or is greater than 128, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        Let ciphertext be the result of performing the CTR Encryption
        operation described in Section 6.5 of [NIST SP800-38A
        <#SP800-38A>] using AES as the block cipher, the contents of
        <#concept-contents-of-arraybuffer> the counter <#dfn-
        AesCtrParams-counter> member of normalizedAlgorithm as the
        initial value of the counter block, the length <#dfn-
        AesCtrParams-length> member of normalizedAlgorithm as the input
        parameter m to the standard counter block incrementing function
        defined in Appendix B.1 of [NIST SP800-38A <#SP800-38A>] and the
        contents of plaintext <#concept-contents-of-arraybuffer> as the
        input plaintext.

     4.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing ciphertext.

Decrypt

     1.

        If the counter <#dfn-AesCtrParams-counter> member of
        normalizedAlgorithm does not have length 16 bytes, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     2.

        If the length <#dfn-AesCtrParams-length> member of
        normalizedAlgorithm is zero or is greater than 128, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        Let plaintext be the result of performing the CTR Decryption
        operation described in Section 6.5 of [NIST SP800-38A
        <#SP800-38A>] using AES as the block cipher, the contents of
        <#concept-contents-of-arraybuffer> the counter <#dfn-
        AesCtrParams-counter> member of normalizedAlgorithm as the
        initial value of the counter block, the length <#dfn-
        AesCtrParams-length> member of normalizedAlgorithm as the input
        parameter m to the standard counter block incrementing function
        defined in Appendix B.1 of [NIST SP800-38A <#SP800-38A>] and the
        contents of ciphertext <#concept-contents-of-arraybuffer> as the
        input ciphertext.

     4.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing plaintext.

Generate Key

     1.

        If usages contains any entry which is not one of |"encrypt"|,
        |"decrypt"|, |"wrapKey"| or |"unwrapKey"|, then throw <#concept-
        throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        If the length <#dfn-AesKeyGenParams-length> member of
        normalizedAlgorithm is not equal to one of 128, 192 or 256, then
        throw <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        Generate an AES key of length equal to the length <#dfn-
        AesKeyGenParams-length> member of normalizedAlgorithm.

     4.

        If the key generation step fails, then throw <#concept-throw> an
        |OperationError| <#dfn-OperationError>.

     5.

        Let key be a new CryptoKey <#dfn-CryptoKey> object representing
        the generated AES key.

     6.

        Let algorithm be a new AesKeyAlgorithm <#dfn-AesKeyAlgorithm>.

     7.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"AES-CTR"|.

     8.

        Set the length <#dfn-AesKeyAlgorithm-length> attribute of
        algorithm to equal the length <#dfn-AesKeyGenParams-length>
        member of normalizedAlgorithm.

     9.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

    10.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of key to be extractable.

    11.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        key to be usages.

    12.

        Return key.

Import Key

     1.

        If usages contains an entry which is not one of |"encrypt"|,
        |"decrypt"|, |"wrapKey"| or |"unwrapKey"|, then throw <#concept-
        throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        If format is |"raw"|:
             1.

                Let data be the octet string <#dfn-octet-string>
                contained in keyData.

             2.

                If the length in bits of data is not 128, 192 or 256
                then throw <#concept-throw> a |DataError| <#dfn-DataError>.

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"kty"| field of jwk is not |"oct"|, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             3.

                If jwk does not meet the requirements of Section 6.4 of
                JSON Web Algorithms <#jwa>, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             4.

                Let data be the octet string <#dfn-octet-string>
                obtained by decoding the |"k"| field of jwk.

             5.

                If data has length 128 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A128CTR"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>. 
                If data has length 192 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A192CTR"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>. 
                If data has length 256 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A256CTR"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>. 
                Otherwise:
                    throw <#concept-throw> a |DataError| <#dfn-DataError>.

             6.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not |"enc"|, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             7.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk> or does not contain all of the specified usages
                values, then throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             8.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>. 

     3.

        Let key be a new |CryptoKey <#dfn-CryptoKey>| object
        representing an AES key with value data.

     4.

        Let algorithm be a new AesKeyAlgorithm <#dfn-AesKeyAlgorithm>.

     5.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"AES-CTR"|.

     6.

        Set the length <#dfn-AesKeyAlgorithm-length> attribute of
        algorithm to the length, in bits, of data.

     7.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

     8.

        Return key.

Export Key

     1.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     2.

        If format is |"raw"|:
             1.

                Let data be the raw octets of the key represented by
                [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of
                key.

             2.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
             1.

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

             2.

                Set the |kty| attribute of jwk to the string |"oct"|.

             3.

                Set the |k| attribute of jwk to be a string containing
                the raw octets of the key represented by [[handle <#dfn-
                CryptoKey-slot-handle>]] internal slot of key, encoded
                according to Section 6.4 of JSON Web Algorithms <#jwa>.

             4.

                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 128:
                    Set the |alg| attribute of jwk to the string
                    |"A128CTR"|.
                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 192:
                    Set the |alg| attribute of jwk to the string
                    |"A192CTR"|.
                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 256:
                    Set the |alg| attribute of jwk to the string
                    |"A256CTR"|.

             5.

                Set the |key_ops| attribute of jwk to equal the [[usages
                <#dfn-CryptoKey-slot-usages>]] internal slot of key.

             6.

                Set the |ext| attribute of jwk to equal the
                [[extractable <#dfn-CryptoKey-slot-extractable>]]
                internal slot of key.

             7.

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     3.

        Return result.

Get key length

     1.

        If the length <#dfn-AesDerivedKeyParams-length> member of
        normalizedDerivedKeyAlgorithm is not 128, 192 or 256, then throw
        <#concept-throw> a |OperationError| <#dfn-OperationError>.

     2.

        Return the length <#dfn-AesDerivedKeyParams-length> member of
        normalizedDerivedKeyAlgorithm.


      26. AES-CBC ¶ <#aes-cbc>


        26.1. Description ¶ <#aes-cbc-description>

This section is non-normative.

The |"AES-CBC"| algorithm identifier is used to perform encryption and
decryption using AES in Cipher Block Chaining mode, as described in
[NIST SP800-38A <#SP800-38A>].

When operating in CBC mode, messages that are not exact multiples of the
AES block size (16 bytes) can be padded under a variety of padding
schemes. In the Web Crypto API, the only padding mode that is supported
is that of PKCS#7, as described by Section 10.3, step 2, of [RFC2315
<#RFC2315>].


        26.2. Registration ¶ <#aes-cbc-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"AES-CBC"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
encrypt 	AesCbcParams <#dfn-AesCbcParams> 	ArrayBuffer <#dfn-ArrayBuffer>
decrypt 	AesCbcParams <#dfn-AesCbcParams> 	ArrayBuffer <#dfn-ArrayBuffer>
generateKey 	AesKeyGenParams <#dfn-AesKeyGenParams> 	CryptoKey <#dfn-
CryptoKey>
importKey 	None 	CryptoKey <#dfn-CryptoKey>
exportKey 	None 	object
get key length 	AesDerivedKeyParams <#dfn-AesDerivedKeyParams> 	Integer


        26.3. AesCbcParams dictionary ¶ <#aes-cbc-params>

IDL

|
dictionary AesCbcParams : Algorithm <#dfn-Algorithm> {
  // The initialization vector. MUST be 16 bytes.
  required BufferSource iv;
};
          |


        26.4. Operations ¶ <#aes-cbc-operations>

Encrypt

     1.

        If the iv <#dfn-AesCbcParams-iv> member of normalizedAlgorithm
        does not have length 16 bytes, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     2.

        Let paddedPlaintext be the result of adding padding octets to
        the contents of ciphertext <#concept-contents-of-arraybuffer>
        according to the procedure defined in Section 10.3 of [RFC2315
        <#RFC2315>], step 2, with a value of k of 16.

     3.

        Let ciphertext be the result of performing the CBC Encryption
        operation described in Section 6.2 of [NIST SP800-38A
        <#SP800-38A>] using AES as the block cipher, the contents of
        <#concept-contents-of-arraybuffer> the iv <#dfn-AesCbcParams-iv>
        member of normalizedAlgorithm as the IV input parameter and
        paddedPlaintext as the input plaintext.

     4.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing ciphertext.

Decrypt

     1.

        If the iv <#dfn-AesCbcParams-iv> member of normalizedAlgorithm
        does not have length 16 bytes, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     2.

        Let paddedPlaintext be the result of performing the CBC
        Decryption operation described in Section 6.2 of [NIST SP800-38A
        <#SP800-38A>] using AES as the block cipher, the contents of
        <#concept-contents-of-arraybuffer> the iv <#dfn-AesCbcParams-iv>
        member of normalizedAlgorithm as the IV input parameter and the
        contents of ciphertext <#concept-contents-of-arraybuffer> as the
        input ciphertext.

     3.

        Let p be the value of the last octet of paddedPlaintext.

     4.

        If p is zero or greater than 16, or if any of the last p octets
        of paddedPlaintext have a value which is not p, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     5.

        Let plaintext be the result of removing p octets from the end of
        paddedPlaintext.

     6.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing plaintext.

Generate Key

     1.

        If usages contains any entry which is not one of |"encrypt"|,
        |"decrypt"|, |"wrapKey"| or |"unwrapKey"|, then throw <#concept-
        throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        If the length <#dfn-AesKeyGenParams-length> member of
        normalizedAlgorithm is not equal to one of 128, 192 or 256, then
        throw <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        Generate an AES key of length equal to the length <#dfn-
        AesKeyGenParams-length> member of normalizedAlgorithm.

     4.

        If the key generation step fails, then throw <#concept-throw> an
        |OperationError| <#dfn-OperationError>.

     5.

        Let key be a new CryptoKey <#dfn-CryptoKey> object representing
        the generated AES key.

     6.

        Let algorithm be a new AesKeyAlgorithm <#dfn-AesKeyAlgorithm>.

     7.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"AES-CBC"|.

     8.

        Set the length <#dfn-AesKeyAlgorithm-length> attribute of
        algorithm to equal the length <#dfn-AesKeyGenParams-length>
        member of normalizedAlgorithm.

     9.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

    10.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of key to be extractable.

    11.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        key to be usages.

    12.

        Return key.

Import Key

     1.

        If usages contains an entry which is not one of |"encrypt"|,
        |"decrypt"|, |"wrapKey"| or |"unwrapKey"|, then throw <#concept-
        throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        If format is |"raw"|:
             1.

                Let data be the octet string <#dfn-octet-string>
                contained in keyData.

             2.

                If the length in bits of data is not 128, 192 or 256
                then throw <#concept-throw> a |DataError| <#dfn-DataError>.

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"kty"| field of jwk is not |"oct"|, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             3.

                If jwk does not meet the requirements of Section 6.4 of
                JSON Web Algorithms <#jwa>, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             4.

                Let data be the octet string <#dfn-octet-string>
                obtained by decoding the |"k"| field of jwk.

             5.

                If data has length 128 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A128CBC"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                If data has length 192 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A192CBC"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                If data has length 256 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A256CBC"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                Otherwise:
                    throw <#concept-throw> a |DataError| <#dfn-DataError>. 

             6.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not |"enc"|, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             7.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk> or does not contain all of the specified usages
                values, then throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             8.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError> 

     3.

        Let key be a new |CryptoKey <#dfn-CryptoKey>| object
        representing an AES key with value data.

     4.

        Let algorithm be a new AesKeyAlgorithm <#dfn-AesKeyAlgorithm>.

     5.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"AES-CBC"|.

     6.

        Set the length <#dfn-AesKeyAlgorithm-length> attribute of
        algorithm to the length, in bits, of data.

     7.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

     8.

        Return key.

Export Key

     1.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     2.

        If format is |"raw"|:
             1.

                Let data be the raw octets of the key represented by
                [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of
                key.

             2.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                Set the |kty| attribute of jwk to the string |"oct"|.

             3.

                Set the |k| attribute of jwk to be a string containing
                the raw octets of the key represented by [[handle <#dfn-
                CryptoKey-slot-handle>]] internal slot of key, encoded
                according to Section 6.4 of JSON Web Algorithms <#jwa>.

             4.

                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 128:
                    Set the |alg| attribute of jwk to the string
                    |"A128CBC"|.
                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 192:
                    Set the |alg| attribute of jwk to the string
                    |"A192CBC"|.
                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 256:
                    Set the |alg| attribute of jwk to the string
                    |"A256CBC"|.

             5.

                Set the |key_ops| attribute of jwk to equal the usages
                <#dfn-CryptoKey-usages> attribute of key.

             6.

                Set the |ext| attribute of jwk to equal the
                [[extractable <#dfn-CryptoKey-slot-extractable>]]
                internal slot of key.

             7.

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     3.

        Return result.

Get key length

     1.

        If the length <#dfn-AesDerivedKeyParams-length> member of
        normalizedDerivedKeyAlgorithm is not 128, 192 or 256, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     2.

        Return the length <#dfn-AesDerivedKeyParams-length> member of
        normalizedDerivedKeyAlgorithm.


      27. AES-GCM ¶ <#aes-gcm>


        27.1. Description ¶ <#aes-gcm-description>

This section is non-normative.

The |"AES-GCM"| algorithm identifier is used to perform authenticated
encryption and decryption using AES in Galois/Counter Mode mode, as
described in [NIST SP 800-38D <#SP800-38D>].


        27.2. Registration ¶ <#aes-gcm-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"AES-GCM"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
encrypt 	AesGcmParams <#dfn-AesGcmParams> 	ArrayBuffer <#dfn-ArrayBuffer>
decrypt 	AesGcmParams <#dfn-AesGcmParams> 	ArrayBuffer <#dfn-ArrayBuffer>
generateKey 	AesKeyGenParams <#dfn-AesKeyGenParams> 	CryptoKey <#dfn-
CryptoKey>
importKey 	None 	CryptoKey <#dfn-CryptoKey>
exportKey 	None 	object
get key length 	AesDerivedKeyParams <#dfn-AesDerivedKeyParams> 	Integer


        27.3. AesGcmParams dictionary ¶ <#aes-gcm-params>

IDL

|
dictionary AesGcmParams : Algorithm <#dfn-Algorithm> {
  // The initialization vector to use. May be up to 2^64-1 bytes long.
  required BufferSource iv;
  // The additional authentication data to include.
  BufferSource additionalData;
  // The desired length of the authentication tag. May be 0 - 128.
  [EnforceRange] octet tagLength;
};
          |


        27.4. Operations ¶ <#aes-gcm-operations>

Encrypt

     1.

        If plaintext has a length greater than 2^39 - 256 bytes, then
        throw <#concept-throw> an |OperationError| <#dfn-OperationError>.

     2.

        If the iv <#dfn-AesGcmParams-iv> member of normalizedAlgorithm
        has a length greater than 2^64 - 1 bytes, then throw <#concept-
        throw> an |OperationError| <#dfn-OperationError>.

     3.

        If the additionalData <#dfn-AesGcmParams-additionalData> member
        of normalizedAlgorithm is present and has a length greater than
        2^64 - 1 bytes, then throw <#concept-throw> an |OperationError|
        <#dfn-OperationError>.

     4.

        If the tagLength <#dfn-AesGcmParams-tagLength> member of
        normalizedAlgorithm is not present:
            Let tagLength be 128.
        If the tagLength <#dfn-AesGcmParams-tagLength> member of
        normalizedAlgorithm is one of 32, 64, 96, 104, 112, 120 or 128:
            Let tagLength be equal to the tagLength <#dfn-AesGcmParams-
            tagLength> member of normalizedAlgorithm
        Otherwise:
            throw <#concept-throw> an |OperationError| <#dfn-
            OperationError>. 

     5.

        Let additionalData be the contents of <#concept-contents-of-
        arraybuffer> the additionalData <#dfn-AesGcmParams-
        additionalData> member of normalizedAlgorithm if present or the
        empty octet string otherwise.

     6.

        Let C and T be the outputs that result from performing the
        Authenticated Encryption Function described in Section 7.1 of
        [NIST SP800-38D <#SP800-38D>] using AES as the block cipher, the
        contents of <#concept-contents-of-arraybuffer> the iv <#dfn-
        AesGcmParams-iv> member of normalizedAlgorithm as the IV input
        parameter, the contents of additionalData <#concept-contents-of-
        arraybuffer> as the A input parameter, tagLength as the t pre-
        requisite and the contents of plaintext <#concept-contents-of-
        arraybuffer> as the input plaintext.

     7.

        Let ciphertext be equal to C | T, where '|' denotes concatenation.

     8.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing ciphertext.

Decrypt

     1.

        If the tagLength <#dfn-AesGcmParams-tagLength> member of
        normalizedAlgorithm is not present:
            Let tagLength be 128.
        If the tagLength <#dfn-AesGcmParams-tagLength> member of
        normalizedAlgorithm is one of 32, 64, 96, 104, 112, 120 or 128:
            Let tagLength be equal to the tagLength <#dfn-AesGcmParams-
            tagLength> member of normalizedAlgorithm
        Otherwise:
            throw <#concept-throw> an |OperationError| <#dfn-
            OperationError>. 

     2.

        If plaintext has a length less than tagLength bits, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        If the iv <#dfn-AesGcmParams-iv> member of normalizedAlgorithm
        has a length greater than 2^64 - 1 bytes, then throw <#concept-
        throw> an |OperationError| <#dfn-OperationError>.

     4.

        If the additionalData <#dfn-AesGcmParams-additionalData> member
        of normalizedAlgorithm is present and has a length greater than
        2^64 - 1 bytes, then throw <#concept-throw> an |OperationError|
        <#dfn-OperationError>.

     5.

        Let tag be the last tagLength bits of ciphertext.

     6.

        Let actualCiphertext be the result of removing the last
        tagLength bits from ciphertext.

     7.

        Let additionalData be the contents <#concept-contents-of-
        arraybuffer> of the additionalData <#dfn-AesGcmParams-
        additionalData> member of normalizedAlgorithm if present or the
        empty octet string otherwise.

     8.

        Perform the Authenticated Decryption Function described in
        Section 7.2 of [NIST SP800-38D <#SP800-38D>] using AES as the
        block cipher, the contents of <#concept-contents-of-arraybuffer>
        the iv <#dfn-AesGcmParams-iv> member of normalizedAlgorithm as
        the IV input parameter, the contents of additionalData
        <#concept-contents-of-arraybuffer> as the A input parameter,
        tagLength as the t pre-requisite, the contents of
        actualCiphertext <#concept-contents-of-arraybuffer> as the input
        ciphertext, C and the contents of tag <#concept-contents-of-
        arraybuffer> as the authentication tag, T.

        If the result of the algorithm is the indication of
        inauthenticity, "FAIL":
            throw <#concept-throw> an |OperationError| <#dfn-
            OperationError> 
        Otherwise:
            Let plaintext be the output P of the Authenticated
            Decryption Function.

     9.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing plaintext.

Generate Key

     1.

        If usages contains any entry which is not one of |"encrypt"|,
        |"decrypt"|, |"wrapKey"| or |"unwrapKey"|, then throw <#concept-
        throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        If the length <#dfn-AesKeyGenParams-length> member of
        normalizedAlgorithm is not equal to one of 128, 192 or 256, then
        throw <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        Generate an AES key of length equal to the length <#dfn-
        AesKeyGenParams-length> member of normalizedAlgorithm.

     4.

        If the key generation step fails, then throw <#concept-throw> an
        |OperationError| <#dfn-OperationError>.

     5.

        Let key be a new CryptoKey <#dfn-CryptoKey> object representing
        the generated AES key.

     6.

        Let algorithm be a new AesKeyAlgorithm <#dfn-AesKeyAlgorithm>.

     7.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"AES-GCM"|.

     8.

        Set the length <#dfn-AesKeyAlgorithm-length> attribute of
        algorithm to equal the length <#dfn-AesKeyGenParams-length>
        member of normalizedAlgorithm.

     9.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

    10.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of key to be extractable.

    11.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        key to be usages.

    12.

        Return key.

Import Key

     1.

        If usages contains an entry which is not one of |"encrypt"|,
        |"decrypt"|, |"wrapKey"| or |"unwrapKey"|, then throw <#concept-
        throw> a |SyntaxError| <#dfn-SyntaxError>.

     2.

        If format is |"raw"|:
             1.

                Let data be the octet string <#dfn-octet-string>
                contained in keyData.

             2.

                If the length in bits of data is not 128, 192 or 256
                then throw <#concept-throw> a |DataError| <#dfn-DataError>.

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"kty"| field of jwk is not |"oct"|, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             3.

                If jwk does not meet the requirements of Section 6.4 of
                JSON Web Algorithms <#jwa>, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             4.

                Let data be the octet string <#dfn-octet-string>
                obtained by decoding the |"k"| field of jwk.

             5.

                If data has length 128 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A128GCM"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                If data has length 192 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A192GCM"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                If data has length 256 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A256GCM"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                Otherwise:
                    throw <#concept-throw> a |DataError| <#dfn-DataError>. 

             6.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not |"enc"|, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             7.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk> or does not contain all of the specified usages
                values, then throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             8.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>. 

     3.

        Let key be a new |CryptoKey <#dfn-CryptoKey>| object
        representing an AES key with value data.

     4.

        Let algorithm be a new AesKeyAlgorithm <#dfn-AesKeyAlgorithm>.

     5.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"AES-GCM"|.

     6.

        Set the length <#dfn-AesKeyAlgorithm-length> attribute of
        algorithm to the length, in bits, of data.

     7.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

     8.

        Return key.

Export Key

     1.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     2.

        If format is |"raw"|:
             1.

                Let data be the raw octets of the key represented by
                [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of
                key.

             2.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
             1.

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

             2.

                Set the |kty| attribute of jwk to the string |"oct"|.

             3.

                Set the |k| attribute of jwk to be a string containing
                the raw octets of the key represented by [[handle <#dfn-
                CryptoKey-slot-handle>]] internal slot of key, encoded
                according to Section 6.4 of JSON Web Algorithms <#jwa>.

             4.

                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 128:
                    Set the |alg| attribute of jwk to the string
                    |"A128GCM"|.
                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 192:
                    Set the |alg| attribute of jwk to the string
                    |"A192GCM"|.
                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 256:
                    Set the |alg| attribute of jwk to the string
                    |"A256GCM"|.

             5.

                Set the |key_ops| attribute of jwk to equal the usages
                <#dfn-CryptoKey-usages> attribute of key.

             6.

                Set the |ext| attribute of jwk to equal the
                [[extractable <#dfn-CryptoKey-slot-extractable>]]
                internal slot of key.

             7.

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     3.

        Return result.

Get key length

     1.

        If the length <#dfn-AesDerivedKeyParams-length> member of
        normalizedDerivedKeyAlgorithm is not 128, 192 or 256, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     2.

        Return the length <#dfn-AesDerivedKeyParams-length> member of
        normalizedDerivedKeyAlgorithm.


      28. AES-KW ¶ <#aes-kw>


        28.1. Description ¶ <#aes-kw-description>

This section is non-normative.

The |"AES-KW"| algorithm identifier is used to perform key wrapping
using AES, as described in [RFC3394 <#rfc3394>].


        28.2. Registration ¶ <#aes-kw-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"AES-KW"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
wrapKey 	None 	ArrayBuffer <#dfn-ArrayBuffer>
unwrapKey 	None 	ArrayBuffer <#dfn-ArrayBuffer>
generateKey 	AesKeyGenParams <#dfn-AesKeyGenParams> 	CryptoKey <#dfn-
CryptoKey>
importKey 	None 	CryptoKey <#dfn-CryptoKey>
exportKey 	None 	object
get key length 	AesDerivedKeyParams <#dfn-AesDerivedKeyParams> 	Integer


        28.3. Operations ¶ <#aes-kw-operations>

Wrap Key

     1.

        If plaintext is not a multiple of 64 bits in length, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     2.

        Let ciphertext be the result of performing the Key Wrap
        operation described in Section 2.2.1 of [RFC3394 <#rfc3394>]
        with plaintext as the plaintext to be wrapped and using the
        default Initial Value defined in Section 2.2.3.1 of the same
        document.

     3.

        Return ciphertext.

Unwrap Key

     1.

        Let plaintext be the result of performing the Key Unwrap
        operation described in Section 2.2.2 of [RFC3394 <#rfc3394>]
        with ciphertext as the input ciphertext and using the default
        Initial Value defined in Section 2.2.3.1 of the same document.

     2.

        If the Key Unwrap operation returns an error, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        Return plaintext.

Generate Key

     1.

        If usages contains any entry which is not one of |"wrapKey"| or
        |"unwrapKey"|, then throw <#concept-throw> a |SyntaxError|
        <#dfn-SyntaxError>.

     2.

        If the length <#dfn-AesKeyGenParams-length> property of
        normalizedAlgorithm is not equal to one of 128, 192 or 256, then
        throw <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        If the key generation step fails, then throw <#concept-throw> an
        |OperationError| <#dfn-OperationError>.

     4.

        Let key be a new CryptoKey <#dfn-CryptoKey> object representing
        the generated AES key.

     5.

        Let algorithm be a new AesKeyAlgorithm <#dfn-AesKeyAlgorithm>.

     6.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"AES-KW"|.

     7.

        Set the length <#dfn-AesKeyAlgorithm-length> attribute of
        algorithm to equal the length <#dfn-AesKeyGenParams-length>
        property of normalizedAlgorithm.

     8.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

     9.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of key to be extractable.

    10.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        key to be usages.

    11.

        Return key.

Import Key

     1.

        If usages contains an entry which is not one of |"wrapKey"| or
        |"unwrapKey"|, then throw <#concept-throw> a |SyntaxError|
        <#dfn-SyntaxError>.

     2.

        If format is |"raw"|:
             1.

                Let data be the octet string <#dfn-octet-string>
                contained in keyData.

             2.

                If the length in bits of data is not 128, 192 or 256
                then throw <#concept-throw> a |DataError| <#dfn-DataError>.

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"kty"| field of jwk is not |"oct"|, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             3.

                If jwk does not meet the requirements of Section 6.4 of
                JSON Web Algorithms <#jwa>, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             4.

                Let data be the octet string <#dfn-octet-string>
                obtained by decoding the |"k"| field of jwk.

             5.

                If data has length 128 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A128KW"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                If data has length 192 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A192KW"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                If data has length 256 bits:
                    If the |"alg"| field of jwk is present, and is not
                    |"A256KW"|, then throw <#concept-throw> a |
                    DataError| <#dfn-DataError>.
                Otherwise:
                    throw <#concept-throw> a |DataError| <#dfn-DataError>. 

             6.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not |"enc"|, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             7.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk> or does not contain all of the specified usages
                values, then throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             8.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>. 

     3.

        Let key be a new CryptoKey <#dfn-CryptoKey> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing an AES key with value data.

     4.

        Let algorithm be a new AesKeyAlgorithm <#dfn-AesKeyAlgorithm>.

     5.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"AES-KW"|.

     6.

        Set the length <#dfn-AesKeyAlgorithm-length> attribute of
        algorithm to the length, in bits, of data.

     7.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

     8.

        Return key.

Export Key

     1.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     2.

        If format is |"raw"|:
             1.

                Let data be the raw octets of the key represented by
                [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of
                key.

             2.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
             1.

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

             2.

                Set the |kty| attribute of jwk to the string |"oct"|.

             3.

                Set the |k| attribute of jwk to be a string containing
                the raw octets of the key represented by [[handle <#dfn-
                CryptoKey-slot-handle>]] internal slot of key, encoded
                according to Section 6.4 of JSON Web Algorithms <#jwa>.

             4.

                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 128:
                    Set the |alg| attribute of jwk to the string |"A128KW"|.
                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 192:
                    Set the |alg| attribute of jwk to the string |"A192KW"|.
                If the length <#dfn-AesKeyAlgorithm-length> attribute of
                key is 256:
                    Set the |alg| attribute of jwk to the string |"A256KW"|.

             5.

                Set the |key_ops| attribute of jwk to equal the usages
                <#dfn-CryptoKey-usages> attribute of key.

             6.

                Set the |ext| attribute of jwk to equal the
                [[extractable <#dfn-CryptoKey-slot-extractable>]]
                internal slot of key.

             7.

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     3.

        Return result.

Get key length

     1.

        If the length <#dfn-AesDerivedKeyParams-length> member of
        normalizedDerivedKeyAlgorithm is not 128, 192 or 256, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     2.

        Return the length <#dfn-AesDerivedKeyParams-length> member of
        normalizedDerivedKeyAlgorithm.


      29. HMAC ¶ <#hmac>


        29.1. Description ¶ <#hmac-description>

This section is non-normative.

The |HMAC| algorithm calculates and verifies hash-based message
authentication codes according to [FIPS PUB 198-1 <#fips-pub-198-1>]
using the SHA hash functions defined in this specification.

Other specifications <#dfn-applicable-specification> may specify the use
of additional hash algorithms with HMAC. Such specifications must define
the digest operation for the additional hash algorithms and key import
steps and key export steps for HMAC.


        29.2. Registration ¶ <#hmac-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"HMAC"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
sign 	None 	ArrayBuffer <#dfn-ArrayBuffer>
verify 	None 	boolean
generateKey 	HmacKeyGenParams <#dfn-HmacKeyGenParams> 	CryptoKey <#dfn-
CryptoKey>
importKey 	HmacImportParams <#dfn-HmacImportParams> 	CryptoKey <#dfn-
CryptoKey>
exportKey 	None 	object
get key length 	HmacImportParams <#dfn-HmacImportParams> 	Integer


        29.3. HmacImportParams dictionary ¶ <#hmac-importparams>

IDL

|
dictionary HmacImportParams : Algorithm <#dfn-Algorithm> {
  // The inner hash function to use.
  required HashAlgorithmIdentifier <#dfn-HashAlgorithmIdentifier> hash;
  // The length (in bits) of the key.
  [EnforceRange] unsigned long length;
};
          |


        29.4. HmacKeyAlgorithm dictionary ¶ <#HmacKeyAlgorithm-dictionary>

IDL

|
dictionary HmacKeyAlgorithm : KeyAlgorithm <#dfn-KeyAlgorithm> {
  // The inner hash function to use.
  required KeyAlgorithm hash;
  // The length (in bits) of the key.
  required unsigned long length;
};
          |


        29.5. HmacKeyGenParams dictionary ¶ <#hmac-keygen-params>

IDL

|
dictionary HmacKeyGenParams : Algorithm <#dfn-Algorithm> {
  // The inner hash function to use.
  required HashAlgorithmIdentifier <#dfn-HashAlgorithmIdentifier> hash;
  // The length (in bits) of the key to generate. If unspecified, the
  // recommended length will be used, which is the size of the associated hash function's block
  // size.
  [EnforceRange] unsigned long length;
};
          |


        29.6. Operations ¶ <#hmac-operations>

Sign

     1.

        Let mac be the result of performing the MAC Generation operation
        described in Section 4 of [FIPS PUB 198-1 <#fips-pub-198-1>]
        using the key represented by [[handle <#dfn-CryptoKey-slot-
        handle>]] internal slot of key, the hash function identified by
        the hash <#dfn-HmacKeyAlgorithm-hash> attribute of the
        [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of
        key and message as the input data text.

     2.

        Return a new ArrayBuffer <#dfn-ArrayBuffer> object, associated
        with the relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and containing the bytes of mac.

Verify

     1.

        Let mac be the result of performing the MAC Generation operation
        described in Section 4 of [FIPS PUB 198-1 <#fips-pub-198-1>]
        using the key represented by [[handle <#dfn-CryptoKey-slot-
        handle>]] internal slot of key, the hash function identified by
        the hash <#dfn-HmacKeyAlgorithm-hash> attribute of the
        [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal slot of
        key and message as the input data text.

     2.

        Return true if mac is equal to signature and false otherwise.

Generate Key

     1.

        If usages contains any entry which is not |"sign"| or
        |"verify"|, then throw <#concept-throw> a |SyntaxError| <#dfn-
        SyntaxError>.

     2.

        If the length <#dfn-HmacKeyGenParams-length> member of
        normalizedAlgorithm is not present:
            Let length be the block size in bits of the hash function
            identified by the hash <#dfn-HmacKeyGenParams-hash> member
            of normalizedAlgorithm. 
        Otherwise, if the length <#dfn-HmacKeyGenParams-length> member
        of normalizedAlgorithm is non-zero:
            Let length be equal to the length <#dfn-HmacKeyGenParams-
            length> member of normalizedAlgorithm. 
        Otherwise:
            throw <#concept-throw> an |OperationError| <#dfn-
            OperationError>. 

     3.

        Generate a key of length length bits.

     4.

        If the key generation step fails, then throw <#concept-throw> an
        |OperationError| <#dfn-OperationError>.

     5.

        Let key be a new CryptoKey <#dfn-CryptoKey> object representing
        the generated key.

     6.

        Let algorithm be a new HmacKeyAlgorithm <#dfn-HmacKeyAlgorithm>.

     7.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"HMAC"|.

     8.

        Let hash be a new KeyAlgorithm <#dfn-KeyAlgorithm>.

     9.

        Set the name <#dfn-KeyAlgorithm-name> attribute of hash to equal
        the name <#dfn-Algorithm-name> member of the hash <#dfn-
        HmacKeyGenParams-hash> member of normalizedAlgorithm.

    10.

        Set the hash <#dfn-HmacKeyAlgorithm-hash> attribute of algorithm
        to hash.

    11.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

    12.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of key to be extractable.

    13.

        Set the [[usages <#dfn-CryptoKey-slot-usages>]] internal slot of
        key to be usages.

    14.

        Return key.

Import Key

     1.

        Let keyData be the key data to be imported.

     2.

        If usages contains an entry which is not |"sign"| or |"verify"|,
        then throw <#concept-throw> a |SyntaxError| <#dfn-SyntaxError>.

     3.

        Let hash be a new KeyAlgorithm <#dfn-KeyAlgorithm>.

     4.

        If format is |"raw"|:
             1.

                Let data be the octet string <#dfn-octet-string>
                contained in keyData.

             2.

                Set hash to equal the hash <#dfn-HmacImportParams-hash>
                member of normalizedAlgorithm.

        If format is |"jwk"|:
             1.

                If keyData is a JsonWebKey <#dfn-JsonWebKey> dictionary:

                    Let jwk equal keyData.

                Otherwise:

                    Throw <#concept-throw> a |DataError| <#dfn-DataError>.

             2.

                If the |"kty"| field of jwk is not |"oct"|, then throw
                <#concept-throw> a |DataError| <#dfn-DataError>.

             3.

                If jwk does not meet the requirements of Section 6.4 of
                JSON Web Algorithms <#jwa>, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             4.

                Let data be the octet string <#dfn-octet-string>
                obtained by decoding the |"k"| field of jwk.

             5.

                Set the hash to equal the hash <#dfn-HmacImportParams-
                hash> member of normalizedAlgorithm.

             6.

                If the name <#dfn-KeyAlgorithm-name> attribute of hash
                is |"SHA-1"|:
                    If the |"alg"| field of jwk is present and is not
                    |"HS1"|, then throw <#concept-throw> a |DataError|
                    <#dfn-DataError>. 
                If If the name <#dfn-KeyAlgorithm-name> attribute of
                hash is |"SHA-256"|:
                    If the |"alg"| field of jwk is present and is not
                    |"HS256"|, then throw <#concept-throw> a |DataError|
                    <#dfn-DataError>. 
                If If the name <#dfn-KeyAlgorithm-name> attribute of
                hash is |"SHA-384"|:
                    If the |"alg"| field of jwk is present and is not
                    |"HS384"|, then throw <#concept-throw> a |DataError|
                    <#dfn-DataError>. 
                If If the name <#dfn-KeyAlgorithm-name> attribute of
                hash is |"SHA-512"|:
                    If the |"alg"| field of jwk is present and is not
                    |"HS512"|, then throw <#concept-throw> a |DataError|
                    <#dfn-DataError>. 
                Otherwise, if the name <#dfn-KeyAlgorithm-name>
                attribute of hash is defined in another applicable
                specification <#dfn-applicable-specification>:
                    Perform any key import steps <#dfn-hmac-extended-
                    import-steps> defined by other applicable
                    specifications <#dfn-applicable-specification>,
                    passing format, jwk and hash and obtaining hash. 

             7.

                If usages is non-empty and the |"use"| field of jwk is
                present and is not |"sign"|, then throw <#concept-throw>
                a |DataError| <#dfn-DataError>.

             8.

                If the |"key_ops"| field of jwk is present, and is
                invalid according to the requirements of JSON Web Key
                <#jwk> or does not contain all of the specified usages
                values, then throw <#concept-throw> a |DataError| <#dfn-
                DataError>.

             9.

                If the |"ext"| field of jwk is present and has the value
                false and extractable is true, then throw <#concept-
                throw> a |DataError| <#dfn-DataError>.

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>. 

     5.

        Let length be equivalent to the length, in octets, of data,
        multiplied by 8.

     6.

        If length is zero then throw <#concept-throw> a |DataError|
        <#dfn-DataError>.

     7.

        If the length <#dfn-HmacImportParams-length> member of
        normalizedAlgorithm is present:

            If the length <#dfn-HmacImportParams-length> member of
            normalizedAlgorithm is greater than length:
                throw <#concept-throw> a |DataError| <#dfn-DataError>. 
            If the length <#dfn-HmacImportParams-length> member of
            normalizedAlgorithm, is less than or equal to length minus
            eight:
                throw <#concept-throw> a |DataError| <#dfn-DataError>. 
            Otherwise:
                Set length equal to the length <#dfn-HmacImportParams-
                length> member of normalizedAlgorithm. 

     8.

        Let key be a new |CryptoKey <#dfn-CryptoKey>| object
        representing an HMAC key with the first length bits of data.

     9.

        Let algorithm be a new HmacKeyAlgorithm <#dfn-HmacKeyAlgorithm>.

    10.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"HMAC"|.

    11.

        Set the length <#dfn-HmacKeyAlgorithm-length> attribute of
        algorithm to length.

    12.

        Set the hash <#dfn-HmacKeyAlgorithm-hash> attribute of algorithm
        to hash.

    13.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

    14.

        Return key.

Export Key

     1.

        If the underlying cryptographic key material represented by the
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key
        cannot be accessed, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     2.

        Let bits be the raw bits of the key represented by [[handle
        <#dfn-CryptoKey-slot-handle>]] internal slot of key.

     3.

        Let data be an octet string containing <#dfn-octet-string-
        containing> bits.

     4.

        If format is |"raw"|:
             1.

                Let result be a new ArrayBuffer <#dfn-ArrayBuffer>
                associated with the relevant global object <https://
                www.w3.org/TR/html51/webappapis.html#relevant-global-
                object> of |this| [HTML <#HTML>], and containing data.

        If format is |"jwk"|:
             1.

                Let jwk be a new JsonWebKey <#dfn-JsonWebKey> dictionary.

             2.

                Set the |kty| attribute of jwk to the string |"oct"|.

             3.

                Set the |k| attribute of jwk to be a string containing
                data, encoded according to Section 6.4 of JSON Web
                Algorithms <#jwa>.

             4.

                Let algorithm be the [[algorithm <#dfn-CryptoKey-slot-
                algorithm>]] internal slot of key.

             5.

                Let hash be the hash <#dfn-HmacKeyAlgorithm-hash>
                attribute of algorithm.

             6.

                If the name <#dfn-KeyAlgorithm-name> attribute of hash
                is |"SHA-1"|:
                    Set the |alg| attribute of jwk to the string |"HS1"|.
                If the name <#dfn-KeyAlgorithm-name> attribute of hash
                is |"SHA-256"|:
                    Set the |alg| attribute of jwk to the string |"HS256"|.
                If the name <#dfn-KeyAlgorithm-name> attribute of hash
                is |"SHA-384"|:
                    Set the |alg| attribute of jwk to the string |"HS384"|.
                If the name <#dfn-KeyAlgorithm-name> attribute of hash
                is |"SHA-512"|:
                    Set the |alg| attribute of jwk to the string |"HS512"|.
                Otherwise, the name <#dfn-KeyAlgorithm-name> attribute
                of hash is defined in another applicable specification
                <#dfn-applicable-specification>:
                     1.

                        Perform any key export steps <#dfn-hmac-
                        extended-export-steps> defined by other
                        applicable specifications <#dfn-applicable-
                        specification>, passing format and key and
                        obtaining alg.

                     2.

                        Set the |alg| attribute of jwk to alg.

             7.

                Set the |key_ops| attribute of jwk to equal the usages
                <#dfn-CryptoKey-usages> attribute of key.

             8.

                Set the |ext| attribute of jwk to equal the
                [[extractable <#dfn-CryptoKey-slot-extractable>]]
                internal slot of key.

             9.

                Let result be the result of converting jwk to an
                ECMAScript Object, as defined by [WebIDL <#WebIDL>].

        Otherwise:

            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>.

     5.

        Return result.

Get key length

     1.

        If the length <#dfn-HmacImportParams-length> member of
        normalizedDerivedKeyAlgorithm is not present:

            Let length be the block size in bytes of the hash function
            identified by the hash <#dfn-HmacImportParams-hash> member
            of normalizedDerivedKeyAlgorithm.

        Otherwise, if the length <#dfn-HmacImportParams-length> member
        of normalizedDerivedKeyAlgorithm is non-zero:
            Let length be equal to the length <#dfn-HmacImportParams-
            length> member of normalizedDerivedKeyAlgorithm. 
        Otherwise:
            throw <#concept-throw> a |TypeError| <#dfn-TypeError>. 

     2.

        Return length.


      30. SHA ¶ <#sha>


        30.1. Description ¶ <#sha-description>

This section is non-normative.

This describes the SHA-1 and SHA-2 families, as specified by [FIPS PUB
180-4 <#FIPS180-4>].


        30.2. Registration ¶ <#sha-registration>

The following algorithms are added as recognized algorithm names
<#recognized-algorithm-name>:

|"SHA-1"|
    The SHA-1 algorithm as specified in Section 6.1
|"SHA-256"|
    The SHA-256 algorithm as specified in Section 6.2
|"SHA-384"|
    The SHA-384 algorithm as specified in Section 6.5
|"SHA-512"|
    The SHA-512 algorithm as specified in Section 6.4

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
digest 	None 	ArrayBuffer <#dfn-ArrayBuffer>


        30.3. Operations ¶ <#sha-operations>

Digest

     1.

        If the name <#dfn-Algorithm-name> member of normalizedAlgorithm
        is a cases-sensitive string match for |"SHA-1"|:
            Let result be the result of performing the SHA-1 hash
            function defined in Section 6.1 of [FIPS PUB 180-4
            <#FIPS180-4>] using message as the input message, M. 
        If the name <#dfn-Algorithm-name> member of normalizedAlgorithm
        is a cases-sensitive string match for |"SHA-256"|:
            Let result be the result of performing the SHA-256 hash
            function defined in Section 6.2 of [FIPS PUB 180-4
            <#FIPS180-4>] using message as the input message, M. 
        If the name <#dfn-Algorithm-name> member of normalizedAlgorithm
        is a cases-sensitive string match for |"SHA-384"|:
            Let result be the result of performing the SHA-384 hash
            function defined in Section 6.5 of [FIPS PUB 180-4
            <#FIPS180-4>] using message as the input message, M. 
        If the name <#dfn-Algorithm-name> member of normalizedAlgorithm
        is a cases-sensitive string match for |"SHA-512"|:
            Let result be the result of performing the SHA-1 hash
            function defined in Section 6.4 of [FIPS PUB 180-4
            <#FIPS180-4>] using message as the input message, M. 

     2.

        If performing the operation results in an error, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     3.

        Return a new ArrayBuffer containing result.


      31. HKDF ¶ <#hkdf>


        31.1. Description ¶ <#hkdf-description>

This section is non-normative.

The |"HKDF"| algorithm identifier is used to perform key derivation
using the extraction-then-expansion approach described in [RFC 5869
<#RFC5869>] and using the SHA hash functions defined in this specification.

Other specifications <#dfn-applicable-specification> may specify the use
of additional hash algorithms with HKDF. Such specifications must define
the digest operation for the additional hash algorithms.


        31.2. Registration ¶ <#hkdf-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"HKDF"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
deriveBits 	HkdfParams <#dfn-HkdfParams> 	ArrayBuffer <#dfn-ArrayBuffer>
importKey 	None 	CryptoKey <#dfn-CryptoKey>
Get key length 	None 	null


        31.3. HkdfParams dictionary ¶ <#hkdf-params>

IDL

|
dictionary HkdfParams : Algorithm <#dfn-Algorithm> {
  // The algorithm to use with HMAC (e.g.: SHA-256 <#alg-sha-256>)
  required HashAlgorithmIdentifier <#dfn-HashAlgorithmIdentifier> hash;
  // A bit string that corresponds to the salt used in the extract step.
  required BufferSource salt;
  // A bit string that corresponds to the context and application specific context for the derived keying material.
  required BufferSource info;
};
          |


        31.4. Operations ¶ <#hkdf2-operations>

Derive Bits

     1.

        If length is null, then throw <#concept-throw> an |
        OperationError| <#dfn-OperationError>.

     2.

        Let extractKey be a key equal to n zero bits where n is the size
        of the output of the hash function described by the hash <#dfn-
        HkdfParams-hash> member of normalizedAlgorithm.

     3.

        Let keyDerivationKey be the secret represented by [[handle
        <#dfn-CryptoKey-slot-handle>]] internal slot of key as the message.

     4.

        Let result be the result of performing the HKDF extract and then
        the HKDF expand step described in Section 2 of [RFC 5869
        <#RFC5869>] using:

          *

            the hash <#dfn-HkdfParams-hash> member of
            normalizedAlgorithm as Hash,

          *

            keyDerivationKey as the input keying material, IKM,

          *

            the contents of <#concept-contents-of-arraybuffer> the salt
            <#dfn-HkdfParams-salt> member of normalizedAlgorithm as salt,

          *

            the contents of <#concept-contents-of-arraybuffer> the info
            <#dfn-HkdfParams-info> member of normalizedAlgorithm as info,

          *

            length as the value of L,

     5.

        If the key derivation operation fails, then throw <#concept-
        throw> an |OperationError| <#dfn-OperationError>.

     6.

        Return result.

Import key

     1.

        Let keyData be the key data to be imported.

     2.

        If format is |"raw"|:
             1.

                If usages contains a value that is not |"deriveKey"| or
                |"deriveBits"|, then throw <#concept-throw> a |
                SyntaxError| <#dfn-SyntaxError>.

             2.

                If extractable is not |false|, then throw <#concept-
                throw> a |SyntaxError| <#dfn-SyntaxError>.

             3.

                Let key be a new CryptoKey <#dfn-CryptoKey> associated
                with the relevant global object <https://www.w3.org/TR/
                html51/webappapis.html#relevant-global-object> of |this|
                [HTML <#HTML>], and representing the key data provided
                in keyData.

             4.

                Set the [[type <#dfn-CryptoKey-slot-type>]] internal
                slot of key to |"secret"|.

             5.

                Set the [[extractable <#dfn-CryptoKey-slot-
                extractable>]] internal slot of key to |false|.

             6.

                Let algorithm be a new KeyAlgorithm <#dfn-KeyAlgorithm>
                object.

             7.

                Set the name <#dfn-KeyAlgorithm-name> attribute of
                algorithm to |"HKDF"|.

             8.

                Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]]
                internal slot of key to algorithm.

             9.

                Return key.

        Otherwise:
            throw <#concept-throw> a |NotSupportedError| <#dfn-
            NotSupportedError>. 

Get key length

     1.

        Return null.


      32. PBKDF2 ¶ <#pbkdf2>


        32.1. Description ¶ <#pbkdf2-description>

This section is non-normative.

The |"PBKDF2"| algorithm identifier is used to perform key derivation
using the PKCS#5 password-based key derivation function version 2.0, as
defined in [RFC2898 <#RFC2898>] using HMAC as the pseudo-random
function, using the SHA hash functions defined in this specification.

Other specifications <#dfn-applicable-specification> may specify the use
of additional hash algorithms with PBKDF2. Such specifications must
define the digest operation for the additional hash algorithms.


        32.2. Registration ¶ <#pbkdf2-registration>

The recognized algorithm name <#recognized-algorithm-name> for this
algorithm is |"PBKDF2"|.

Operation <#supported-operations> 	Parameters <#algorithm-specific-
params> 	Result <#algorithm-result>
deriveBits 	Pbkdf2Params <#dfn-Pbkdf2Params> 	ArrayBuffer <#dfn-
ArrayBuffer>
importKey 	None 	CryptoKey <#dfn-CryptoKey>
Get key length 	None 	Integer or null


        32.3. Pbkdf2Params dictionary ¶ <#pbkdf2-params>

IDL

|
dictionary Pbkdf2Params : Algorithm <#dfn-Algorithm> {
  required BufferSource salt;
  [EnforceRange] required unsigned long iterations;
  required HashAlgorithmIdentifier <#dfn-HashAlgorithmIdentifier> hash;
};
          |


        32.4. Operations ¶ <#pbkdf2-operations>

Derive bits

     1.

        If length is null or is not a multiple of 8, then throw
        <#concept-throw> an |OperationError| <#dfn-OperationError>.

     2.

        Let prf be the MAC Generation function described in Section 4 of
        [FIPS PUB 198-1 <#fips-pub-198-1>] using the hash function
        described by the hash <#dfn-Pbkdf2Params-hash> member of
        normalizedAlgorithm.

     3.

        Let result be the result of performing the PBKDF2 operation
        defined in Section 5.2 of [RFC2898 <#RFC2898>] using prf as the
        pseudo-random function, PRF, the password represented by
        [[handle <#dfn-CryptoKey-slot-handle>]] internal slot of key as
        the password, P, the contents of <#concept-contents-of-
        arraybuffer> the salt <#dfn-Pbkdf2Params-salt> attribute of
        normalizedAlgorithm as the salt, S, the value of the iterations
        <#dfn-Pbkdf2Params-iterations> attribute of normalizedAlgorithm
        as the iteration count, c, and length divided by 8 as the
        intended key length, dkLen.

     4.

        If the key derivation operation fails, then throw <#concept-
        throw> an |OperationError| <#dfn-OperationError>.

     5.

        Return result

Import key

     1.

        If format is not |"raw"|, throw <#concept-throw> a |
        NotSupportedError| <#dfn-NotSupportedError>

     2.

        If usages contains a value that is not |"deriveKey"| or
        |"deriveBits"|, then throw <#concept-throw> a |SyntaxError|
        <#dfn-SyntaxError>.

     3.

        If extractable is not |false|, then throw <#concept-throw> a |
        SyntaxError| <#dfn-SyntaxError>.

     4.

        Let key be a new CryptoKey <#dfn-CryptoKey> associated with the
        relevant global object <https://www.w3.org/TR/html51/
        webappapis.html#relevant-global-object> of |this| [HTML
        <#HTML>], and representing keyData.

     5.

        Set the [[type <#dfn-CryptoKey-slot-type>]] internal slot of key
        to |"secret"|.

     6.

        Set the [[extractable <#dfn-CryptoKey-slot-extractable>]]
        internal slot of key to |false|.

     7.

        Let algorithm be a new KeyAlgorithm <#dfn-KeyAlgorithm> object.

     8.

        Set the name <#dfn-KeyAlgorithm-name> attribute of algorithm to
        |"PBKDF2"|.

     9.

        Set the [[algorithm <#dfn-CryptoKey-slot-algorithm>]] internal
        slot of key to algorithm.

    10.

        Return key.

Get key length

     1.

        Return null.


    33. JavaScript Example Code ¶ <#examples-section>


      33.1. Generate a signing key pair, sign some data ¶ <#examples-
      signing>

ECMAScript

|
var encoder = new TextEncoder('utf-8');

// Algorithm Object
var algorithmKeyGen = {
  name: "RSASSA-PKCS1-v1_5",
  // RsaHashedKeyGenParams <#dfn-RsaHashedKeyGenParams>
  modulusLength: 2048,
  publicExponent: new Uint8Array([0x01, 0x00, 0x01]),  // Equivalent to 65537
  hash: {
    name: "SHA-256"
  }
};

var algorithmSign = {
  name: "RSASSA-PKCS1-v1_5"
};

window.crypto.subtle.generateKey(algorithmKeyGen, false, ["sign"]).then(
  function(key) {
    var dataPart1 = encoder.encode("hello,");
    var dataPart2 = encoder.encode(" world!");

    return window.crypto.subtle.sign(algorithmSign, key.privateKey, [dataPart1, dataPart2]);
  },
  console.error.bind(console, "Unable to generate a key")
).then(
  console.log.bind(console, "The signature is: "),
  console.error.bind(console, "Unable to sign")
);
        |


      33.2. Symmetric Encryption ¶ <#examples-symmetric-encryption>

ECMAScript

|
var encoder = new TextEncoder('utf-8');
var clearDataArrayBufferView = encoder.encode("Plain Text Data");

var aesAlgorithmKeyGen = {
  name: "AES-CBC",
  // AesKeyGenParams <#dfn-AesKeyGenParams>
  length: 128
};

var aesAlgorithmEncrypt = {
  name: "AES-CBC",
  // AesCbcParams <#dfn-AesCbcParams>
  iv: window.crypto.getRandomValues(new Uint8Array(16))
};

// Create a key generator to produce a one-time-use AES key to encrypt some data
window.crypto.subtle.generateKey(aesAlgorithmKeyGen, false, ["encrypt"]).then(
  function(aesKey) {
    return window.crypto.subtle.encrypt(aesAlgorithmEncrypt, aesKey, [ clearDataArrayBufferView ]);
  }
).then(console.log.bind(console, "The ciphertext is: "),
       console.error.bind(console, "Unable to encrypt"));
        |


    34. IANA Considerations ¶ <#iana-section>


      34.1. JSON Web Signature and Encryption Algorithms Registration ¶
      <#iana-section-jws-jwa>

This section registers the following algorithm identifiers in the IANA
JSON Web Signature and Encryption Algorithms Registry for use with JSON
Web Key. Note that the 'Implementation Requirements' field in the
template refers to use with JSON Web Signature and JSON Web Encryption
specifically, in which case use of unauthenticated encryption is
prohibited.

  * Algorithm Name: "RS1"
  * Algorithm Description: RSASSA-PKCS1-v1_5 with SHA-1
  * Algorithm Usage Location(s): "JWK"
  * JOSE Implementation Requirements: Prohibited
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "RSA-OAEP-384"
  * Algorithm Description: RSA-OAEP using SHA-384 and MGF1 with SHA-384
  * Algorithm Usage Location(s): "alg"
  * JOSE Implementation Requirements: Optional+
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "RSA-OAEP-512"
  * Algorithm Description: RSA-OAEP using SHA-512 and MGF1 with SHA-512
  * Algorithm Usage Location(s): "alg"
  * JOSE Implementation Requirements: Optional+
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "A128CBC"
  * Algorithm Description: AES CBC using 128 bit key
  * Algorithm Usage Location(s): "JWK"
  * JOSE Implementation Requirements: Prohibited
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "A192CBC"
  * Algorithm Description: AES CBC using 192 bit key
  * Algorithm Usage Location(s): "JWK"
  * JOSE Implementation Requirements: Prohibited
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "A256CBC"
  * Algorithm Description: AES CBC using 256 bit key
  * Algorithm Usage Location(s): "JWK"
  * JOSE Implementation Requirements: Prohibited
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "A128CTR"
  * Algorithm Description: AES CTR using 128 bit key
  * Algorithm Usage Location(s): "JWK"
  * JOSE Implementation Requirements: Prohibited
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "A192CTR"
  * Algorithm Description: AES CTR using 192 bit key
  * Algorithm Usage Location(s): "JWK"
  * JOSE Implementation Requirements: Prohibited
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "A256CTR"
  * Algorithm Description: AES CTR using 256 bit key
  * Algorithm Usage Location(s): "JWK"
  * JOSE Implementation Requirements: Prohibited
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]

  * Algorithm Name: "HS1"
  * Algorithm Description: HMAC using SHA-1
  * Algorithm Usage Location(s): "JWK"
  * JOSE Implementation Requirements: Prohibited
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]


      34.2. JSON Web Key Parameters Registration ¶ <#iana-section-jwk>

  * Parameter Name: "ext"
  * Parameter Description: Extractable
  * Used with "kty" Value(s): *
  * Parameter Information Class: Public
  * Change Controller: W3C Web Cryptography Working Group
  * Specification Document(s): [[ This Document ]]


    35. Acknowledgments ¶ <#acknowledgements-section>

Thanks are due especially to Ryan Sleevi, the original author and editor
of this document.

The editor would like to thank Adam Barth, Alex Russell, Ali Asad, Arun
Ranganathan, Brian Smith, Brian Warner, Channy Yun, Charles Engelke,
Eric Roman, Glenn Adams, Jim Schaad, Kai Engert, Michael Hutchinson,
Michael B. Jones, Nick Van den Bleeken, Richard Barnes, Ryan Hurst, Tim
Taubert, Vijay Bharadwaj, Virginie Galindo, and Wan-Teh Chang for their
technical feedback and assistance.

Thanks to the W3C Web Cryptography WG, and to participants on the
public-webcrypto@w3.org mailing list.

The W3C would like to thank the Northrop Grumman Cybersecurity Research
Consortium <http://www.northropgrumman.com/Capabilities/
CybersecurityResearchConsortium/> for supporting W3C/MIT.

The |getRandomValues| <#dfn-Crypto-method-getRandomValues> method in the
|Crypto| interface was originally proposed by Adam Barth to the WHATWG
<https://wiki.whatwg.org/wiki/Crypto>.


    36. References ¶ <#references>


      36.1. Normative References ¶ <#normative-references>

DOM4
    W3C DOM4 <https://www.w3.org/TR/dom/>, A. Gregor, A. van Kesteren,
    Ms2ger, Alex Russell, Robin Berjon. 
ECMA262
    ECMAScript 5th Edition <http://www.ecma-international.org/
    publications/standards/Ecma-262.htm>, A. Wirfs-Brock, P. Lakshman et
    al. 
FIPS 180-4
    FIPS PUB 180-4: Secure Hash Standard <http://csrc.nist.gov/
    publications/fips/fips180-4/fips-180-4.pdf>, NIST. 
FIPS 198-1
    The Keyed-Hash Message Authentication Code (HMAC) <http://
    csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf> ,
    July 2008, NIST. 
HTML
    HTML5.1 <https://www.w3.org/TR/html51/>, W3C. 
ITU-T Recommendation X.690 (11/08)
    Information technology - ASN.1 encoding rules: Specification of
    Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and
    Distinguished Encoding Rules (DER) <http://www.itu.int/rec/T-REC-
    X.690-200811-I/en> , ITU-T. 
JSON Web Key
    JSON Web Key <https://tools.ietf.org/html/rfc7517>, M. Jones,
    Microsoft. 
JSON Web Algorithms
    JSON Web Algorithms <https://tools.ietf.org/html/rfc7518>, M. Jones,
    Microsoft. 
NIST SP 800-38A
    NIST Special Publication 800-38A: Recommendation for Block Cipher
    Modes of Operation, Methods and Techniques <http://csrc.nist.gov/
    publications/nistpubs/800-38a/sp800-38a.pdf>, December 2001, NIST. 
NIST SP 800-38B
    NIST Special Publication 800-38B: Recommendation for Block Cipher
    Modes of Operation: The CMAC Mode for Authentication <http://
    csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf>, May
    2005, NIST. 
NIST SP 800-38D
    NIST Special Publication 800-38D: Recommendation for Block Cipher
    Modes of Operation: Galois/Counter Mode (GCM) and GMAC <http://
    csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf>,
    November 2007, NIST. 
NIST SP 800-56A
    NIST Special Publication 800-56A: Recommendation for Pair-Wise Key
    Establishment Schemes Using Discrete Logarithm Cryptography
    (Revised) <http://csrc.nist.gov/publications/nistpubs/800-56A/
    SP800-56A_Revision1_Mar08-2007.pdf>, March 2007, NIST. 
NIST SP 800-56C
    NIST Special Publication 800-56C: Recommendation for Key Derivation
    through Extraction-then-Expansion <http://csrc.nist.gov/
    publications/nistpubs/800-56C/SP-800-56C.pdf>, November 2011, NIST. 
RFC 2119
    Key words for use in RFCs to Indicate Requirement Levels <http://
    www.ietf.org/rfc/rfc2119>, S. Bradner. IETF. 
RFC 2315
    PKCS #7: Cryptographic Message Syntax, Version 1.5 <http://
    tools.ietf.org/html/rfc2315>, B. Kaliski. RSA Laboratories. 
RFC 2898
    PKCS #5: Password-Based Cryptography Specification, Version 2.0
    <http://tools.ietf.org/html/RFC2898>, B. Kaliski. RSA Laboratories 
RFC 3279
    Algorithms and Identifiers for the Internet X.509 Public Key
    Infrastructure Certificate and Certificate Revocation List (CRL)
    Profile <http://www.ietf.org/rfc/rfc3279>, W. Polk, R. Housley, L.
    Bassham. IETF. 
RFC3394
    Advanced Encryption Standard (AES) Key Wrap Algorithm <http://
    www.ietf.org/rfc/rfc3394.txt>, J. Schaad, R. Housley, IETF. 
RFC 3447
    Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography
    Specifications Version 2.1 <http://www.ietf.org/rfc/rfc3447>, J.
    Jonsson, B. Kaliski. IETF. 
RFC 5208
    Public-Key Cryptography Standards (PKCS) #8: Private-Key Information
    Syntax Specification Version 1.2 <http://www.ietf.org/rfc/
    rfc5208.txt>, B. Kaliski. IETF. 
RFC 5280
    Internet X.509 Public Key Infrastructure Certificate and Certificate
    Revocation List (CRL) Profile <http://www.ietf.org/rfc/rfc5280.txt>,
    D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, W. Polk.
    IETF. 
RFC 5480
    Elliptic Curve Cryptography Subject Public Key Information <http://
    www.ietf.org/rfc/rfc5480.txt>, S. Turner, D. Brown, K. Yiu, R.
    Housley, T. Polk. IETF. 
RFC 5869
    HMAC-based Extract-and-Expand Key Derivation Function (HKDF)"
    <https://www.ietf.org/rfc/rfc5869.txt>, H. Krawczyk, P. Eronen. IETF. 
RFC 5915
    Elliptic Curve Private Key Structure <http://www.ietf.org/rfc/
    rfc5915.txt>, S. Turner, D. Brown. IETF. 
RFC6090
    Fundamental Elliptic Curve Cryptography Algorithms <http://
    www.ietf.org/rfc/rfc6090.txt>, D. McGrew, K. Igoe, M.Salter. IETF. 
SEC 1
    SEC 1: Elliptic Curve Cryptography <http://www.secg.org/sec1-
    v2.pdf>, Certicom Research 
Web IDL Level 1
    WebIDL Level 1 <https://www.w3.org/TR/WebIDL-1/>, Yves Lafon, W3C,
    Travis Leithead, Cameron McCormack; Boris Zbarsky. 
X9.62
    ANS X9.62–2005: Public Key Cryptography for the Financial Services
    Industry, The Elliptic Curve Digital Signature Algorithm (ECDSA), ANSI. 


      36.2. Informative References ¶ <#informative-references>

CDSA
    Common Security: CDSA and CSSM, Version 2 (with corrigenda) <http://
    www.opengroup.org/security/cdsa.htm>, the Open Group. 
CNG
    Cryptography API: Next Generation <http://msdn.microsoft.com/en-us/
    library/windows/desktop/aa376210(v=vs.85).aspx>, Microsoft Corporation. 
CryptoAPI
    Cryptography Reference <http://msdn.microsoft.com/en-us/library/
    aa380256.aspx>, Microsoft Corporation. 
DRAFT-TLS-OBC
    TLS Origin-Bound Certificates <http://tools.ietf.org/html/draft-
    balfanz-tls-obc-01>, D. Balfanz, D. Smetters, M. Upadhyay, A. Barth.
    IETF. 
FileAPI
    File API <https://www.w3.org/TR/FileAPI/>, A. Ranganathan, J.
    Sicking. W3C. 
Indexed Database API
    Indexed Database API <https://www.w3.org/TR/IndexedDB/>, N. Mehta,
    J. Sicking, E. Graff, A. Popescu, J. Orlow, J. Bell. W3C. 
PKCS11
    PKCS #11: Cryptographic Token Interface Standard <http://
    www.onefs.com/emc-plus/rsa-labs/standards-initiatives/pkcs-11-
    cryptographic-token-interface-standard.htm>, RSA Laboratories. 
RFC 4055
    Additional Algorithms and Identifiers for RSA Cryptography for use
    in the Internet X.509 Public Key Infrastructure Certificate and
    Certificate Revocation List (CRL) Profile <https://tools.ietf.org/
    html/rfc4055>, J. Schaad, B. Kaliski, R. Housley. IETF. 
RFC 5756
    Updates for RSAES-OAEP and RSASSA-PSS Algorithm Parameters <https://
    tools.ietf.org/html/rfc5756>, S. Turner, D. Brown, K. Yiu, R.
    Housley, T. Polk. IETF. 
RFC 5958
    Asymmetric Key Packages <https://tools.ietf.org/html/rfc5958>, S.
    Turner. IETF. 


    A. Mapping between JSON Web Key / JSON Web Algorithm

The following section is non-normative. Refer to algorithm-specific
sections for the normative requirements of importing and exporting JWK.


      A.1. Algorithm mappings

JSON Web Key 	AlgorithmIdentifier
ECMAScript

|
{ kty: "RSA",
  alg: "RS1" }
|

	
ECMAScript

|
{ name: "RSASSA-PKCS1-v1_5",
  hash: { name: "SHA-1" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "RS256" }
|

	
ECMAScript

|
{ name: "RSASSA-PKCS1-v1_5",
  hash: { name: "SHA-256" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "RS384" }
|

	
ECMAScript

|
{ name: "RSASSA-PKCS1-v1_5",
  hash: { name: "SHA-384" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "RS512" }
|

	
ECMAScript

|
{ name: "RSASSA-PKCS1-v1_5",
  hash: { name: "SHA-512" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "PS256" }
|

	
ECMAScript

|
{ name: "RSA-PSS",
  hash: { name: "SHA-256" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "PS384" }
|

	
ECMAScript

|
{ name: "RSA-PSS",
  hash: { name: "SHA-384" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "PS512" }
|

	
ECMAScript

|
{ name: "RSA-PSS",
  hash: { name: "SHA-512" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "RSA-OAEP" }
|

	
ECMAScript

|
{ name: "RSA-OAEP",
  hash: { name: "SHA-1" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "RSA-OAEP-256" }
|

	
ECMAScript

|
{ name: "RSA-OAEP",
  hash: { name: "SHA-256" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "RSA-OAEP-384" }
|

	
ECMAScript

|
{ name: "RSA-OAEP",
  hash: { name: "SHA-384" }
}
|

ECMAScript

|
{ kty: "RSA",
  alg: "RSA-OAEP-512" }
|

	
ECMAScript

|
{ name: "RSA-OAEP",
  hash: { name: "SHA-512" }
}
|

ECMAScript

|
{ kty: "EC",
  alg: "ES256" }
|

	
ECMAScript

|
{ name: "ECDSA",
  namedCurve: "P-256"
  hash: { name: "SHA-256" }
}
|

ECMAScript

|
{ kty: "EC",
  alg: "ES384" }
|

	
ECMAScript

|
{ name: "ECDSA",
  namedCurve: "P-384"
  hash: { name: "SHA-384" }
}
|

ECMAScript

|
{ kty: "EC",
  alg: "ES512" }
|

	
ECMAScript

|
{ name: "ECDSA",
  namedCurve: "P-521"
  hash: { name: "SHA-512" }
}
|

ECMAScript

|
{ kty: "oct",
  alg: "A128CTR" }
|

	
ECMAScript

|
{ name: "AES-CTR",
  length: 128 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A192CTR" }
|

	
ECMAScript

|
{ name: "AES-CTR",
  length: 192 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A256CTR" }
|

	
ECMAScript

|
{ name: "AES-CTR",
  length: 256 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A128CBC" }
|

	
ECMAScript

|
{ name: "AES-CBC",
  length: 128 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A192CBC" }
|

	
ECMAScript

|
{ name: "AES-CBC",
  length: 192 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A256CBC" }
|

	
ECMAScript

|
{ name: "AES-CBC",
  length: 256 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A128KW" }
|

	
ECMAScript

|
{ name: "AES-KW",
  length: 128 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A192KW" }
|

	
ECMAScript

|
{ name: "AES-KW",
  length: 192 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A256KW" }
|

	
ECMAScript

|
{ name: "AES-KW",
  length: 256 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A128GCM" }
|

	
ECMAScript

|
{ name: "AES-GCM",
  length: 128 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A192GCM" }
|

	
ECMAScript

|
{ name: "AES-GCM",
  length: 192 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A256GCM" }
|

	
ECMAScript

|
{ name: "AES-GCM",
  length: 256 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A128GCMKW" }
|

	
ECMAScript

|
{ name: "AES-GCM",
  length: 128 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A192GCMKW" }
|

	
ECMAScript

|
{ name: "AES-GCM",
  length: 192 }
|

ECMAScript

|
{ kty: "oct",
  alg: "A256GCMKW" }
|

	
ECMAScript

|
{ name: "AES-GCM",
  length: 256 }
|

ECMAScript

|
{ kty: "oct",
  alg: "HS1" }
|

	
ECMAScript

|
{ name: "HMAC",
  hash: { name: "SHA-1" }
}
|

ECMAScript

|
{ kty: "oct",
  alg: "HS256" }
|

	
ECMAScript

|
{ name: "HMAC",
  hash: { name: "SHA-256" }
}
|

ECMAScript

|
{ kty: "oct",
  alg: "HS384" }
|

	
ECMAScript

|
{ name: "HMAC",
  hash: { name: "SHA-384" }
}
|

ECMAScript

|
{ kty: "oct",
  alg: "HS512" }
|

	
ECMAScript

|
{ name: "HMAC",
  hash: "SHA-512" }
|


    B. Mapping between Algorithm and SubjectPublicKeyInfo

The following section is non-normative. Refer to algorithm-specific
sections for the normative requirements of importing and exporting SPKI.

Algorithm OID 	subjectPublicKey ASN.1 structure 	AlgorithmIdentifier 	
Reference
rsaEncryption (1.2.840.113549.1.1.1) 	RSAPublicKey 	|"RSASSA-PKCS1-
v1_5"|, |"RSA-PSS"|, or |"RSA-OAEP"| 	RFC 3279 <#RFC3279>, RFC 4055
<#RFC4055>, RFC 5756 <#RFC5756>
id-RSASSA-PSS (1.2.840.113549.1.1.10) 	RSAPublicKey 	|"RSA-PSS"| 	RFC
4055 <#RFC4055>, RFC 5756 <#RFC5756>
id-RSAES-OAEP (1.2.840.113549.1.1.7) 	RSAPublicKey 	|"RSA-OAEP"| 	RFC
4055 <#RFC4055>, RFC 5756 <#RFC5756>
id-ecPublicKey (1.2.840.10045.2.1) 	ECPoint 	|"ECDH"| or |"ECDSA"| 	RFC
5480 <#RFC5480>
id-ecDH (1.3.132.1.12) 	ECPoint 	|"ECDH"| 	RFC 5480 <#RFC5480>
id-dsa (1.2.840.10040.4.1) 	DSAPublicKey 	|"DSA"| 	RFC 3279 <#RFC3279>

Note

For "id-RSASSA-PSS" and "id-RSAES-OAEP", RFC 5756 <#RFC5756> recommends
implementations should not include parameters when PSS is used with a |
subjectPublicKeyInfo|, and MUST NOT include parameters when OAEP is
used. However, when OAEP is used as part of a key transport (as an |
AlgorithmIdentifier|), implementations MUST include the parameters.

The |"spki"| key format in this specification implies |
subjectPublicKeyInfo| and thus may not be appropriate when what is
needed is an |AlgorithmIdentifier| for transport.


    C. Mapping between Algorithm and PKCS#8 PrivateKeyInfo

The following section is non-normative. Refer to algorithm-specific
sections for the normative requirements of importing and exporting
PKCS#8 PrivateKeyInfo.

privateKeyAlgorithm 	privateKey format 	AlgorithmIdentifier 	Reference
rsaEncryption (1.2.840.113549.1.1.1) 	RSAPrivateKey 	|"RSASSA-PKCS1-
v1_5"|, |"RSA-PSS"|, or |"RSA-OAEP"| 	RFC 3447 <#RFC3447>, RFC 5958
<#RFC5958>
id-RSASSA-PSS (1.2.840.113549.1.1.10) 	RSAPrivateKey 	|"RSA-PSS"| 	RFC
3447 <#RFC3447>, RFC 4055 <#RFC4055>, RFC 5958 <#RFC5958>
id-RSAES-OAEP (1.2.840.113549.1.1.7) 	RSAPrivateKey 	|"RSA-OAEP"| 	RFC
3447 <#RFC3447>, RFC 4055 <#RFC4055>, RFC 5958 <#RFC5958>
id-ecPublicKey (1.2.840.10045.2.1) 	ECPrivateKey 	|"ECDH"| or |"ECDSA"|
	RFC 5480 <#RFC5480>, RFC 5915 <#RFC5915>, RFC 5958 <#RFC5958>
id-ecDH (1.3.132.1.12) 	ECPrivateKey 	|"ECDH"| 	RFC 5480 <#RFC5480>, RFC
5915 <#RFC5915>, RFC 5958 <#RFC5958>
id-dsa (1.2.840.10040.4.1) 	INTEGER 	|"DSA"| 	RFC 5958 <#RFC5958>

↑ <#toc>

