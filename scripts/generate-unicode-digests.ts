// SPDX-License-Identifier: LGPL-3.0-or-later
/**
 * Digest generation script for Unicode binary data.
 * Computes SHA-384 hashes for each profile/kind pair and emits a TypeScript
 * module consumed at runtime for integrity verification.
 *
 * Usage (Node >=18):
 *   ts-node scripts/generate-unicode-digests.ts
 * or (after build) with plain node if compiled.
 */
import { createHash } from 'node:crypto';
import { writeFileSync, readFileSync, existsSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';

const PROFILES = ['minimal','standard','complete'] as const;
const KINDS = ['identifier','confusables'] as const;

function fileName(kind: string, profile: string): string {
  return kind === 'identifier'
    ? `unicode-identifier-ranges-${profile}.bin`
    : `unicode-confusables-${profile}.bin`;
}

function hashFile(path: string): string {
  const h = createHash('sha384');
  h.update(readFileSync(path));
  return h.digest('hex');
}

function main(): void {
  const generatedDir = join(process.cwd(), 'src', 'generated');
  const outFile = join(generatedDir, 'unicode-digests.ts');
  if (!existsSync(generatedDir)) mkdirSync(generatedDir, { recursive: true });

  const assignments: string[] = [];
  for (const profile of PROFILES) {
    for (const kind of KINDS) {
      const binPath = join(generatedDir, fileName(kind, profile));
      if (!existsSync(binPath)) {
        console.warn(`[digest] Missing binary file: ${binPath}`);
        continue; // No digest emitted; runtime will fail integrity if required
      }
      const hash = hashFile(binPath);
      assignments.push(
        `data[${JSON.stringify(profile)}] = { ...(data[${JSON.stringify(profile)}]||{}), ${JSON.stringify(kind)}: { algo: 'SHA-384', hash: '${hash}' } };`
      );
    }
  }

  const content = `// AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.
// Generated by scripts/generate-unicode-digests.ts
export const UNICODE_DATA_DIGESTS: Readonly<Record<string, Record<string, { readonly algo: string; readonly hash: string }>>> = (() => {
  const data: Record<string, Record<string, { algo: string; hash: string }>> = {};
${assignments.map(a => `  ${a}`).join('\n')}
  return Object.freeze(data);
})();
`;
  writeFileSync(outFile, content, 'utf8');
  console.log(`[digest] Wrote ${outFile}`);
}
// Execute when run directly (heuristic: last argv equals script name)
try {
  const invoked = process.argv[1] && process.argv[1].includes('generate-unicode-digests');
  if (invoked) main();
} catch (e) {
  console.error('[digest] Failed:', e);
  process.exit(1);
}
