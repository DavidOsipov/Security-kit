// SPDX-License-Identifier: LGPL-3.0-or-later
// SPDX-FileCopyrightText: Â© 2025 David Osipov <personal@david-osipov.vision>

/**
 * Optimized Unicode 16.0.0 binary data loader with profile selection
 * Generated by parse-unicode-data-optimized.ts
 */

import { readFileSync } from "node:fs";
import { join } from "node:path";
import { getUnicodeSecurityConfig } from "../config.ts";
import { verifyUnicodeDataIntegrity } from "../unicodeIntegrity.ts";
import { UNICODE_DATA_DIGESTS } from "./unicode-digests.ts";

export type UnicodeProfile = "minimal" | "standard" | "complete";
export type IdentifierStatus =
  | "Allowed"
  | "Disallowed"
  | "Restricted"
  | "Obsolete";

export interface UnicodeRangeEntry {
  readonly start: number;
  readonly end: number;
  readonly status: IdentifierStatus;
}

export interface UnicodeConfusableEntry {
  readonly source: string;
  readonly target: string;
}

const _STATUS_NAMES: readonly IdentifierStatus[] = [
  "Allowed",
  "Disallowed",
  "Restricted",
  "Obsolete",
] as const;

// In-memory cache for loaded data
const dataCache = new Map<
  string,
  readonly UnicodeRangeEntry[] | readonly UnicodeConfusableEntry[]
>();


// Optional confusables index (Map<char, string[]>) built lazily for O(1) lookups.
let _confusableIndex: Map<string, string[]> | null = null;
let _confusableIndexProfile: string | null = null;

function ensureConfusableIndex(): void {
  const cfg = getUnicodeSecurityConfig();
  if (!cfg.enableConfusableIndex) return; // feature disabled
  const profile = cfg.dataProfile;
  if (_confusableIndex && _confusableIndexProfile === profile) return; // already built for current profile
  const mappings = getConfusables(); // loads data if needed
  const map = new Map<string, string[]>();
  for (const m of mappings) {
    let arr = map.get(m.source);
    if (!arr) {
      arr = [];
      map.set(m.source, arr);
    }
    arr.push(m.target);
  }
  _confusableIndex = map;
  _confusableIndexProfile = profile;
}

function getDataPath(filename: string): string {
  if (typeof __dirname !== "undefined") {
    // Node.js environment
    return join(__dirname, filename);
  } else {
    // Browser/Deno - would need bundler support
    throw new Error(
      "Binary Unicode data loading not supported in this environment",
    );
  }
}

function loadIdentifierRanges(
  profile: UnicodeProfile,
): readonly UnicodeRangeEntry[] {
  const cacheKey = `identifier-ranges-${profile}`;
  if (dataCache.has(cacheKey))
    return dataCache.get(cacheKey) as readonly UnicodeRangeEntry[];
  try {
    const data = readFileSync(
      getDataPath(`unicode-identifier-ranges-${profile}.bin`),
    );
  if (data.length === 0) return [];
  try { verifyUnicodeDataIntegrity("identifier", profile, data); } catch (e) { throw e; }
    const isV2 =
      data.length >= 12 &&
      data[0] === 0x55 &&
      data[1] === 0x31 &&
      data[2] === 0x36 &&
      data[3] === 0x52; // 'U16R'
    const ranges: readonly UnicodeRangeEntry[] = [];
    if (!isV2) {
      for (let offset = 0; offset + 8 <= data.length; offset += 8) {
        const start = data.readUInt32LE(offset);
        const end = data.readUInt32LE(offset + 4);
        ranges.push({ start, end, status: "Allowed" });
      }
    } else {
      const version = data[4];
      if (version !== 2)
        throw new Error(`Unsupported identifier ranges version ${version}`);
      const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
      const count = dv.getUint32(8, true);
      let offset = 12;
      const readVarint = () => {
        let shift = 0;
        let result = 0;
        for (let index = 0; index < 5; index++) {
          if (offset >= data.length) throw new Error("Truncated varint");
          const b = data[offset++];
          result |= (b & 0x7f) << shift;
          if ((b & 0x80) === 0) return result;
          shift += 7;
        }
        throw new Error("Varint too long");
      };
      if (count > 10000) throw new Error("Range count sanity exceeded");
      if (count > 0) {
        let start = readVarint();
        let length = readVarint();
        let end = start + length;
        ranges.push({ start, end, status: "Allowed" });
        for (let index = 1; index < count; index++) {
          const deltaStart = readVarint();
          start = start + deltaStart;
          length = readVarint();
          end = start + length;
          ranges.push({ start, end, status: "Allowed" });
        }
      }
    }
    dataCache.set(cacheKey, ranges);
    return ranges;
  } catch (error) {
    console.warn(
      `Failed to load Unicode identifier ranges for profile ${profile}:`,
      error,
    );
    return [];
  }
}

function loadConfusables(
  profile: UnicodeProfile,
): readonly UnicodeConfusableEntry[] {
  if (profile === "minimal") return [];
  const cacheKey = `confusables-${profile}`;
  if (dataCache.has(cacheKey))
    return dataCache.get(cacheKey) as readonly UnicodeConfusableEntry[];
  try {
    const data = readFileSync(
      getDataPath(`unicode-confusables-${profile}.bin`),
    );
    if (data.length === 0) {
      dataCache.set(cacheKey, []);
      return [];
    }
    try { verifyUnicodeDataIntegrity("confusables", profile, data); } catch (e) { throw e; }
    // v2 magic 'U16C' + version 2 (header >=32 bytes)
    const isV2 =
      data.length >= 32 &&
      data[0] === 0x55 &&
      data[1] === 0x31 &&
      data[2] === 0x36 &&
      data[3] === 0x43 &&
      data[4] === 2;
    let mappings: readonly UnicodeConfusableEntry[] = [];
    if (!isV2) {
      // legacy v1
      if (data.length < 8) throw new Error("Confusables legacy file too small");
      const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
      const stringTableSize = dv.getUint32(0, true);
      const mappingsCount = dv.getUint32(4, true);
      if (8 + stringTableSize + mappingsCount * 4 > data.length)
        throw new Error("Legacy confusables truncated");
      const tableBytes = data.subarray(8, 8 + stringTableSize);
      const table = new TextDecoder()
        .decode(tableBytes)
        .split("\0")
        .filter(Boolean);
      let offset = 8 + stringTableSize;
      mappings = new Array(mappingsCount);
      for (let index = 0; index < mappingsCount; index++) {
        const s = dv.getUint16(offset, true);
        const t = dv.getUint16(offset + 2, true);
        offset += 4;
        mappings[index] = { source: table[s]!, target: table[t]! };
      }
    } else {
      const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
      const singleCount = dv.getUint32(8, true);
      const multiCount = dv.getUint32(12, true);
      const multiBytesSize = dv.getUint32(16, true);
      const mappingCount = dv.getUint32(20, true);
      let offset = 32;
      const single: readonly string[] = new Array(singleCount);
      for (let index = 0; index < singleCount; index++) {
        const cp = dv.getUint32(offset, true);
        offset += 4;
        single[index] = String.fromCodePoint(cp);
      }
      const multiBlock = data.subarray(offset, offset + multiBytesSize);
      offset += multiBytesSize;
      const multi: readonly string[] = new Array(multiCount);
      let previous = "";
      let mOff = 0;
      const decoder = new TextDecoder();
      for (let index_ = 0; index_ < multiCount; index_++) {
        const prefix = multiBlock[mOff++];
        const remLength = multiBlock[mOff++];
        const remBytes = multiBlock.subarray(mOff, mOff + remLength);
        mOff += remLength;
        const rem = decoder.decode(remBytes);
        const full = previous.slice(0, prefix) + rem;
        multi[index_] = full;
        previous = full;
      }
      mappings = new Array(mappingCount);
      let index = 0;
      while (index < mappingCount) {
        const flags = data[offset++];
        const sIsMulti = (flags & 0x01) !== 0;
        const tIsMulti = (flags & 0x02) !== 0;
        const sSmall = (flags & 0x04) !== 0;
        const tSmall = (flags & 0x08) !== 0;
        let sIndex: number;
        let tIndex: number;
        if (sSmall) {
          sIndex = data[offset++];
        } else {
          sIndex = data[offset] | (data[offset + 1] << 8);
          offset += 2;
        }
        if (tSmall) {
          tIndex = data[offset++];
        } else {
          tIndex = data[offset] | (data[offset + 1] << 8);
          offset += 2;
        }
        const source = sIsMulti ? multi[sIndex] : single[sIndex];
        const target = tIsMulti ? multi[tIndex] : single[tIndex];
        if (!source || !target)
          throw new Error("Confusables mapping index out of bounds");
        mappings[index++] = { source, target };
      }
    }
    dataCache.set(cacheKey, mappings);
    return mappings;
  } catch (error) {
    console.warn(
      `Failed to load Unicode confusables for profile ${profile}:`,
      error,
    );
    return [];
  }
}

/**
 * Get Unicode identifier validation ranges for the configured profile
 */
export function getIdentifierRanges(): readonly UnicodeRangeEntry[] {
  const config = getUnicodeSecurityConfig();
  return loadIdentifierRanges(config.dataProfile);
}

/**
 * Get Unicode confusables mappings for the configured profile
 */
export function getConfusables(): readonly UnicodeConfusableEntry[] {
  const config = getUnicodeSecurityConfig();
  return loadConfusables(config.dataProfile);
}

/**
 * Check if a code point has a specific identifier status
 */
export function getIdentifierStatus(
  codePoint: number,
): IdentifierStatus | undefined {
  const ranges = getIdentifierRanges();

  for (const range of ranges) {
    if (codePoint >= range.start && codePoint <= range.end) {
      return range.status;
    }
  }

  return undefined;
}

/**
 * Find confusable targets for a given character
 */
function normalizeInputChar(c: string): string {
  return c ? c.normalize("NFC") : "";
}
export function getConfusableTargets(char: string): readonly string[] {
  const norm = normalizeInputChar(char);
  const cfg = getUnicodeSecurityConfig();
  if (cfg.enableConfusableIndex) {
    ensureConfusableIndex();
    const targets = _confusableIndex?.get(norm);
    return targets ? [...targets] : [];
  }
  const confusables = getConfusables();
  return confusables.filter((e) => e.source === norm).map((e) => e.target);
}

/**
 * Check if a character is confusable with another
 */
export function isConfusable(char1: string, char2: string): boolean {
  const a = normalizeInputChar(char1);
  const b = normalizeInputChar(char2);
  if (!a || !b) return false;
  const cfg = getUnicodeSecurityConfig();
  if (cfg.enableConfusableIndex) {
    ensureConfusableIndex();
    const aTargets = _confusableIndex?.get(a);
    if (aTargets && aTargets.includes(b)) return true;
    const bTargets = _confusableIndex?.get(b);
    if (bTargets && bTargets.includes(a)) return true;
    return false;
  }
  const confusables = getConfusables();
  return confusables.some(
    (entry) =>
      (entry.source === a && entry.target === b) ||
      (entry.source === b && entry.target === a),
  );
}

/**
 * Get data size statistics for the current profile
 */
export interface UnicodeDataStats {
  readonly ranges: number;
  readonly confusables: number;
  readonly totalBytes: number;
}
export function getDataStats(): UnicodeDataStats {
  const ranges = getIdentifierRanges();
  const confusables = getConfusables();
  const rangeBytes = ranges.length * 12;
  const confusableBytes = confusables.reduce(
    (sum, e) => sum + e.source.length * 2 + e.target.length * 2,
    0,
  );
  return Object.freeze({
    ranges: ranges.length,
    confusables: confusables.length,
    totalBytes: rangeBytes + confusableBytes,
  });
}
