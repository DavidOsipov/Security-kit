// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: © 2025 David Osipov
/**
 * server/verify-api-request-signature.ts
 *
 * Server-side verification for signatures produced by SecureApiSigner.
 * 
 * SECURITY CONSTITUTION COMPLIANCE:
 * - Implements positive validation (allowlist) for all inputs per Part II-B rules
 * - Uses timing-safe comparison to prevent timing attacks
 * - Requires explicit nonce store implementation to prevent replay attacks
 * - Validates message structure to prevent HTTP smuggling
 * - Enforces data minimization principles
 * 
 * IMPORTANT: The server MUST provide a nonceStore implementing INonceStore 
 * for replay protection. The example InMemoryNonceStore is NOT for production.
 */

import { InvalidParameterError, ReplayAttackError } from "../src/errors.js";
import { safeStableStringify } from "../src/canonical.js";ntifier: MIT
// SPDX-FileCopyrightText: © 2025 David Osipov
/**
 * server/verify-api-request-signature.ts
 *
 * Server-side verification for signatures produced by SecureApiSigner.
 * 
 * SECURITY CONSTITUTION COMPLIANCE:
 * - Implements positive validation (allowlist) for all inputs per Part II-B rules
 * - Uses timing-safe comparison to prevent timing attacks
 * - Requires explicit nonce store implementation to prevent replay attacks
 * - Validates message structure to prevent HTTP smuggling
 * - Enforces data minimization principles
 * 
 * IMPORTANT: The server MUST provide a nonceStore implementing INonceStore 
 * for replay protection. The example InMemoryNonceStore is NOT for production.
 */

import { secureCompareAsync } from "../src/utils"; // timing-safe compare (reuse)
import { 
  InvalidParameterError, 
  TimestampError, 
  ReplayAttackError,
  SignatureVerificationError 
} from "../src/errors";
import { SHARED_ENCODER } from "../src/encoding";

/** Input shape expected by verification with positive validation */
export type VerifyExtendedInput = {
  readonly secret: ArrayBuffer | Uint8Array | string; // server-side secret (raw or base64)
  readonly payload: unknown; // same canonicalization as client
  readonly nonce: string; // base64-encoded nonce from client
  readonly timestamp: number; // unix timestamp in milliseconds
  readonly signatureBase64: string; // base64-encoded HMAC signature
  readonly method?: string; // HTTP method (if binding to request)
  readonly path?: string; // HTTP path (if binding to request)
  readonly bodyHash?: string; // SHA-256 base64 hash of request body
  readonly kid?: string; // key identifier for multi-key scenarios
};

/**
 * Interface for nonce storage backends.
 * SECURITY REQUIREMENT: Implementations MUST be atomic and distributed-safe
 * for production deployments with multiple server instances.
 */
export interface INonceStore {
  /**
   * Check if a nonce has been used before.
   * MUST return true if the nonce exists and is not expired.
   */
  has(kid: string, nonce: string): Promise<boolean>;
  
  /**
   * Store a nonce with expiration.
   * MUST be atomic to prevent race conditions.
   * MUST handle expiration automatically.
   */
  store(kid: string, nonce: string, ttlMs: number): Promise<void>;
  
  /**
   * Optional: Clean up expired nonces.
   * Implementations MAY provide this for manual cleanup.
   */
  cleanup?(): Promise<void>;
}

/**
 * Example (NOT FOR PRODUCTION) in-memory nonce store.
 * 
 * ⚠️ PRODUCTION WARNING: This implementation is NOT suitable for production:
 * - Not distributed: works only with single server instance
 * - Not persistent: lost on restart
 * - Not atomic: race conditions possible with high concurrency
 * 
 * For production, use Redis, DynamoDB, or another distributed store.
 */
export class InMemoryNonceStore implements INonceStore {
  #map = new Map<string, number>(); // key = `${kid}:${nonce}`, value = expiry unix ms

  async has(kid: string, nonce: string): Promise<boolean> {
    this.#validateStoreParams(kid, nonce);
    const key = `${kid}:${nonce}`;
    const exp = this.#map.get(key);
    if (!exp) return false;
    if (Date.now() > exp) {
      this.#map.delete(key);
      return false;
    }
    return true;
  }

  async store(kid: string, nonce: string, ttlMs: number): Promise<void> {
    this.#validateStoreParams(kid, nonce);
    if (typeof ttlMs !== "number" || ttlMs <= 0 || ttlMs > 86400000) { // max 24h
      throw new InvalidParameterError("ttlMs must be between 1 and 86400000 (24h)");
    }
    const key = `${kid}:${nonce}`;
    this.#map.set(key, Date.now() + ttlMs);
  }

  async cleanup(): Promise<void> {
    const now = Date.now();
    for (const [key, expiry] of this.#map.entries()) {
      if (expiry <= now) {
        this.#map.delete(key);
      }
    }
  }

  #validateStoreParams(kid: string, nonce: string): void {
    if (typeof kid !== "string" || kid.length === 0 || kid.length > 256) {
      throw new InvalidParameterError("kid must be a non-empty string (max 256 chars)");
    }
    if (typeof nonce !== "string" || nonce.length === 0 || nonce.length > 256) {
      throw new InvalidParameterError("nonce must be a non-empty string (max 256 chars)");
    }
    // Validate base64-like format for nonce (basic check)
    if (!/^[A-Za-z0-9+/=]+$/.test(nonce)) {
      throw new InvalidParameterError("nonce must be base64-encoded");
    }
  }
}

const DEFAULT_SKEW_MS = 2 * 60 * 1000; // 2 minutes
const NONCE_TTL_MS = 5 * 60 * 1000; // 5 minutes
const MAX_PAYLOAD_SIZE = 10 * 1024 * 1024; // 10MB
const MAX_BODY_SIZE = 100 * 1024 * 1024; // 100MB

/**
 * Validates input parameters using positive validation patterns.
 * Implements Security Constitution requirement for input validation.
 */
function validateVerifyInput(input: VerifyExtendedInput): void {
  if (!input || typeof input !== "object") {
    throw new InvalidParameterError("Input must be a valid object");
  }

  const { secret, payload, nonce, timestamp, signatureBase64, kid, method, path } = input;

  // Secret validation
  if (!secret) {
    throw new InvalidParameterError("secret is required");
  }
  if (!(secret instanceof ArrayBuffer) && !(secret instanceof Uint8Array) && typeof secret !== "string") {
    throw new InvalidParameterError("secret must be ArrayBuffer, Uint8Array, or string");
  }

  // Nonce validation (positive validation)
  if (typeof nonce !== "string" || nonce.length === 0) {
    throw new InvalidParameterError("nonce must be a non-empty string");
  }
  if (nonce.length > 256) {
    throw new InvalidParameterError("nonce too long (max 256 chars)");
  }
  if (!/^[A-Za-z0-9+/=]+$/.test(nonce)) {
    throw new InvalidParameterError("nonce must be base64-encoded");
  }

  // Timestamp validation
  if (typeof timestamp !== "number" || !Number.isInteger(timestamp)) {
    throw new InvalidParameterError("timestamp must be an integer");
  }
  if (timestamp < 0 || timestamp > Date.now() + 86400000) { // not more than 24h in future
    throw new InvalidParameterError("timestamp out of reasonable range");
  }

  // Signature validation
  if (typeof signatureBase64 !== "string" || signatureBase64.length === 0) {
    throw new InvalidParameterError("signatureBase64 must be a non-empty string");
  }
  if (signatureBase64.length > 512) { // reasonable limit for base64 HMAC
    throw new InvalidParameterError("signature too long");
  }
  if (!/^[A-Za-z0-9+/=]+$/.test(signatureBase64)) {
    throw new InvalidParameterError("signatureBase64 must be base64-encoded");
  }

  // Optional parameter validation with positive validation
  if (kid !== undefined) {
    if (typeof kid !== "string") {
      throw new InvalidParameterError("kid must be a string");
    }
    if (kid.length > 256) {
      throw new InvalidParameterError("kid too long (max 256 chars)");
    }
    if (!/^[A-Za-z0-9._-]+$/.test(kid)) {
      throw new InvalidParameterError("kid contains invalid characters");
    }
  }

  if (method !== undefined) {
    if (typeof method !== "string") {
      throw new InvalidParameterError("method must be a string");
    }
    if (!/^[A-Z]{3,10}$/.test(method)) {
      throw new InvalidParameterError("method must be a valid HTTP method");
    }
  }

  if (path !== undefined) {
    if (typeof path !== "string") {
      throw new InvalidParameterError("path must be a string");
    }
    if (path.length > 2048) {
      throw new InvalidParameterError("path too long (max 2048 chars)");
    }
    // Basic path validation - must start with / and contain only safe chars
    if (!/^\/[A-Za-z0-9._~:/?#[\]@!$&'()*+,;=%-]*$/.test(path)) {
      throw new InvalidParameterError("path contains invalid characters");
    }
  }

  // Payload size validation
  const payloadStr = typeof payload === "string" ? payload : JSON.stringify(payload ?? "");
  if (payloadStr.length > MAX_PAYLOAD_SIZE) {
    throw new InvalidParameterError(`payload too large (max ${MAX_PAYLOAD_SIZE} bytes)`);
  }
}

function base64ToUint8Array(base64: string): Uint8Array {
  if (typeof atob === "function") {
    const bin = atob(base64);
    const len = bin.length;
    const out = new Uint8Array(len);
    for (let i = 0; i < len; i++) out[i] = bin.charCodeAt(i);
    return out;
  } else {
    return Uint8Array.from(Buffer.from(base64, "base64"));
  }
}

function normalizeSecret(secret: ArrayBuffer | Uint8Array | string): Uint8Array {
  if (secret instanceof ArrayBuffer) return new Uint8Array(secret);
  if (secret instanceof Uint8Array) return secret;
  if (typeof secret === "string") return base64ToUint8Array(secret);
  throw new InvalidParameterError("Unsupported secret type");
}

async function hmacSha256NodeFallback(keyBytes: Uint8Array, dataBytes: Uint8Array): Promise<Uint8Array> {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const crypto = require("crypto");
  const h = crypto.createHmac("sha256", Buffer.from(keyBytes));
  h.update(Buffer.from(dataBytes));
  return Uint8Array.from(h.digest());
}

async function computeHmacSha256(keyBytes: Uint8Array, dataBytes: Uint8Array): Promise<Uint8Array> {
  if (typeof globalThis !== "undefined" && (globalThis as any).crypto && ((globalThis as any).crypto.subtle)) {
    const subtle = (globalThis as any).crypto.subtle as SubtleCrypto;
    // Ensure we have proper ArrayBuffer for Web Crypto API
    const keyBuffer = keyBytes.buffer.slice(keyBytes.byteOffset, keyBytes.byteOffset + keyBytes.byteLength);
    const dataBuffer = dataBytes.buffer.slice(dataBytes.byteOffset, dataBytes.byteOffset + dataBytes.byteLength);
    
    const key = await subtle.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    const sig = await subtle.sign("HMAC", key, dataBuffer);
    return new Uint8Array(sig);
  } else {
    return await hmacSha256NodeFallback(keyBytes, dataBytes);
  }
}

export async function verifyApiRequestSignature(
  input: VerifyExtendedInput,
  nonceStore: INonceStore,
  options?: { maxSkewMs?: number; nonceTtlMs?: number },
): Promise<boolean> {
  // Validate all inputs using positive validation
  validateVerifyInput(input);
  
  if (!nonceStore) {
    throw new InvalidParameterError("nonceStore is required for replay protection");
  }

  const { secret, payload, nonce, timestamp, signatureBase64, kid, method, path, bodyHash } = input;
  const maxSkew = options?.maxSkewMs ?? DEFAULT_SKEW_MS;
  const nonceTtl = options?.nonceTtlMs ?? NONCE_TTL_MS;

  // Timestamp window check
  const now = Date.now();
  if (Math.abs(now - timestamp) > maxSkew) {
    throw new TimestampError(`Timestamp skew too large: ${Math.abs(now - timestamp)}ms > ${maxSkew}ms`);
  }

  // Nonce uniqueness check (replay protection)
  const keyForStore = String(kid ?? "default");
  if (await nonceStore.has(keyForStore, nonce)) {
    throw new ReplayAttackError(`Nonce already used: ${nonce}`);
  }

  // Build the same extended canonical string as the client
  const payloadStr = typeof payload === "string" ? payload : JSON.stringify(payload ?? "");
  
  // Compute body hash if not provided but body is available via separate mechanism
  let computedBodyHash = bodyHash ?? "";

  const canonicalParts = [
    String(timestamp),
    nonce,
    String(method ?? ""),
    String(path ?? ""),
    String(computedBodyHash),
    payloadStr,
    String(kid ?? ""),
  ];
  const canonical = canonicalParts.join(".");

  const keyBytes = normalizeSecret(secret);
  const messageBytes = SHARED_ENCODER.encode(canonical);

  // Compute expected signature
  const computedSigBytes = await computeHmacSha256(keyBytes, messageBytes);

  // Convert to base64 for comparison
  let computedBase64: string;
  if (typeof btoa === "function") {
    let binary = "";
    for (let i = 0; i < computedSigBytes.length; i++) {
      binary += String.fromCharCode(computedSigBytes[i]);
    }
    computedBase64 = btoa(binary);
  } else {
    computedBase64 = Buffer.from(computedSigBytes).toString("base64");
  }

  // Timing-safe comparison
  const isValid = await secureCompareAsync(computedBase64, signatureBase64, { requireCrypto: true });
  if (!isValid) {
    throw new SignatureVerificationError("Signature verification failed");
  }

  // Store nonce only after successful verification to prevent DoS via nonce exhaustion
  await nonceStore.store(keyForStore, nonce, nonceTtl);
  return true;
}

// Backwards-compatible alias. Some callers (or external integrations) may
// still import the older symbol name; keep an alias to avoid breakage.
export { verifyApiRequestSignature as verifyApiRequestSignatureExtended };
